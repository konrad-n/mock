U≈ºytkownik chce, ≈ºebym:
1. Przeanalizowa≈Ç ca≈Çy codebase aplikacji SledzSpecke
2. Por√≥wna≈Ç go z przyk≈Çadem w CLAUDEAPIEXAMPLE.xml jako wzorcem dobrych praktyk
3. Oceni≈Ç czy kod jest napisany zgodnie z zasadami SOLID i clean code
4. Przygotowa≈Ç szczeg√≥≈ÇowƒÖ instrukcjƒô dla junior developera z listƒÖ rzeczy do poprawy

Najpierw muszƒô przeszukaƒá projekt, ≈ºeby znale≈∫ƒá wszystkie pliki kodu i przyk≈Çad CLAUDEAPIEXAMPLE.xml.

Przeszukam ca≈Çy codebase aplikacji SledzSpecke oraz przyk≈Çad CLAUDEAPIEXAMPLE.xml, aby przeprowadziƒá dok≈ÇadnƒÖ analizƒô.

Searched project for ‚ÄúCLAUDEAPIEXAMPLE.xml‚Äù

Znalaz≈Çem plik SOLIDAPIEXAMPLE.xml, kt√≥ry pokazuje przyk≈Çady dobrych praktyk. Teraz muszƒô przeszukaƒá wiƒôcej plik√≥w z codebase SledzSpecke, ≈ºeby por√≥wnaƒá jako≈õƒá kodu.

Searched project for ‚ÄúSledzSpecke.Core ValueObjects Entities‚Äù

≈öwietnie, teraz widzƒô przyk≈Çady z obu projekt√≥w. Mogƒô por√≥wnaƒá jako≈õƒá kodu. Poszukam jeszcze wiƒôcej plik√≥w z SledzSpecke, szczeg√≥lnie z warstwy Application i Infrastructure.

Searched project for ‚ÄúSledzSpecke Application Commands Handlers CQRS‚Äù

Teraz poszukam wiƒôcej plik√≥w z Infrastructure layer, ≈ºeby zobaczyƒá jak zaimplementowane sƒÖ repozytoria i inne elementy infrastrukturalne.

Searched project for ‚ÄúSledzSpecke Infrastructure Repository PostgresContext EntityTypeConfiguration‚Äù

≈öwietnie, teraz mam dobre wyobra≈ºenie o jako≈õci kodu w projekcie SledzSpecke. Mogƒô por√≥wnaƒá to z przyk≈Çadem SOLIDAPIEXAMPLE.xml i przygotowaƒá szczeg√≥≈ÇowƒÖ instrukcjƒô dla junior developera.

G≈Ç√≥wne problemy, kt√≥re widzƒô:
1. Brak konsekwentnego u≈ºycia Value Objects - wiele miejsc gdzie u≈ºywane sƒÖ prymitywne typy
2. Mieszanie starych i nowych pattern'√≥w (np. niekt√≥re handlery u≈ºywajƒÖ Result pattern, inne rzucajƒÖ wyjƒÖtki)
3. Brak konsekwentnego stosowania DDD (Domain Services, Aggregate Roots)
4. Brak w≈Ça≈õciwej enkapsulacji w encjach (publiczne settery)
5. S≈Çabe u≈ºycie wzorca Repository (brak specyfikacji, query objects)
6. Mieszanie logiki biznesowej w handlerach zamiast w domenie
7. Brak konsekwentnego u≈ºycia IUnitOfWork
8. Brak konsekwentnego podej≈õcia do walidacji
9. Nie ma Domain Events
10. Brak konsekwentnego podej≈õcia do obs≈Çugi b≈Çƒôd√≥w

Przygotujƒô teraz szczeg√≥≈ÇowƒÖ instrukcjƒô.

Na podstawie analizy kodu SledzSpecke w por√≥wnaniu z przyk≈Çadem CLAUDEAPIEXAMPLE.xml, przygotowa≈Çem szczeg√≥≈ÇowƒÖ instrukcjƒô poprawy jako≈õci kodu dla junior developera.

# Instrukcja Poprawy Kodu SledzSpecke - Przewodnik dla Junior Developera

## üéØ Wprowadzenie

Po dok≈Çadnej analizie kodu SledzSpecke w por√≥wnaniu z przyk≈Çadem MySpot (CLAUDEAPIEXAMPLE.xml), zidentyfikowa≈Çem kluczowe obszary wymagajƒÖce poprawy. Ten dokument stanowi szczeg√≥≈ÇowƒÖ mapƒô drogowƒÖ do refaktoryzacji aplikacji zgodnie z najlepszymi praktykami i zasadami SOLID.

## üî¥ KRYTYCZNE: G≈Ç√≥wne Problemy do Naprawienia

### 1. **Primitive Obsession - Nadu≈ºywanie Typ√≥w Prymitywnych**

#### ‚ùå Obecny stan (Z≈ÅY):
```csharp
public class User
{
    public int Id { get; set; }
    public string Email { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public string FullName { get; set; }
    public string SmkVersion { get; set; } // "OldSMK" lub "NewSMK"
}
```

#### ‚úÖ Jak powinno byƒá (MySpot pattern):
```csharp
public class User
{
    public UserId Id { get; private set; }
    public Email Email { get; private set; }
    public Username Username { get; private set; }
    public Password Password { get; private set; }
    public FullName FullName { get; private set; }
    public SmkVersion SmkVersion { get; private set; }
    
    // Prywatny konstruktor - enkapsulacja
    private User() { }
    
    // Factory method z walidacjƒÖ
    public static User Create(
        UserId id,
        Email email,
        Username username,
        Password password,
        FullName fullName,
        SmkVersion smkVersion)
    {
        var user = new User
        {
            Id = id,
            Email = email,
            Username = username,
            Password = password,
            FullName = fullName,
            SmkVersion = smkVersion,
        };
        
        return user;
    }
}
```

#### üìù Zadania:
1. Stw√≥rz Value Objects dla KA≈ªDEGO pola, kt√≥re nie jest prymitywnym typem biznesowym
2. Dodaj walidacjƒô w konstruktorach Value Objects
3. U≈ºyj konwersji implicit/explicit operators
4. Przyk≈Çad implementacji Email:

```csharp
public sealed record Email
{
    public string Value { get; }
    
    public Email(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new EmptyEmailException();
        }
        
        if (!IsValidEmail(value))
        {
            throw new InvalidEmailException(value);
        }
        
        Value = value.ToLowerInvariant();
    }
    
    private static bool IsValidEmail(string email)
        => new EmailAddressAttribute().IsValid(email);
    
    public static implicit operator string(Email email)
        => email.Value;
    
    public static implicit operator Email(string value)
        => new (value);
    
    public override string ToString() => Value;
}
```

### 2. **Niesp√≥jna Obs≈Çuga B≈Çƒôd√≥w**

#### ‚ùå Obecny stan (NIESP√ìJNY):
```csharp
// Niekt√≥re handlery rzucajƒÖ wyjƒÖtki
public async Task HandleAsync(AddMedicalShift command)
{
    var internship = await _internshipRepository.GetByIdAsync(command.InternshipId);
    if (internship is null)
    {
        throw new InvalidOperationException($"Internship not found");
    }
}

// Inne u≈ºywajƒÖ Result pattern
public async Task<Result<int>> HandleAsync(CreateCourse command)
{
    if (string.IsNullOrWhiteSpace(command.Name))
    {
        return Result<int>.Failure("Course name is required");
    }
}
```

#### ‚úÖ Jak powinno byƒá (SP√ìJNIE - wybierz JEDEN spos√≥b):

**Opcja 1 - Domain Exceptions (jak MySpot):**
```csharp
public async Task HandleAsync(AddMedicalShift command)
{
    var internship = await _internshipRepository.GetByIdAsync(command.InternshipId);
    if (internship is null)
    {
        throw new InternshipNotFoundException(command.InternshipId);
    }
    
    // Logika biznesowa w domenie
    internship.AddMedicalShift(/* parametry */);
    
    await _internshipRepository.UpdateAsync(internship);
}
```

**Opcja 2 - Result Pattern wszƒôdzie:**
```csharp
public async Task<Result> HandleAsync(AddMedicalShift command)
{
    var internship = await _internshipRepository.GetByIdAsync(command.InternshipId);
    if (internship is null)
    {
        return Result.Failure($"Internship with ID {command.InternshipId} not found", 
            ErrorCodes.INTERNSHIP_NOT_FOUND);
    }
    
    var addResult = internship.AddMedicalShift(/* parametry */);
    if (addResult.IsFailure)
    {
        return addResult;
    }
    
    await _internshipRepository.UpdateAsync(internship);
    return Result.Success();
}
```

### 3. **Brak W≈Ça≈õciwej Enkapsulacji w Encjach**

#### ‚ùå Obecny stan (Z≈ÅY):
```csharp
public class Internship
{
    public int Id { get; set; }
    public string Department { get; set; }
    public DateTime StartDate { get; set; }
    public DateTime? EndDate { get; set; }
    public List<MedicalShift> MedicalShifts { get; set; } = new ();
}
```

#### ‚úÖ Jak powinno byƒá (DDD Aggregate):
```csharp
public sealed class Internship
{
    private readonly List<MedicalShift> _medicalShifts = new ();
    
    public InternshipId Id { get; private set; }
    public Department Department { get; private set; }
    public DateRange Period { get; private set; }
    public IReadOnlyCollection<MedicalShift> MedicalShifts => _medicalShifts.AsReadOnly();
    
    // Prywatny konstruktor
    private Internship() { }
    
    // Factory method
    public static Internship Create(
        InternshipId id,
        Department department,
        Date startDate,
        Date? endDate = null)
    {
        return new Internship
        {
            Id = id,
            Department = department,
            Period = new DateRange(startDate, endDate),
        };
    }
    
    // Metody biznesowe z logikƒÖ
    public Result AddMedicalShift(Date date, Hours duration, Location location)
    {
        // Walidacja biznesowa
        if (!Period.Contains(date))
        {
            return Result.Failure("Medical shift date must be within internship period");
        }
        
        var shift = MedicalShift.Create(
            MedicalShiftId.New(),
            Id,
            date,
            duration,
            location);
            
        _medicalShifts.Add(shift);
        
        // Raise domain event
        AddDomainEvent(new MedicalShiftAddedEvent(Id, shift.Id));
        
        return Result.Success();
    }
    
    public void Complete(Date completionDate)
    {
        if (Period.EndDate.HasValue)
        {
            throw new InternshipAlreadyCompletedException(Id);
        }
        
        Period = Period.WithEndDate(completionDate);
        AddDomainEvent(new InternshipCompletedEvent(Id, completionDate));
    }
}
```

### 4. **Brak Domain Services**

#### ‚ùå Obecny stan (logika w handlerach):
```csharp
public class AddMedicalShiftHandler
{
    public async Task HandleAsync(AddMedicalShift command)
    {
        // Ca≈Ça logika biznesowa w handlerze
        var internship = await _repository.GetByIdAsync(command.InternshipId);
        
        // Skomplikowana walidacja
        if (specialization.SmkVersion == "NewSMK")
        {
            // du≈ºo kodu walidacyjnego
        }
        
        // Tworzenie encji
        var shift = new MedicalShift { /* ... */ };
        
        // Zapis
        await _repository.AddAsync(shift);
    }
}
```

#### ‚úÖ Jak powinno byƒá (Domain Service):
```csharp
// Domain Service
public sealed class MedicalShiftService
{
    private readonly IClock _clock;
    
    public MedicalShiftService(IClock clock)
    {
        _clock = clock;
    }
    
    public Result<MedicalShift> CreateMedicalShift(
        Internship internship,
        Specialization specialization,
        Date date,
        Hours duration,
        Location location)
    {
        // Ca≈Ça logika biznesowa tutaj
        var validationResult = ValidateShiftCreation(
            internship, 
            specialization, 
            date, 
            duration);
            
        if (validationResult.IsFailure)
        {
            return Result<MedicalShift>.Failure(validationResult.Error);
        }
        
        var shift = MedicalShift.Create(
            MedicalShiftId.New(),
            internship.Id,
            date,
            duration,
            location,
            _clock.Current());
            
        return Result<MedicalShift>.Success(shift);
    }
    
    private Result ValidateShiftCreation(/* parametry */)
    {
        // Walidacja biznesowa
    }
}

// Handler - tylko orkiestracja
public sealed class AddMedicalShiftHandler : ICommandHandler<AddMedicalShift>
{
    private readonly IInternshipRepository _internshipRepository;
    private readonly IMedicalShiftRepository _shiftRepository;
    private readonly MedicalShiftService _shiftService;
    private readonly IUnitOfWork _unitOfWork;
    
    public async Task HandleAsync(AddMedicalShift command)
    {
        var internship = await _internshipRepository.GetByIdAsync(
            new InternshipId(command.InternshipId));
            
        if (internship is null)
        {
            throw new InternshipNotFoundException(command.InternshipId);
        }
        
        var specialization = await _specializationRepository.GetByIdAsync(
            internship.SpecializationId);
            
        var createResult = _shiftService.CreateMedicalShift(
            internship,
            specialization,
            new Date(command.Date),
            new Hours(command.Hours),
            new Location(command.Location));
            
        if (createResult.IsFailure)
        {
            throw new CannotCreateMedicalShiftException(createResult.Error);
        }
        
        await _shiftRepository.AddAsync(createResult.Value);
        await _unitOfWork.CommitAsync();
    }
}
```

### 5. **Brak Policies Pattern**

#### Dodaj Policies dla skomplikowanych regu≈Ç biznesowych:

```csharp
// Interface
public interface ISpecializationPolicy
{
    bool CanBeApplied(SmkVersion version);
    Result Validate(Specialization specialization, MedicalShift shift);
}

// Implementacja dla Old SMK
public sealed class OldSmkMedicalShiftPolicy : ISpecializationPolicy
{
    public bool CanBeApplied(SmkVersion version)
        => version == SmkVersion.Old;
        
    public Result Validate(Specialization specialization, MedicalShift shift)
    {
        // Walidacja specyficzna dla Old SMK
        if (shift.Duration < Hours.FromMinutes(60))
        {
            return Result.Failure("Medical shift in Old SMK must be at least 1 hour");
        }
        
        return Result.Success();
    }
}

// Implementacja dla New SMK  
public sealed class NewSmkMedicalShiftPolicy : ISpecializationPolicy
{
    public bool CanBeApplied(SmkVersion version)
        => version == SmkVersion.New;
        
    public Result Validate(Specialization specialization, MedicalShift shift)
    {
        // Walidacja specyficzna dla New SMK
        if (!shift.Supervisor.HasValue)
        {
            return Result.Failure("Supervisor is required for New SMK");
        }
        
        return Result.Success();
    }
}

// Policy selector
public sealed class SpecializationPolicySelector
{
    private readonly IEnumerable<ISpecializationPolicy> _policies;
    
    public SpecializationPolicySelector(IEnumerable<ISpecializationPolicy> policies)
    {
        _policies = policies;
    }
    
    public ISpecializationPolicy SelectPolicy(SmkVersion version)
    {
        var policy = _policies.SingleOrDefault(p => p.CanBeApplied(version));
        if (policy is null)
        {
            throw new NoSpecializationPolicyFoundException(version);
        }
        
        return policy;
    }
}
```

### 6. **Brak Domain Events**

#### Dodaj Domain Events:

```csharp
// Base class
public abstract record DomainEvent
{
    public Guid Id { get; } = Guid.NewGuid();
    public DateTime OccurredAt { get; } = DateTime.UtcNow;
}

// Konkretne eventy
public sealed record MedicalShiftAdded(
    InternshipId InternshipId,
    MedicalShiftId ShiftId,
    Date Date,
    Hours Duration) : DomainEvent;

public sealed record InternshipCompleted(
    InternshipId InternshipId,
    Date CompletionDate) : DomainEvent;

// Aggregate Root base
public abstract class AggregateRoot
{
    private readonly List<DomainEvent> _domainEvents = new ();
    
    public IReadOnlyCollection<DomainEvent> DomainEvents => _domainEvents.AsReadOnly();
    
    protected void AddDomainEvent(DomainEvent domainEvent)
    {
        _domainEvents.Add(domainEvent);
    }
    
    public void ClearDomainEvents()
    {
        _domainEvents.Clear();
    }
}
```

### 7. **Poprawki w Repozytoriach**

#### ‚ùå Obecny stan:
```csharp
public interface IUserRepository
{
    Task<User?> GetByIdAsync(UserId id);
    Task<User?> GetByUsernameAsync(Username username);
    Task<User?> GetByEmailAsync(Email email);
    Task<IEnumerable<User>> GetAllAsync();
    Task<UserId> AddAsync(User user);
    Task UpdateAsync(User user);
    Task DeleteAsync(UserId id);
}
```

#### ‚úÖ Jak powinno byƒá (ze Specification Pattern):
```csharp
public interface IUserRepository
{
    Task<User?> GetByIdAsync(UserId id);
    Task<User?> GetAsync(ISpecification<User> specification);
    Task<IEnumerable<User>> BrowseAsync(ISpecification<User> specification);
    Task AddAsync(User user);
    Task UpdateAsync(User user);
    Task DeleteAsync(User user);
    Task<bool> ExistsAsync(ISpecification<User> specification);
}

// Specifications
public sealed class UserByEmailSpecification : ISpecification<User>
{
    public Email Email { get; }
    
    public UserByEmailSpecification(Email email)
    {
        Email = email;
    }
    
    public IQueryable<User> Apply(IQueryable<User> query)
        => query.Where(u => u.Email == Email);
}

// U≈ºycie
var user = await _userRepository.GetAsync(
    new UserByEmailSpecification(new Email("user@example.com")));
```

## üìã Plan Refaktoryzacji - Krok po Kroku

### Faza 1: Value Objects (2-3 dni)
1. **Dzie≈Ñ 1**: Stw√≥rz podstawowe Value Objects
   - `UserId`, `Email`, `Username`, `Password`, `FullName`
   - `SmkVersion`, `SpecializationId`, `ModuleId`
   - `Date`, `DateRange`, `Hours`, `Minutes`

2. **Dzie≈Ñ 2**: Stw√≥rz domenowe Value Objects
   - `Location`, `Institution`, `Department`  
   - `ProcedureCode`, `CourseCode`
   - `PhoneNumber`, `Language`, `Theme`

3. **Dzie≈Ñ 3**: Zastosuj Value Objects w encjach
   - Zaktualizuj wszystkie encje
   - Popraw konfiguracje EF Core
   - Napisz testy jednostkowe

### Faza 2: Domain Model (3-4 dni)
1. **Dzie≈Ñ 4-5**: Refaktoryzacja encji
   - Dodaj prywatne konstruktory
   - Implementuj factory methods
   - Dodaj metody biznesowe
   - Ustal Aggregate Roots

2. **Dzie≈Ñ 6-7**: Domain Services i Policies
   - Wydziel logikƒô z handler√≥w
   - Stw√≥rz domain services
   - Implementuj policies

### Faza 3: Application Layer (2-3 dni)
1. **Dzie≈Ñ 8-9**: Refaktoryzacja handler√≥w
   - Upro≈õƒá handlery (tylko orkiestracja)
   - Zdecyduj: Exceptions czy Result Pattern
   - Dodaj Unit of Work

2. **Dzie≈Ñ 10**: Dodaj Domain Events
   - Implementuj event dispatching
   - Dodaj event handlers

### Faza 4: Infrastructure (1-2 dni)
1. **Dzie≈Ñ 11-12**: 
   - Zaktualizuj repozytoria
   - Dodaj Specification Pattern
   - Popraw konfiguracje EF Core

## üß™ Testowanie

### Struktura test√≥w:
```csharp
// Unit Tests - Domain
public class MedicalShiftTests
{
    [Fact]
    public void Create_ShouldThrowException_WhenDurationIsNegative()
    {
        // Arrange
        var duration = Hours.FromMinutes(-30);
        
        // Act & Assert
        Assert.Throws<InvalidMedicalShiftDurationException>(() =>
            MedicalShift.Create(
                MedicalShiftId.New(),
                InternshipId.New(),
                Date.Now(),
                duration,
                new Location("Hospital")));
    }
}

// Integration Tests - Handlers
public class AddMedicalShiftHandlerTests : IDisposable
{
    private readonly TestDatabase _database;
    private readonly ICommandHandler<AddMedicalShift> _handler;
    
    [Fact]
    public async Task HandleAsync_ShouldAddMedicalShift_WhenDataIsValid()
    {
        // Arrange
        var internship = await GivenInternship();
        var command = new AddMedicalShift(
            internship.Id,
            DateTime.Now,
            480); // 8 hours
            
        // Act
        await _handler.HandleAsync(command);
        
        // Assert
        var shifts = await _database.MedicalShifts
            .Where(s => s.InternshipId == internship.Id)
            .ToListAsync();
            
        shifts.Should().HaveCount(1);
        shifts[0].Duration.TotalMinutes.Should().Be(480);
    }
}
```

## üö® Najczƒôstsze B≈Çƒôdy do Unikniƒôcia

1. **NIE mieszaj pattern'√≥w** - wybierz jeden spos√≥b i trzymaj siƒô go
2. **NIE pomijaj walidacji** w Value Objects
3. **NIE zostawiaj publicznych setter√≥w** w encjach
4. **NIE umieszczaj logiki biznesowej** w handlerach
5. **NIE u≈ºywaj typ√≥w prymitywnych** dla koncept√≥w domenowych
6. **NIE zapominaj o testach** przy ka≈ºdej zmianie

## üìö Materia≈Çy do Nauki

1. **Domain-Driven Design** - Eric Evans
2. **Clean Architecture** - Robert C. Martin
3. **Przyk≈Çad MySpot** - przestudiuj dok≈Çadnie CLAUDEAPIEXAMPLE.xml
4. **.NET Domain-Driven Design** - dokumentacja Microsoft

## ‚úÖ Checklist Sukcesu

- [ ] Wszystkie typy prymitywne zastƒÖpione Value Objects
- [ ] Encje majƒÖ prywatne konstruktory i factory methods
- [ ] Logika biznesowa przeniesiona do domeny
- [ ] Handlery tylko orkiestrujƒÖ
- [ ] Sp√≥jny pattern obs≈Çugi b≈Çƒôd√≥w
- [ ] Domain Services dla skomplikowanej logiki
- [ ] Domain Events zaimplementowane
- [ ] Specification Pattern w repozytoriach
- [ ] Unit of Work u≈ºywany konsekwentnie
- [ ] Testy pokrywajƒÖ kluczowƒÖ logikƒô

## üéØ Cel Ko≈Ñcowy

Kod SledzSpecke powinien byƒá tak czysty i SOLID jak przyk≈Çad MySpot. Ka≈ºda linia kodu powinna:
- Byƒá ≈Çatwa do zrozumienia
- Mieƒá jasno okre≈õlonƒÖ odpowiedzialno≈õƒá
- Byƒá testowalna
- Przestrzegaƒá zasad DDD
- Byƒá odporna na b≈Çƒôdy

Pamiƒôtaj: **Jako≈õƒá kodu to nie luksus - to konieczno≈õƒá!**

≈öwietnie, stworzy≈Çem bardzo szczeg√≥≈ÇowƒÖ instrukcjƒô dla junior developera. Teraz dodam jeszcze praktyczny przyk≈Çad refaktoryzacji jednego z modu≈Ç√≥w, ≈ºeby pokazaƒá krok po kroku jak to zrobiƒá.

Dodatkowo, przygotowa≈Çem praktyczny przyk≈Çad refaktoryzacji dla jednego z modu≈Ç√≥w:

// ========================================
// PRZED REFAKTORYZACJƒÑ (OBECNY STAN)
// ========================================

// Entity - s≈Çaba enkapsulacja, brak Value Objects
public class MedicalShift
{
    public int Id { get; set; }
    public int InternshipId { get; set; }
    public DateTime Date { get; set; }
    public int DurationMinutes { get; set; }
    public string Location { get; set; }
    public string Status { get; set; }
    public bool IsApproved { get; set; }
    public string ApproverName { get; set; }
    public DateTime? ApprovalDate { get; set; }
}

// Handler - za du≈ºo logiki biznesowej
public class AddMedicalShiftHandler
{
    private readonly AppDbContext _context;
    
    public async Task<int> HandleAsync(AddMedicalShift command)
    {
        // Walidacja w handlerze
        if (command.DurationMinutes < 60)
        {
            throw new InvalidOperationException("Duration must be at least 60 minutes");
        }
        
        var internship = await _context.Internships
            .FirstOrDefaultAsync(i => i.Id == command.InternshipId);
            
        if (internship == null)
        {
            throw new InvalidOperationException("Internship not found");
        }
        
        // Tworzenie encji z publicznymi setterami
        var shift = new MedicalShift
        {
            InternshipId = command.InternshipId,
            Date = command.Date,
            DurationMinutes = command.DurationMinutes,
            Location = command.Location,
            Status = "Draft",
            IsApproved = false,
        };
        
        _context.MedicalShifts.Add(shift);
        await _context.SaveChangesAsync();
        
        return shift.Id;
    }
}

// ========================================
// PO REFAKTORYZACJI (WZORCOWY KOD)
// ========================================

// Value Objects
public sealed record MedicalShiftId
{
    public Guid Value { get; }
    
    private MedicalShiftId(Guid value)
    {
        if (value == Guid.Empty)
        {
            throw new EmptyMedicalShiftIdException();
        }
        Value = value;
    }
    
    public static MedicalShiftId New() => new (Guid.NewGuid());
    public static MedicalShiftId From(Guid value) => new (value);
    
    public static implicit operator Guid(MedicalShiftId id) => id.Value;
}

public sealed record ShiftDuration
{
    public int TotalMinutes { get; }
    
    public ShiftDuration(int totalMinutes)
    {
        if (totalMinutes < 60)
        {
            throw new InvalidShiftDurationException(totalMinutes);
        }
        
        if (totalMinutes > 1440) // 24 hours
        {
            throw new ShiftDurationExceedsLimitException(totalMinutes);
        }
        
        TotalMinutes = totalMinutes;
    }
    
    public static ShiftDuration FromHours(int hours) => new (hours * 60);
    public static ShiftDuration FromMinutes(int minutes) => new (minutes);
    
    public int Hours => TotalMinutes / 60;
    public int Minutes => TotalMinutes % 60;
    
    public override string ToString() => $"{Hours}h {Minutes}min";
}

public sealed record ShiftLocation
{
    public string Value { get; }
    
    public ShiftLocation(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new EmptyShiftLocationException();
        }
        
        if (value.Length > 200)
        {
            throw new ShiftLocationTooLongException(value);
        }
        
        Value = value.Trim();
    }
    
    public static implicit operator string(ShiftLocation location) => location.Value;
    public static implicit operator ShiftLocation(string value) => new (value);
}

// Domain Entity - w≈Ça≈õciwa enkapsulacja
public sealed class MedicalShift : AggregateRoot
{
    private MedicalShift() { } // EF Core
    
    public MedicalShiftId Id { get; private set; }
    public InternshipId InternshipId { get; private set; }
    public Date Date { get; private set; }
    public ShiftDuration Duration { get; private set; }
    public ShiftLocation Location { get; private set; }
    public ShiftStatus Status { get; private set; }
    public ApprovalInfo? Approval { get; private set; }
    public DateTime CreatedAt { get; private set; }
    public DateTime? ModifiedAt { get; private set; }
    
    // Factory method z walidacjƒÖ
    public static MedicalShift Create(
        MedicalShiftId id,
        InternshipId internshipId,
        Date date,
        ShiftDuration duration,
        ShiftLocation location,
        IClock clock)
    {
        var shift = new MedicalShift
        {
            Id = id,
            InternshipId = internshipId,
            Date = date,
            Duration = duration,
            Location = location,
            Status = ShiftStatus.Draft,
            CreatedAt = clock.Current(),
        };
        
        shift.AddDomainEvent(new MedicalShiftCreatedEvent(
            shift.Id,
            shift.InternshipId,
            shift.Date,
            shift.Duration));
            
        return shift;
    }
    
    // Metody biznesowe
    public void Submit()
    {
        if (Status != ShiftStatus.Draft)
        {
            throw new CannotSubmitMedicalShiftException(Id, Status);
        }
        
        Status = ShiftStatus.Submitted;
        ModifiedAt = DateTime.UtcNow;
        
        AddDomainEvent(new MedicalShiftSubmittedEvent(Id));
    }
    
    public void Approve(ApproverName approverName, IClock clock)
    {
        if (Status != ShiftStatus.Submitted)
        {
            throw new CannotApproveMedicalShiftException(Id, Status);
        }
        
        Approval = new ApprovalInfo(approverName, clock.Current());
        Status = ShiftStatus.Approved;
        ModifiedAt = clock.Current();
        
        AddDomainEvent(new MedicalShiftApprovedEvent(Id, approverName));
    }
    
    public void UpdateDetails(ShiftDuration duration, ShiftLocation location)
    {
        if (Status == ShiftStatus.Approved)
        {
            throw new CannotModifyApprovedShiftException(Id);
        }
        
        Duration = duration;
        Location = location;
        ModifiedAt = DateTime.UtcNow;
        
        AddDomainEvent(new MedicalShiftUpdatedEvent(Id));
    }
}

// Value Object dla informacji o zatwierdzeniu
public sealed record ApprovalInfo(
    ApproverName ApproverName,
    DateTime ApprovalDate);

public sealed record ApproverName
{
    public string Value { get; }
    
    public ApproverName(string value)
    {
        if (string.IsNullOrWhiteSpace(value))
        {
            throw new EmptyApproverNameException();
        }
        
        Value = value.Trim();
    }
}

// Enum jako Value Object
public sealed record ShiftStatus
{
    public string Value { get; }
    
    private ShiftStatus(string value) => Value = value;
    
    public static readonly ShiftStatus Draft = new ("Draft");
    public static readonly ShiftStatus Submitted = new ("Submitted");
    public static readonly ShiftStatus Approved = new ("Approved");
    public static readonly ShiftStatus Rejected = new ("Rejected");
    
    public static ShiftStatus From(string value)
    {
        return value switch
        {
            "Draft" => Draft,
            "Submitted" => Submitted,
            "Approved" => Approved,
            "Rejected" => Rejected,
            _ => throw new InvalidShiftStatusException(value),
        };
    }
}

// Domain Service
public sealed class MedicalShiftService
{
    private readonly IClock _clock;
    private readonly IEnumerable<IMedicalShiftPolicy> _policies;
    
    public MedicalShiftService(IClock clock, IEnumerable<IMedicalShiftPolicy> policies)
    {
        _clock = clock;
        _policies = policies;
    }
    
    public Result<MedicalShift> CreateMedicalShift(
        Internship internship,
        Specialization specialization,
        Date date,
        ShiftDuration duration,
        ShiftLocation location)
    {
        // Walidacja dat
        if (!internship.Period.Contains(date))
        {
            return Result<MedicalShift>.Failure(
                "Medical shift date must be within internship period");
        }
        
        // Wyb√≥r odpowiedniej polityki
        var policy = _policies.FirstOrDefault(p => 
            p.CanBeApplied(specialization.SmkVersion));
            
        if (policy is null)
        {
            return Result<MedicalShift>.Failure(
                $"No policy found for SMK version: {specialization.SmkVersion}");
        }
        
        // Walidacja wed≈Çug polityki
        var validationResult = policy.Validate(specialization, date, duration);
        if (validationResult.IsFailure)
        {
            return Result<MedicalShift>.Failure(validationResult.Error);
        }
        
        // Tworzenie encji
        var shift = MedicalShift.Create(
            MedicalShiftId.New(),
            internship.Id,
            date,
            duration,
            location,
            _clock);
            
        return Result<MedicalShift>.Success(shift);
    }
}

// Policy dla r√≥≈ºnych wersji SMK
public interface IMedicalShiftPolicy
{
    SmkVersion CanBeApplied(SmkVersion version);
    Result Validate(Specialization specialization, Date date, ShiftDuration duration);
}

public sealed class OldSmkMedicalShiftPolicy : IMedicalShiftPolicy
{
    public SmkVersion CanBeApplied(SmkVersion version) => SmkVersion.Old;
    
    public Result Validate(Specialization specialization, Date date, ShiftDuration duration)
    {
        // Specyficzne regu≈Çy dla Old SMK
        if (duration.TotalMinutes < 120)
        {
            return Result.Failure("In Old SMK, medical shift must be at least 2 hours");
        }
        
        return Result.Success();
    }
}

// Refaktoryzowany Handler - tylko orkiestracja
public sealed class AddMedicalShiftHandler : ICommandHandler<AddMedicalShift>
{
    private readonly IInternshipRepository _internshipRepository;
    private readonly ISpecializationRepository _specializationRepository;
    private readonly IMedicalShiftRepository _medicalShiftRepository;
    private readonly MedicalShiftService _medicalShiftService;
    private readonly IUnitOfWork _unitOfWork;
    private readonly IEventDispatcher _eventDispatcher;
    
    public AddMedicalShiftHandler(
        IInternshipRepository internshipRepository,
        ISpecializationRepository specializationRepository,
        IMedicalShiftRepository medicalShiftRepository,
        MedicalShiftService medicalShiftService,
        IUnitOfWork unitOfWork,
        IEventDispatcher eventDispatcher)
    {
        _internshipRepository = internshipRepository;
        _specializationRepository = specializationRepository;
        _medicalShiftRepository = medicalShiftRepository;
        _medicalShiftService = medicalShiftService;
        _unitOfWork = unitOfWork;
        _eventDispatcher = eventDispatcher;
    }
    
    public async Task HandleAsync(AddMedicalShift command)
    {
        // Pobieranie danych
        var internship = await _internshipRepository.GetByIdAsync(
            new InternshipId(command.InternshipId));
            
        if (internship is null)
        {
            throw new InternshipNotFoundException(command.InternshipId);
        }
        
        var specialization = await _specializationRepository.GetByIdAsync(
            internship.SpecializationId);
            
        // Delegacja do Domain Service
        var createResult = _medicalShiftService.CreateMedicalShift(
            internship,
            specialization,
            new Date(command.Date),
            new ShiftDuration(command.DurationMinutes),
            new ShiftLocation(command.Location));
            
        if (createResult.IsFailure)
        {
            throw new CannotCreateMedicalShiftException(createResult.Error);
        }
        
        // Zapis
        await _medicalShiftRepository.AddAsync(createResult.Value);
        await _unitOfWork.CommitAsync();
        
        // Publikacja event√≥w
        await _eventDispatcher.PublishAsync(createResult.Value.DomainEvents);
    }
}

// Domain Events
public sealed record MedicalShiftCreatedEvent(
    MedicalShiftId ShiftId,
    InternshipId InternshipId,
    Date Date,
    ShiftDuration Duration) : DomainEvent;

public sealed record MedicalShiftSubmittedEvent(
    MedicalShiftId ShiftId) : DomainEvent;

public sealed record MedicalShiftApprovedEvent(
    MedicalShiftId ShiftId,
    ApproverName ApproverName) : DomainEvent;

// Custom Exceptions
public sealed class EmptyMedicalShiftIdException : DomainException
{
    public EmptyMedicalShiftIdException() 
        : base("Medical shift ID cannot be empty") { }
}

public sealed class InvalidShiftDurationException : DomainException
{
    public InvalidShiftDurationException(int minutes) 
        : base($"Shift duration {minutes} minutes is invalid. Minimum is 60 minutes.") { }
}

public sealed class CannotSubmitMedicalShiftException : DomainException
{
    public CannotSubmitMedicalShiftException(MedicalShiftId id, ShiftStatus status)
        : base($"Cannot submit medical shift {id} in status {status}") { }
}

// EF Core Configuration
public sealed class MedicalShiftConfiguration : IEntityTypeConfiguration<MedicalShift>
{
    public void Configure(EntityTypeBuilder<MedicalShift> builder)
    {
        builder.HasKey(x => x.Id);
        
        builder.Property(x => x.Id)
            .HasConversion(x => x.Value, x => MedicalShiftId.From(x));
            
        builder.Property(x => x.InternshipId)
            .HasConversion(x => x.Value, x => new InternshipId(x));
            
        builder.Property(x => x.Date)
            .HasConversion(x => x.Value, x => new Date(x));
            
        builder.Property(x => x.Duration)
            .HasConversion(x => x.TotalMinutes, x => new ShiftDuration(x));
            
        builder.Property(x => x.Location)
            .HasConversion(x => x.Value, x => new ShiftLocation(x))
            .HasMaxLength(200);
            
        builder.Property(x => x.Status)
            .HasConversion(x => x.Value, x => ShiftStatus.From(x))
            .HasMaxLength(20);
            
        builder.OwnsOne(x => x.Approval, approval =>
        {
            approval.Property(a => a.ApproverName)
                .HasConversion(x => x.Value, x => new ApproverName(x))
                .HasMaxLength(100);
                
            approval.Property(a => a.ApprovalDate);
        });
        
        builder.HasIndex(x => x.InternshipId);
        builder.HasIndex(x => x.Date);
        builder.HasIndex(x => x.Status);
        
        builder.Ignore(x => x.DomainEvents);
    }
}

≈öwietnie, teraz dodam jeszcze jeden artifact z przyk≈Çadowymi testami jednostkowymi, ≈ºeby pokazaƒá jak testowaƒá taki zrefaktoryzowany kod.

Na koniec dodam przyk≈Çady test√≥w jednostkowych dla zrefaktoryzowanego kodu:

using Xunit;
using FluentAssertions;
using NSubstitute;
using System;
using System.Threading.Tasks;
using System.Collections.Generic;

// ========================================
// TESTY VALUE OBJECTS
// ========================================

public class ShiftDurationTests
{
    [Fact]
    public void Constructor_ShouldThrowException_WhenMinutesLessThan60()
    {
        // Arrange & Act
        var act = () => new ShiftDuration(59);
        
        // Assert
        act.Should().Throw<InvalidShiftDurationException>()
            .WithMessage("*59 minutes is invalid*");
    }
    
    [Fact]
    public void Constructor_ShouldThrowException_WhenMinutesExceed24Hours()
    {
        // Arrange & Act
        var act = () => new ShiftDuration(1441); // 24h + 1min
        
        // Assert
        act.Should().Throw<ShiftDurationExceedsLimitException>();
    }
    
    [Theory]
    [InlineData(60, 1, 0)]
    [InlineData(90, 1, 30)]
    [InlineData(480, 8, 0)]
    [InlineData(615, 10, 15)]
    public void Properties_ShouldCalculateCorrectly(
        int totalMinutes, 
        int expectedHours, 
        int expectedMinutes)
    {
        // Arrange & Act
        var duration = new ShiftDuration(totalMinutes);
        
        // Assert
        duration.TotalMinutes.Should().Be(totalMinutes);
        duration.Hours.Should().Be(expectedHours);
        duration.Minutes.Should().Be(expectedMinutes);
    }
    
    [Fact]
    public void FromHours_ShouldCreateCorrectDuration()
    {
        // Arrange & Act
        var duration = ShiftDuration.FromHours(8);
        
        // Assert
        duration.TotalMinutes.Should().Be(480);
        duration.ToString().Should().Be("8h 0min");
    }
}

public class EmailTests
{
    [Theory]
    [InlineData("")]
    [InlineData(" ")]
    [InlineData(null)]
    public void Constructor_ShouldThrowException_WhenEmailIsEmpty(string email)
    {
        // Arrange & Act
        var act = () => new Email(email);
        
        // Assert
        act.Should().Throw<EmptyEmailException>();
    }
    
    [Theory]
    [InlineData("invalid")]
    [InlineData("@example.com")]
    [InlineData("user@")]
    [InlineData("user@@example.com")]
    public void Constructor_ShouldThrowException_WhenEmailIsInvalid(string email)
    {
        // Arrange & Act
        var act = () => new Email(email);
        
        // Assert
        act.Should().Throw<InvalidEmailException>()
            .WithMessage($"Email '{email}' is invalid");
    }
    
    [Fact]
    public void Constructor_ShouldNormalizeEmail_ToLowerCase()
    {
        // Arrange & Act
        var email = new Email("USER@EXAMPLE.COM");
        
        // Assert
        email.Value.Should().Be("user@example.com");
    }
    
    [Fact]
    public void ImplicitConversion_ShouldWorkBothWays()
    {
        // Arrange
        const string emailString = "user@example.com";
        
        // Act
        Email email = emailString;
        string converted = email;
        
        // Assert
        converted.Should().Be(emailString);
    }
}

// ========================================
// TESTY ENCJI DOMENOWYCH
// ========================================

public class MedicalShiftTests
{
    private readonly IClock _clock;
    
    public MedicalShiftTests()
    {
        _clock = Substitute.For<IClock>();
        _clock.Current().Returns(new DateTime(2024, 1, 15, 10, 0, 0));
    }
    
    [Fact]
    public void Create_ShouldCreateValidShift_WithDraftStatus()
    {
        // Arrange
        var id = MedicalShiftId.New();
        var internshipId = new InternshipId(1);
        var date = new Date(DateTime.Today);
        var duration = ShiftDuration.FromHours(8);
        var location = new ShiftLocation("Hospital");
        
        // Act
        var shift = MedicalShift.Create(id, internshipId, date, duration, location, _clock);
        
        // Assert
        shift.Id.Should().Be(id);
        shift.InternshipId.Should().Be(internshipId);
        shift.Date.Should().Be(date);
        shift.Duration.Should().Be(duration);
        shift.Location.Should().Be(location);
        shift.Status.Should().Be(ShiftStatus.Draft);
        shift.Approval.Should().BeNull();
        shift.CreatedAt.Should().Be(_clock.Current());
    }
    
    [Fact]
    public void Create_ShouldRaiseDomainEvent()
    {
        // Arrange & Act
        var shift = CreateDefaultShift();
        
        // Assert
        shift.DomainEvents.Should().HaveCount(1);
        var @event = shift.DomainEvents.First();
        @event.Should().BeOfType<MedicalShiftCreatedEvent>();
        
        var createdEvent = (MedicalShiftCreatedEvent)@event;
        createdEvent.ShiftId.Should().Be(shift.Id);
        createdEvent.InternshipId.Should().Be(shift.InternshipId);
        createdEvent.Date.Should().Be(shift.Date);
        createdEvent.Duration.Should().Be(shift.Duration);
    }
    
    [Fact]
    public void Submit_ShouldChangeStatus_WhenInDraftStatus()
    {
        // Arrange
        var shift = CreateDefaultShift();
        
        // Act
        shift.Submit();
        
        // Assert
        shift.Status.Should().Be(ShiftStatus.Submitted);
        shift.ModifiedAt.Should().NotBeNull();
        shift.DomainEvents.Should().Contain(e => e is MedicalShiftSubmittedEvent);
    }
    
    [Fact]
    public void Submit_ShouldThrowException_WhenNotInDraftStatus()
    {
        // Arrange
        var shift = CreateDefaultShift();
        shift.Submit(); // Already submitted
        
        // Act
        var act = () => shift.Submit();
        
        // Assert
        act.Should().Throw<CannotSubmitMedicalShiftException>()
            .WithMessage($"*{shift.Id}*{ShiftStatus.Submitted}*");
    }
    
    [Fact]
    public void Approve_ShouldSetApprovalInfo_WhenInSubmittedStatus()
    {
        // Arrange
        var shift = CreateDefaultShift();
        shift.Submit();
        var approverName = new ApproverName("Dr. Smith");
        
        // Act
        shift.Approve(approverName, _clock);
        
        // Assert
        shift.Status.Should().Be(ShiftStatus.Approved);
        shift.Approval.Should().NotBeNull();
        shift.Approval!.ApproverName.Should().Be(approverName);
        shift.Approval.ApprovalDate.Should().Be(_clock.Current());
        shift.ModifiedAt.Should().Be(_clock.Current());
    }
    
    [Fact]
    public void UpdateDetails_ShouldThrowException_WhenApproved()
    {
        // Arrange
        var shift = CreateDefaultShift();
        shift.Submit();
        shift.Approve(new ApproverName("Dr. Smith"), _clock);
        
        // Act
        var act = () => shift.UpdateDetails(
            ShiftDuration.FromHours(10), 
            new ShiftLocation("New Hospital"));
        
        // Assert
        act.Should().Throw<CannotModifyApprovedShiftException>();
    }
    
    private MedicalShift CreateDefaultShift()
    {
        return MedicalShift.Create(
            MedicalShiftId.New(),
            new InternshipId(1),
            new Date(DateTime.Today),
            ShiftDuration.FromHours(8),
            new ShiftLocation("Hospital"),
            _clock);
    }
}

// ========================================
// TESTY DOMAIN SERVICE
// ========================================

public class MedicalShiftServiceTests
{
    private readonly MedicalShiftService _service;
    private readonly IClock _clock;
    private readonly List<IMedicalShiftPolicy> _policies;
    
    public MedicalShiftServiceTests()
    {
        _clock = Substitute.For<IClock>();
        _clock.Current().Returns(new DateTime(2024, 1, 15));
        
        _policies = new List<IMedicalShiftPolicy>
        {
            new OldSmkMedicalShiftPolicy(),
            new NewSmkMedicalShiftPolicy(),
        };
        
        _service = new MedicalShiftService(_clock, _policies);
    }
    
    [Fact]
    public void CreateMedicalShift_ShouldReturnFailure_WhenDateOutsideInternshipPeriod()
    {
        // Arrange
        var internship = CreateInternship(
            new Date(new DateTime(2024, 1, 1)),
            new Date(new DateTime(2024, 6, 30)));
            
        var specialization = CreateSpecialization(SmkVersion.Old);
        var shiftDate = new Date(new DateTime(2024, 7, 1)); // Outside period
        
        // Act
        var result = _service.CreateMedicalShift(
            internship,
            specialization,
            shiftDate,
            ShiftDuration.FromHours(8),
            new ShiftLocation("Hospital"));
        
        // Assert
        result.IsFailure.Should().BeTrue();
        result.Error.Should().Contain("within internship period");
    }
    
    [Fact]
    public void CreateMedicalShift_ShouldApplyCorrectPolicy_ForOldSmk()
    {
        // Arrange
        var internship = CreateInternship();
        var specialization = CreateSpecialization(SmkVersion.Old);
        var shortDuration = new ShiftDuration(90); // 1.5h - too short for Old SMK
        
        // Act
        var result = _service.CreateMedicalShift(
            internship,
            specialization,
            new Date(DateTime.Today),
            shortDuration,
            new ShiftLocation("Hospital"));
        
        // Assert
        result.IsFailure.Should().BeTrue();
        result.Error.Should().Contain("at least 2 hours");
    }
    
    [Fact]
    public void CreateMedicalShift_ShouldReturnSuccess_WhenAllValid()
    {
        // Arrange
        var internship = CreateInternship();
        var specialization = CreateSpecialization(SmkVersion.Old);
        
        // Act
        var result = _service.CreateMedicalShift(
            internship,
            specialization,
            new Date(DateTime.Today),
            ShiftDuration.FromHours(8),
            new ShiftLocation("Hospital"));
        
        // Assert
        result.IsSuccess.Should().BeTrue();
        result.Value.Should().NotBeNull();
        result.Value.Status.Should().Be(ShiftStatus.Draft);
    }
    
    private Internship CreateInternship(Date? startDate = null, Date? endDate = null)
    {
        return Internship.Create(
            new InternshipId(1),
            new Department("Cardiology"),
            startDate ?? new Date(new DateTime(2024, 1, 1)),
            endDate ?? new Date(new DateTime(2024, 12, 31)));
    }
    
    private Specialization CreateSpecialization(SmkVersion version)
    {
        return Specialization.Create(
            new SpecializationId(1),
            new SpecializationName("Cardiology"),
            new ProgramCode("CARD2024"),
            version);
    }
}

// ========================================
// TESTY INTEGRACYJNE HANDLER√ìW
// ========================================

public class AddMedicalShiftHandlerTests : IAsyncLifetime
{
    private readonly TestDatabase _database;
    private readonly AddMedicalShiftHandler _handler;
    private readonly IInternshipRepository _internshipRepository;
    private readonly ISpecializationRepository _specializationRepository;
    private readonly IMedicalShiftRepository _medicalShiftRepository;
    private readonly IEventDispatcher _eventDispatcher;
    
    public AddMedicalShiftHandlerTests()
    {
        _database = new TestDatabase();
        
        _internshipRepository = new InternshipRepository(_database.Context);
        _specializationRepository = new SpecializationRepository(_database.Context);
        _medicalShiftRepository = new MedicalShiftRepository(_database.Context);
        
        var clock = new SystemClock();
        var policies = new List<IMedicalShiftPolicy>
        {
            new OldSmkMedicalShiftPolicy(),
            new NewSmkMedicalShiftPolicy(),
        };
        
        var medicalShiftService = new MedicalShiftService(clock, policies);
        var unitOfWork = new UnitOfWork(_database.Context);
        
        _eventDispatcher = Substitute.For<IEventDispatcher>();
        
        _handler = new AddMedicalShiftHandler(
            _internshipRepository,
            _specializationRepository,
            _medicalShiftRepository,
            medicalShiftService,
            unitOfWork,
            _eventDispatcher);
    }
    
    public async Task InitializeAsync()
    {
        await _database.InitializeAsync();
        await SeedTestData();
    }
    
    public async Task DisposeAsync()
    {
        await _database.DisposeAsync();
    }
    
    [Fact]
    public async Task HandleAsync_ShouldAddMedicalShift_WhenDataIsValid()
    {
        // Arrange
        var command = new AddMedicalShift(
            InternshipId: 1,
            Date: DateTime.Today,
            DurationMinutes: 480,
            Location: "Test Hospital");
        
        // Act
        await _handler.HandleAsync(command);
        
        // Assert
        var shifts = await _medicalShiftRepository.GetByInternshipIdAsync(
            new InternshipId(1));
            
        shifts.Should().HaveCount(1);
        var shift = shifts.First();
        shift.Duration.TotalMinutes.Should().Be(480);
        shift.Location.Value.Should().Be("Test Hospital");
        shift.Status.Should().Be(ShiftStatus.Draft);
    }
    
    [Fact]
    public async Task HandleAsync_ShouldThrowException_WhenInternshipNotFound()
    {
        // Arrange
        var command = new AddMedicalShift(
            InternshipId: 999, // Non-existent
            Date: DateTime.Today,
            DurationMinutes: 480,
            Location: "Test Hospital");
        
        // Act
        var act = () => _handler.HandleAsync(command);
        
        // Assert
        await act.Should().ThrowAsync<InternshipNotFoundException>()
            .WithMessage("*999*");
    }
    
    [Fact]
    public async Task HandleAsync_ShouldPublishDomainEvents()
    {
        // Arrange
        var command = new AddMedicalShift(
            InternshipId: 1,
            Date: DateTime.Today,
            DurationMinutes: 480,
            Location: "Test Hospital");
        
        // Act
        await _handler.HandleAsync(command);
        
        // Assert
        await _eventDispatcher.Received(1)
            .PublishAsync(Arg.Any<IEnumerable<DomainEvent>>());
    }
    
    private async Task SeedTestData()
    {
        var user = User.Create(
            UserId.New(),
            new Email("test@example.com"),
            new Username("testuser"),
            new Password("HashedPassword123!"),
            new FullName("Test User"),
            SmkVersion.Old,
            new SpecializationId(1));
            
        var specialization = Specialization.Create(
            new SpecializationId(1),
            new SpecializationName("Cardiology"),
            new ProgramCode("CARD2024"),
            SmkVersion.Old);
            
        var internship = Internship.Create(
            new InternshipId(1),
            new Department("Cardiology Department"),
            new Date(new DateTime(2024, 1, 1)),
            new Date(new DateTime(2024, 12, 31)));
            
        await _database.Context.Users.AddAsync(user);
        await _database.Context.Specializations.AddAsync(specialization);
        await _database.Context.Internships.AddAsync(internship);
        await _database.Context.SaveChangesAsync();
    }
}

// ========================================
// POMOCNICZE KLASY TESTOWE
// ========================================

public class TestDatabase : IAsyncDisposable
{
    public SledzSpeckeDbContext Context { get; }
    
    public TestDatabase()
    {
        var options = new DbContextOptionsBuilder<SledzSpeckeDbContext>()
            .UseInMemoryDatabase(databaseName: Guid.NewGuid().ToString())
            .Options;
            
        Context = new SledzSpeckeDbContext(options);
    }
    
    public async Task InitializeAsync()
    {
        await Context.Database.EnsureCreatedAsync();
    }
    
    public async ValueTask DisposeAsync()
    {
        await Context.DisposeAsync();
    }
}

public class SystemClock : IClock
{
    public DateTime Current() => DateTime.UtcNow;
}

Teraz podsumowa≈Çem ca≈ÇƒÖ analizƒô. Stworzy≈Çem:

1. **G≈Ç√≥wnƒÖ instrukcjƒô** - szczeg√≥≈Çowy przewodnik pokazujƒÖcy wszystkie problemy i jak je naprawiƒá
2. **Przyk≈Çad refaktoryzacji** - kompletny przyk≈Çad pokazujƒÖcy jak przekszta≈Çciƒá istniejƒÖcy modu≈Ç MedicalShift zgodnie z wzorcami z MySpot
3. **Przyk≈Çady test√≥w** - pokazujƒÖce jak testowaƒá zrefaktoryzowany kod

Kluczowe problemy zidentyfikowane w kodzie SledzSpecke:
- Primitive Obsession - brak Value Objects
- Niesp√≥jna obs≈Çuga b≈Çƒôd√≥w (mieszanie wyjƒÖtk√≥w i Result pattern)
- S≈Çaba enkapsulacja encji (publiczne settery)
- Brak Domain Services
- Logika biznesowa w handlerach zamiast w domenie
- Brak Domain Events
- Brak Policies dla regu≈Ç biznesowych
- Niesp√≥jne u≈ºycie wzorc√≥w

RozwiƒÖzanie pokazuje krok po kroku jak wprowadziƒá wszystkie wzorce z MySpot do SledzSpecke.

## Podsumowanie analizy

Po dok≈Çadnym por√≥wnaniu kodu **SledzSpecke** z przyk≈Çadem **MySpot** (CLAUDEAPIEXAMPLE.xml), stwierdzi≈Çem, ≈ºe aplikacja wymaga znaczƒÖcej refaktoryzacji, aby osiƒÖgnƒÖƒá poziom jako≈õci zgodny z zasadami SOLID i Clean Architecture.

### üîç G≈Ç√≥wne problemy zidentyfikowane:

1. **Primitive Obsession** - nadu≈ºywanie typ√≥w prymitywnych zamiast Value Objects
2. **Niesp√≥jna obs≈Çuga b≈Çƒôd√≥w** - mieszanie wyjƒÖtk√≥w z Result pattern
3. **S≈Çaba enkapsulacja** - publiczne settery w encjach
4. **Brak Domain Services** - logika biznesowa w handlerach
5. **Brak Domain Events** - brak komunikacji miƒôdzy agregat
6. **Brak Policies** - regu≈Çy biznesowe rozproszone w kodzie
7. **Niesp√≥jne wzorce** - r√≥≈ºne podej≈õcia w r√≥≈ºnych modu≈Çach

### üìö Przygotowane materia≈Çy:

1. **Instrukcja poprawy kodu** - szczeg√≥≈Çowy przewodnik dla junior developera z przyk≈Çadami "przed" i "po"
2. **Przyk≈Çad refaktoryzacji** - kompletna reimplementacja modu≈Çu MedicalShift zgodnie ze wzorcami MySpot
3. **Przyk≈Çady test√≥w** - pokazujƒÖce jak prawid≈Çowo testowaƒá zrefaktoryzowany kod

### ‚è±Ô∏è Szacowany czas refaktoryzacji:

- **Faza 1**: Value Objects (2-3 dni)
- **Faza 2**: Domain Model (3-4 dni)  
- **Faza 3**: Application Layer (2-3 dni)
- **Faza 4**: Infrastructure (1-2 dni)

**≈ÅƒÖcznie**: 10-12 dni pracy dla do≈õwiadczonego developera

### üéØ Najwa≈ºniejsze zalecenia:

1. **Rozpocznij od Value Objects** - to fundament ca≈Çej architektury
2. **Wybierz JEDEN spos√≥b obs≈Çugi b≈Çƒôd√≥w** i stosuj konsekwentnie
3. **Przenie≈õ logikƒô biznesowƒÖ do domeny** - handlery tylko orkiestrujƒÖ
4. **Testuj ka≈ºdƒÖ zmianƒô** - to zapewni stabilno≈õƒá podczas refaktoryzacji
5. **Refaktoryzuj modu≈Ç po module** - nie pr√≥buj zmieniƒá wszystkiego naraz

Kod MySpot stanowi doskona≈Çy wzorzec do na≈õladowania - jest czysty, testowalny i zgodny ze wszystkimi zasadami SOLID oraz DDD.

Sources:
- FRONTEND-INSTRUCTION.md
- CLAUDE.md
- SledzSpecke-Frontend/packages/web/src/services/export.ts
- SOLIDAPIEXAMPLE.xml
- SOLIDAPIEXAMPLE.xml
- SledzSpecke.WebApi/src/SledzSpecke.Core/Entities/UserEnhanced.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/Repositories/IModuleRepository.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/Abstractions/ValueObject.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/Repositories/ISpecializationRepository.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/Entities/PublicationEnhanced.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/ValueObjects/SpecializationId.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/Repositories/IUserRepository.cs
- SledzSpecke.WebApi/src/SledzSpecke.Core/ValueObjects/ModuleId.cs
- SledzSpecke.WebApi/src/SledzSpecke.Application/Extensions.cs
- CLAUDE.md
- SOLIDAPIEXAMPLE.xml
- SledzSpecke.WebApi/src/SledzSpecke.Application/Commands/Handlers/ApproveCourseHandler.cs
- SledzSpecke.WebApi/src/SledzSpecke.Application/Commands/Handlers/CreateRecognitionHandler.cs
- SledzSpecke.WebApi/src/SledzSpecke.Application/Commands/Handlers/ApproveInternshipHandler.old
- SledzSpecke.WebApi/src/SledzSpecke.Application/MedicalShifts/Handlers/AddMedicalShiftHandlerEnhanced.cs
- SledzSpecke.WebApi/src/SledzSpecke.Application/Procedures/Handlers/AddProcedureHandler.new
- README.md
- SledzSpecke.WebApi/src/SledzSpecke.Infrastructure/DAL/Configurations/SpecializationConfiguration.cs
- SOLIDAPIEXAMPLE.xml
- SledzSpecke.WebApi/src/SledzSpecke.Infrastructure/DAL/Configurations/ProcedureBaseConfiguration.cs
- SledzSpecke.WebApi/src/SledzSpecke.Infrastructure/DAL/Configurations/UserConfiguration.cs
- SledzSpecke.WebApi/src/SledzSpecke.Infrastructure/DAL/Configurations/ProcedureConfiguration.cs
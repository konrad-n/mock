This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where security check has been disabled.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
compose/
  docker-compose.yaml
  Dockerfile
docs/
  ANOMALIE.md
src/
  Communication/
    TicketFlow.Services.Communication.Alerting/
      AlertingTopologyBuilder.cs
      AlertMessageConventions.cs
      IAlertMessage.cs
      TicketFlow.Services.Communication.Alerting.csproj
    TicketFlow.Services.Communication.Api/
      DTO/
        MessageListDto.cs
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      Program.cs
      TicketFlow.Services.Communication.Api.csproj
    TicketFlow.Services.Communication.Core/
      Data/
        Configurations/
          AlertConfiguration.cs
          MessageConfiguration.cs
        Migrations/
          Communication/
            20241223145106_Initial.cs
            20241223145106_Initial.Designer.cs
            20241223150802_Consolidate_IsRead_props.cs
            20241223150802_Consolidate_IsRead_props.Designer.cs
            20241223152905_Recipient_Email.cs
            20241223152905_Recipient_Email.Designer.cs
            CommunicationDbContextModelSnapshot.cs
          scripts.txt
        Models/
          Alert.cs
          Message.cs
        CommunicationDbContext.cs
      Http/
        Tickets/
          ITicketsClient.cs
          TicketDetails.cs
          TicketsClient.cs
      Messaging/
        Consuming/
          AlertsHandler.cs
          ProducerAgnosticAlertMessage.cs
          TicketResolvedHandler.cs
        CommunicationConsumer.cs
        CommunicationTopologyInitializer.cs
        TicketResolved.cs
      Validators/
        MessageValidator.cs
      Extensions.cs
      TicketFlow.Services.Communication.Core.csproj
    run-migrations.sh
  Inquiries/
    TicketFlow.Services.Inquiries.Api/
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      inquiries-api.http
      Program.cs
      TicketFlow.Services.Inquiries.Api.csproj
    TicketFlow.Services.Inquiries.Core/
      Commands/
        SubmitInquiry/
          SubmitInquiry.cs
          SubmitInquiryHandler.cs
        SubmitInquirySynchronously/
          CreateTicketSynchronously.cs
          SubmitInquirySynchronously.cs
          SubmitInquirySynchronouslyHandler.cs
      Data/
        Configurations/
          InquiryConfiguration.cs
        Migrations/
          20241026110344_Init.cs
          20241026110344_Init.Designer.cs
          20241116205352_FE_alignment.cs
          20241116205352_FE_alignment.Designer.cs
          20241228190704_Inquiry_TicketId.cs
          20241228190704_Inquiry_TicketId.Designer.cs
          InquiriesDbContextModelSnapshot.cs
          scripts.txt
        Models/
          Inquiry.cs
          InquiryCategory.cs
          InquiryStatus.cs
        Repositories/
          IInquiriesRepository.cs
          InquiriesRepository.cs
        InquiriesDbContext.cs
      LanguageDetection/
        Extensions.cs
        ILanguageDetector.cs
        NoopLanguageDetector.cs
        OpenAiLanguageDetector.cs
      Messaging/
        Consuming/
          TicketCreated/
            TicketCreated.cs
            TicketCreatedHandler.cs
        Publishing/
          InquirySubmitted.cs
          RequestTranslationV1.cs
          RequestTranslationV2.cs
        InquiriesConsumerService.cs
        InquiriesTopologyInitializer.cs
      Queries/
        InquiriesListDto.cs
        ListInquiries.cs
        ListInquiriesHandler.cs
      Extensions.cs
      TicketFlow.Services.Inquiries.Core.csproj
    run-migrations.sh
  Shared/
    TicketFlow.CourseUtils/
      FeatureFlags.cs
      TicketFlow.CourseUtils.csproj
    TicketFlow.Shared/
      AnomalyGeneration/
        Anomalies/
          AnomalyException.cs
          ConsumerAnomalies.cs
          IAnomaly.cs
          OutboxAnomalies.cs
          ProducerAnomalies.cs
        CodeApi/
          AnomalyContext.cs
          AnomalyExecutionSteps.cs
          IConsumerAnomalyGenerator.cs
          IOutboxAnomalyGenerator.cs
          IProducerAnomalyGenerator.cs
          MessageHandlerAnomalyDecorator.cs
          MessageOutboxAnomalyDecorator.cs
          MessagePublisherAnomalyDecorator.cs
        HttpApi/
          AnomalyDescription.cs
          AnomalyEndpoints.cs
          EnableAnomalyRequest.cs
          IAnomaliesStorage.cs
        MessagingApi/
          AnomalyDisabled.cs
          AnomalyEnabled.cs
          AnomalyEventWrapper.cs
          AnomalySynchronizationConfigurator.cs
          AnomalyTopologyBuilder.cs
        AnomalyGenerator.cs
        AnomalyType.cs
        Extensions.cs
      App/
        AppOptions.cs
        Extensions.cs
      AspNetCore/
        HttpApiExtensions.cs
      Commands/
        Extensions.cs
        ICommand.cs
        ICommandHandler.cs
      Data/
        Extensions.cs
      DependencyInjection/
        Extensions.cs
      Exceptions/
        ExceptionMiddleware.cs
        Extensions.cs
        TicketFlowException.cs
      Messaging/
        Deduplication/
          Data/
            Migrations/
              20241116134015_Init.cs
              20241116134015_Init.Designer.cs
              DeduplicationDbContextModelSnapshot.cs
            DeduplicationDbContext.cs
            DeduplicationEntry.cs
            DeduplicationEntryConfiguration.cs
            NoopDeduplicationStore.cs
            PostgresDeduplicationStore.cs
          DeduplicationBeforeExecutionStep.cs
          DeduplicationOptions.cs
          DeduplicationTransactionExecutionStep.cs
          Extensions.cs
          IDeduplicationStore.cs
        Executor/
          CommandHandlerExecutorDecorator.cs
          IMessageExecutionStep.cs
          IMessageExecutor.cs
          MessageExecutionAbortedException.cs
          MessageExecutor.cs
          MessageHandlerExecutorDecorator.cs
        Ordering/
          OutOfOrderDetection/
            Extensions.cs
            IGetMessageRelatedEntityVersion.cs
            IgnoreOutOfOrderMessageDecorator.cs
            IVersionedMessage.cs
            OutOfOrderDetector.cs
        Outbox/
          Data/
            Migrations/
              20241116114642_Init.cs
              20241116114642_Init.Designer.cs
              OutboxDbContextModelSnapshot.cs
            OutboxDbContext.cs
            OutboxLocalCache.cs
            OutboxMessageConfiguration.cs
            PostgresMessageOutbox.cs
          Extensions.cs
          IMessageOutbox.cs
          OutboxAfterExecutionStep.cs
          OutboxBackgroundService.cs
          OutboxBeforeExecutionStep.cs
          OutboxMessage.cs
          OutboxMessagePublisher.cs
          OutboxOptions.cs
          OutboxPublishChannel.cs
        Partitioning/
          IConsumerSpecificPartitioningSetup.cs
          IMessageWithPartitionKey.cs
          PartitioningOptions.cs
          PartitionName.cs
        RabbitMQ/
          ChannelFactory.cs
          ConnectionProvider.cs
          Extensions.cs
          RabbitMqDefaultMessageConventionProvider.cs
          RabbitMqMessageConsumer.cs
          RabbitMqMessagePublisher.cs
          RabbitMqOptions.cs
          RabbitMqTopologyBuilder.cs
          RabbitMqTopologyInitializer.cs
        Resiliency/
          Extensions.cs
          Fault.cs
          INonMandatoryMessage.cs
          MessageHandlerRetryDecorator.cs
          ReliableConsuming.cs
          ReliablePublishing.cs
          ResiliencyOptions.cs
        Topology/
          DontUseConventionalTopology.cs
          ITopologyBuilder.cs
          TopologyInitializerBase.cs
          TopologyOptions.cs
          TopologyReadinessAccessor.cs
        Extensions.cs
        IMessage.cs
        IMessageConsumer.cs
        IMessageConventionProvider.cs
        IMessageHandler.cs
        IMessagePublisher.cs
        IMessagingRegisterer.cs
        MessageData.cs
        MessagePropertiesAccessor.cs
        MessageTypeName.cs
        MessagingRegisterer.cs
      Observability/
        Extensions.cs
        MessagingActivitySources.cs
        MessagingObservabilityHeaders.cs
        ObservabilityOptions.cs
      OpenAI/
        Extensions.cs
        OpenAIOptions.cs
      Queries/
        Extensions.cs
        IQuery.cs
        IQueryHandler.cs
      Serialization/
        Extensions.cs
        ISerializer.cs
        JsonSerializer.cs
        SerializationOptions.cs
      Testing/
        MessagingIntegrationTestProvider.cs
      TicketFlow.Shared.csproj
  SLA/
    TicketFlow.Services.SLA.Api/
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      get-deadlines.http
      Program.cs
      TicketFlow.Services.SLA.Api.csproj
    TicketFlow.Services.SLA.Core/
      Data/
        Configurations/
          DeadlineReminderConfiguration.cs
          SignedSLAConfiguration.cs
        Migrations/
          SLA/
            20241217213005_Initial.cs
            20241217213005_Initial.Designer.cs
            20241218195823_UserId_InsteadOf_AgentId.cs
            20241218195823_UserId_InsteadOf_AgentId.Designer.cs
            20241230221523_SourceServiceVersion_And_ServiceCompleted.cs
            20241230221523_SourceServiceVersion_And_ServiceCompleted.Designer.cs
            SLADbContextModelSnapshot.cs
          scripts.txt
        Models/
          CalculatedDeadline.cs
          DeadlineReminders.cs
          Defaults.cs
          Email.cs
          ServiceType.cs
          SeverityLevel.cs
          SignedSLA.cs
          SLADeadlines.cs
          SLATier.cs
          TicketStatus.cs
        Repositories/
          ISLARepository.cs
          SLARepository.cs
        SLADbContext.cs
      Http/
        Communication/
          CommunicationsClient.cs
          ICommunicationClient.cs
          MessageDto.cs
        Tickets/
          AgentDto.cs
          ITicketsClient.cs
          TicketDetails.cs
          TicketsClient.cs
      Initializers/
        Extensions.cs
        SLASignedAppInitializer.cs
      Messaging/
        Consuming/
          ApplicationServices/
            TicketService.cs
          Demultiplexing/
            FallbackTicketChangeEvent.cs
            TicketChangesHandler.cs
          Partitioning/
            TicketChangesPartitioningSetup.cs
          AgentAssignedToTicket.cs
          AgentAssignedToTicketHandler.cs
          ITicketChange.cs
          TicketQualified.cs
          TicketQualifiedHandler.cs
          TicketResolved.cs
          TicketResolvedHandler.cs
        Publishing/
          Conventions/
            SLAMessagePublisherConventionProvider.cs
          DeadlinesCalculated.cs
          SLABreached.cs
        SLAConsumerService.cs
        SLATopologyInitializer.cs
      Schedulers/
        DeadlineBreachOptions.cs
        DeadlineBreachWatcher.cs
        RemindersWatcher.cs
      Extensions.cs
      TicketFlow.Services.SLA.Core.csproj
    run-migrations.sh
  SystemMetrics/
    TicketFlow.Services.SystemMetrics.Api/
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      Program.cs
      TicketFlow.Services.SystemMetrics.Api.csproj
    TicketFlow.Services.SystemMetrics.Core/
      LiveMetrics/
        LiveMetricsHub.cs
        LiveMetricsOptions.cs
        LiveMetricsPullService.cs
      Extensions.cs
      TicketFlow.Services.SystemMetrics.Core.csproj
    TicketFlow.Services.SystemMetrics.Generator/
      Data/
        MetricsGenerator.cs
        MetricTick.cs
      Schedulers/
        RandomMetricsPublisher.cs
      Extensions.cs
      TicketFlow.Services.SystemMetrics.Generator.csproj
  Tickets/
    TicketFlow.Services.Tickets.Api/
      DTO/
        ClientNoteDto.cs
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      Program.cs
      TicketFlow.Services.Tickets.Api.csproj
      tickets-api.http
    TicketFlow.Services.Tickets.Core/
      Commands/
        AddClientCommentsToTicket/
          AddClientCommentsToTicketHandler.cs
          AddClientNoteToTicket.cs
        AssignAgentToTicket/
          AssignAgentToTicket.cs
          AssignAgentToTicketHandler.cs
        BlockTicket/
          BlockTicket.cs
          BlockTicketHandler.cs
        QualifyTicket/
          QualifyTicket.cs
          QualifyTicketHandler.cs
        ResolveTicket/
          ResolveTicket.cs
          ResolveTicketHandler.cs
        UnblockTicket/
          UnblockTicket.cs
          UnblockTicketHandler.cs
      Data/
        Configurations/
          AgentConfiguration.cs
          TicketConfiguration.cs
          TicketScheduledActionConfiguration.cs
        Migrations/
          Tickets/
            20241110130614_Init.cs
            20241110130614_Init.Designer.cs
            20241117173901_Agent_Details.cs
            20241117173901_Agent_Details.Designer.cs
            20241117203736_Tickets_FE_Listing.cs
            20241117203736_Tickets_FE_Listing.Designer.cs
            20241207153411_Added_Scheduled_Actions.cs
            20241207153411_Added_Scheduled_Actions.Designer.cs
            20241207160214_Added_Ticket_Version.cs
            20241207160214_Added_Ticket_Version.Designer.cs
            20241218194154_Agent_UserId.cs
            20241218194154_Agent_UserId.Designer.cs
            20241221215746_DeadlineUtc.cs
            20241221215746_DeadlineUtc.Designer.cs
            20241223124917_Ticket_Resolution.cs
            20241223124917_Ticket_Resolution.Designer.cs
            20241227171939_Nullable_Resolution.cs
            20241227171939_Nullable_Resolution.Designer.cs
            TicketsDbContextModelSnapshot.cs
          scripts.txt
        Models/
          Agent.cs
          AgentPosition.cs
          SeverityLevel.cs
          Ticket.cs
          TicketCategory.cs
          TicketStatus.cs
          TicketTranslation.cs
          TicketType.cs
        Repositories/
          ITicketsRepository.cs
          TicketsRepository.cs
        TicketsDbContext.cs
      Initializers/
        AgentsAppInitializer.cs
        Extensions.cs
      Messaging/
        Consuming/
          DeadlinesCalculated/
            DeadlinesCalculated.cs
            DeadlinesCalculatedHandler.cs
          InquirySubmitted/
            InquirySubmitted.cs
            InquirySubmittedHandler.cs
          TicketCreated/
            TicketCreatedHandler.cs
          TranslationCompleted/
            TranslationCompleted.cs
            TranslationCompletedHandler.cs
        Publishing/
          Conventions/
            TicketsMessagePublisherConventionProvider.cs
          AgentAssignedToTicket.cs
          IncidentCreated.cs
          TicketBlocked.cs
          TicketCreated.cs
          TicketQualified.cs
          TicketResolved.cs
        TicketsConsumerService.cs
        TicketsTopologyInitializer.cs
      Queries/
        GetClientNotesForTicket/
          GetClientNotesForTicket.cs
          GetClientNotesForTicketHandler.cs
        GetTicketDetails/
          GetTicketDetailsQuery.cs
          GetTicketDetailsQueryHandler.cs
          TicketDetailsDto.cs
        ListAgents/
          AgentDto.cs
          ListAgentsHandler.cs
          ListAgentsQuery.cs
        ListTickets/
          ListTicketsHandler.cs
          ListTicketsQuery.cs
          TicketsListDto.cs
      SynchronousIntegration/
        CreateTicketSynchronously.cs
        CreateTicketSynchronouslyHandler.cs
      Extensions.cs
      TicketFlow.Services.Tickets.Core.csproj
    run-migrations.sh
  Translations/
    TicketFlow.Services.Translations.Api/
      Properties/
        launchSettings.json
      appsettings.Development.json
      appsettings.json
      Program.cs
      TicketFlow.Services.Translations.Api.csproj
      translations-api.http
    TicketFlow.Services.Translations.Core/
      Messaging/
        Consuming/
          RequestTranslation/
            RequestTranslationHandler.cs
            RequestTranslationV1.cs
            RequestTranslationV2.cs
        Publishing/
          TranslationCompleted.cs
          TranslationSkipped.cs
        TranslationsConsumerService.cs
        TranslationTopologyInitializer.cs
      SynchronousIntegration/
        GetTranslatedTextSynchronously.cs
        GetTranslatedTextSynchronouslyHandler.cs
      Translations/
        Extensions.cs
        ITranslationsService.cs
        NoopTranslationsService.cs
        OpenAiTranslationsService.cs
        TranslationLanguage.cs
      Extensions.cs
      TicketFlow.Services.Translations.Core.csproj
  run_all_be.sh
  run_all_migrations.sh
src_frontend/
  inquiries/
    app/
      components/
        client-layout.tsx
      inquiries-list/
        inquiry.tsx
        page.tsx
      lib/
        translations.ts
      services/
        agents.ts
        inquiryService.ts
        messages.ts
        ticketService.ts
      submit-inquiry/
        page.tsx
      types/
        employee.ts
        enums.ts
        inquiry.ts
        message.ts
      globals.css
      layout.tsx
      page.tsx
      providers.tsx
    components/
      custom/
        custom-nav.tsx
        data-table.tsx
        footer.tsx
      messages/
        message-item.tsx
        message-list.tsx
      ui/
        avatar.tsx
        badge.tsx
        button.tsx
        card.tsx
        dialog.tsx
        dropdown-menu.tsx
        form.tsx
        input.tsx
        label.tsx
        navigation-menu.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        sonner.tsx
        switch.tsx
        table.tsx
        textarea.tsx
    lib/
      utils.ts
    .eslintrc.json
    .gitignore
    components.json
    db.json
    next.config.mjs
    package.json
    postcss.config.mjs
    tailwind.config.ts
    tsconfig.json
  technical/
    app/
      applications-list/
        page.tsx
      lib/
        translations.ts
      providers/
        tanstack-provider.tsx
      globals.css
      layout.tsx
      page.tsx
      providers.tsx
    components/
      custom/
        custom-nav.tsx
        data-table.tsx
        footer.tsx
      ui/
        avatar.tsx
        badge.tsx
        button.tsx
        card.tsx
        command.tsx
        dialog.tsx
        dropdown-menu.tsx
        form.tsx
        input.tsx
        label.tsx
        navigation-menu.tsx
        popover.tsx
        select.tsx
        separator.tsx
        sheet.tsx
        switch.tsx
        table.tsx
        textarea.tsx
        tooltip.tsx
      application-tile.tsx
    lib/
      axios.ts
      utils.ts
    types/
      anomaly.ts
      message.ts
    .eslintrc.json
    .gitignore
    components.json
    next.config.mjs
    package.json
    postcss.config.mjs
    tailwind.config.ts
    tsconfig.json
  tickets/
    app/
      lib/
        translations.ts
      providers/
        tanstack-provider.tsx
      tickets-list/
        page.tsx
        ticket.tsx
      types/
        enums.ts
      globals.css
      layout-content.tsx
      layout.tsx
      page.tsx
      providers.tsx
    components/
      alerts/
        alert-list.tsx
      custom/
        agent-required.tsx
        agent-select.tsx
        custom-nav.tsx
        data-table.tsx
        employee-card.tsx
        footer.tsx
      messages/
        message-item.tsx
        message-list.tsx
      metrics/
        mini-sparkline.tsx
        service-status-list.tsx
      ui/
        avatar.tsx
        badge.tsx
        button.tsx
        card.tsx
        command.tsx
        dialog.tsx
        dropdown-menu.tsx
        form.tsx
        input.tsx
        label.tsx
        navigation-menu.tsx
        popover.tsx
        select.tsx
        sheet.tsx
        switch.tsx
        table.tsx
        textarea.tsx
        tooltip.tsx
      ticket-details.tsx
      ticket-settings-dialog.tsx
    hooks/
      use-agents.ts
      use-alerts.ts
      use-services.ts
      use-tickets.ts
    lib/
      axios.ts
      ticket-styling.tsx
      utils.ts
    services/
      messages.ts
    store/
      use-agent-store.ts
    types/
      alert.ts
      message.ts
      services.ts
      ticket.ts
    .eslintrc.json
    .gitignore
    components.json
    next.config.mjs
    package.json
    postcss.config.mjs
    tailwind.config.ts
    tsconfig.json
  check_port.js
  kill_port.js
  run_all_fe.sh
tests/
  Inquiries/
    TicketFlow.Services.Inquiries.IntegrationTests/
      Messaging/
        TranslationsServiceIntegrationTests.cs
      Mocks/
        InquiriesTestRepository.cs
        TestLanguageDetector.cs
      TicketFlow.Services.Inquiries.IntegrationTests.csproj
  Translations/
    TicketFlow.Services.Translations.IntegrationTests/
      Messaging/
        InquiriesServiceIntegrationTests.cs
      Mocks/
        TestTranslationsService.cs
      TicketFlow.Services.Translations.IntegrationTests.csproj
.gitignore
README.md
run_infra.sh
run_ticketflow.sh
TicketFlow.sln
wipe_and_rebuild_infra.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="compose/docker-compose.yaml">
version: "1.0"

services:
  rabbitmq:
    image: rabbitmq-che
    container_name: 'ticketflow-rabbitmq'
    restart: unless-stopped
    volumes:
      - rabbitmq:/var/lib/rabbitmq
    networks:
      - TicketFlow
    ports:
      - 5672:5672
      - 15672:15672
      - 15692:15692
  postgres:
    image: postgres
    shm_size: '4gb'
    container_name: 'ticketflow-postgres'
    restart: unless-stopped
    environment:
      - POSTGRES_HOST_AUTH_METHOD=trust
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    ports:
      - 5432:5432
    volumes:
      - postgres:/var/lib/postgresql/data
  jaeger:
    image: jaegertracing/all-in-one:latest
    container_name: jaeger
    networks:
      - TicketFlow
    ports:
      - "5775:5775/udp"
      - "6831:6831/udp"
      - "6832:6832/udp"
      - "4317:4317"
      - "5778:5778"
      - "16686:16686"
      - "14268:14268"
      - "14250:14250"
      - "9411:9411"
    environment:
      COLLECTOR_ZIPKIN_HTTP_PORT: 9411

networks:
  TicketFlow:
    name: ticketflow-network

volumes:
  rabbitmq:
    driver: local
  postgres:
    driver: local
</file>

<file path="compose/Dockerfile">
FROM rabbitmq:3.13.6-management
RUN rabbitmq-plugins enable rabbitmq_consistent_hash_exchange
# Add this to ensure we start fresh
ENV RABBITMQ_SERVER_ADDITIONAL_ERL_ARGS="-rabbitmq_management force_fine_statistics true"
</file>

<file path="docs/ANOMALIE.md">
# Anomalie w TicketFlow

Gdy po raz pierwszy siadaliśmy do budowania listy modułów i rozpisywania lekcji, jedną z głównych rzeczy która wydawała się nam upierdliwa w wykonaniu było płynne i w miarę bezobsługowe pokazanie osobie przechodzącej przez kurs jak na różne problemy w systemie rozproszonym reaguje nasza modelowa aplikacja.

Doszliśmy do wniosku, że skoro budujemy UI do TicketFlow, to powinniśmy także umożliwić Ci odkrywanie, jak system się zachowa, gdy w wybrane miejsce wkradnie się problem.

Tak też powstał system generowanie anomalii 🧪 w TicketFlow!

![anomalie](./images/anomalie.png)

Ale o co tu właściwie chodzi?

Dla każdej z usług, które wchodzą w skład naszej aplikacji TicketFlow możesz wybrać jeden ze zdefiniowanych typów anomalii takich jak opóźnienie czy wyjątek oraz zdecydować w którym momencie publikacji czy konsumpcji komunikatu ma wystąpić:


![anomalie](./images/anomalie_typ.gif)

Żeby to miało sens, do wyboru są również dostępne w systemie komunikaty jak i ew. parametry opóźnienia, tak by można było eksperymentować z pomysłami jak “wysadzić” naszą komunikację asynchroniczną, by potem wykorzystać zdobytą wiedzę z kursu i zaradzić tym problemom:

![anomalie](./images/anomalie_submit.gif)

Albo obserwować jak TicketFlow płonie 🔥

![anomalie](./images/system_plonie.png)

Pewnie teraz myślisz: “Bardzo fajnie, ale właściwie po co to komu? Przecież teoretycznie można wejść w kod i popsuć go samemu/samej w ramach eksperymentu.”

Pełna zgoda, ale! ☝️

🤔 Po pierwsze - założyliśmy, że w ten sposób **nawet osoba nie do końca znająca C# może “pobawić się” zachowaniem systemu** by lepiej zrozumieć - nawet od strony użytkownika końcowego - jakie konsekwencje ma wystąpienie konkretnej anomalii w danym miejscu w systemie. 
Chcesz przerabiając kurs pokazać potencjalny problem np. QA z twojego zespołu? Nic prostszego.

🔍 Po drugie - w kursie przedstawiamy - w myśl architektury **pipes and filters** - sposób rozszerzania zarówno pipeline’u producenta i konsumenta. Dlaczego by nie pokazać jeszcze jednego mechanizmu, który wpisuje się w tę ideę?

🧠 Po trzecie - skoro to kurs opierający się o RabbitMQ, dlaczego by nie pokazać **kolejnego przypadku użycia, który opiera się o komunikację asynchroniczną**? Generator anomalii bowiem nie tylko potrafi obsłużyć jedną instancję danej usługi, ale i w przypadku wielu uruchomionych instancji danego serwisu będzie - przy użyciu **kolejek tymczasowych** - synchronizował stan pomiędzy nimi.
Masz podobny case? Zobacz jak +/- taki flow mógłby wyglądać.
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Alerting/AlertingTopologyBuilder.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.Communication.Alerting;

public class AlertingTopologyBuilder(ITopologyBuilder topologyBuilder, IMessagePublisherConventionProvider publisherConventionProvider)
{
    public const string AlertsExchange = "alerting";
    
    public async Task CreateTopologyAsync(CancellationToken cancellationToken)
    {
        var alertMessageTypes = AppDomain.CurrentDomain
            .GetAssemblies()
            .SelectMany(x => x.GetTypes())
            .Where(x => x is { IsClass: true, IsAbstract: false } && typeof(IAlertMessage).IsAssignableFrom(x));

        foreach (var messageType in alertMessageTypes)
        {
            var (publisherDestination, _) = ((string, string)) typeof(IMessagePublisherConventionProvider)
                .GetMethod(nameof(IMessagePublisherConventionProvider.Get))
                .MakeGenericMethod(messageType)
                .Invoke(publisherConventionProvider, null);

            var routingKey = "#." + AlertMessageConventions.AlertingSuffix + ".#";
            routingKey = routingKey.Replace("..", ".");
            
            await topologyBuilder.CreateTopologyAsync(
                publisherDestination,
                AlertsExchange,
                TopologyType.PublisherToPublisher,
                filter: routingKey,
                cancellationToken: cancellationToken);
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Alerting/AlertMessageConventions.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Communication.Alerting;

public static class AlertMessageConventions
{
    public const string AlertingSuffix = ".alert";
    
    public static string WithAlertingApplied<TMessage>(this string routingKey) where TMessage: class, IMessage
    {
        if (typeof(IAlertMessage).IsAssignableFrom(typeof(TMessage)))
        {
            return routingKey + AlertingSuffix;
        }

        return routingKey;
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Alerting/IAlertMessage.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Communication.Alerting;

public interface IAlertMessage : IMessage
{
    string AlertMessageContent { get; }
    string AlertType { get; }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Alerting/TicketFlow.Services.Communication.Alerting.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>disable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/DTO/MessageListDto.cs">
using TicketFlow.Services.Communication.Core.Data.Models;

namespace TicketFlow.Services.Communication.Api.DTO;

public record MessageListDto(List<Message> Data, long Total);
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:31690",
      "sslPort": 44331
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5148",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7227;http://localhost:5148",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "App": {
    "AppName" : "communication-service"
  },
  "Deduplication": {
    "Enabled": false
  },
  "Observability" : {
    "Enabled" : false,
    "Endpoint" : "http://localhost:4317"
  },
  "Outbox": {
    "Enabled": false,
    "PublishOnCommit" : true,
    "IntervalMilliseconds" : 3000,
    "BatchSize": 1
  },
  "Postgres": {
    "ConnectionString": "Host=localhost;Database=TicketFlow.Communication;Username=postgres;Password="
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Services": {
    "Tickets": "http://localhost:5112"
  },
  "Metrics": {
    "Enabled": false
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 10
    },
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/Program.cs">
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Communication.Api.DTO;
using TicketFlow.Services.Communication.Core;
using TicketFlow.Services.Communication.Core.Data;
using TicketFlow.Services.Communication.Core.Data.Models;
using TicketFlow.Services.Communication.Core.Validators;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AspNetCore;
using TicketFlow.Shared.Exceptions;

var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddCore(builder.Configuration)
    .AddApiForFrontendConfigured();

var app = builder.Build();

app.ExposeApiForFrontend();
app.UseAnomalyEndpoints();

app.MapGet("/alerts/", async (
    [FromServices] CommunicationDbContext dbContext,
    [FromQuery] bool onlyUnread = false,
    CancellationToken cancellationToken = default) =>
{
    var dbQuery = dbContext.Alerts
        .AsQueryable();
        
    if (onlyUnread)
    {
        dbQuery = dbQuery.Where(x => !x.IsRead);
    }
    
    return await dbQuery
        .OrderByDescending(x => x.CreatedAt)
        .Take(10)
        .ToListAsync(cancellationToken);
});

app.MapPut("/alerts/{alertId}", async (
    [FromRoute] Guid alertId,
    [FromQuery] bool isRead,
    [FromServices] CommunicationDbContext dbContext,
    CancellationToken cancellationToken) =>
{
    var alert = await dbContext.Alerts.SingleOrDefaultAsync(x => x.Id == alertId, cancellationToken);
    alert.IsRead = isRead;
    await dbContext.SaveChangesAsync(cancellationToken);
    return Results.Ok();
});

app.MapGet("/logged-users/{userId}/messages/", async (
    [FromServices] CommunicationDbContext dbContext,
    [FromRoute] Guid userId,
    [FromQuery] bool onlyUnread = false,
    [FromQuery] int page = 1,
    [FromQuery] int limit = 10,
    CancellationToken cancellationToken = default) =>
{
    var dbQuery = dbContext.Messages
        .AsQueryable()
        .Where(x => x.RecipentUserId.Equals(userId));

    if (onlyUnread)
    {
        dbQuery = dbQuery.Where(x => !x.IsRead);
    }
    
    var total = await dbQuery.CountAsync(cancellationToken);
    
    var data = await dbQuery
        .OrderByDescending(x => x.Timestamp)
        .Skip((page - 1) * limit)
        .Take(limit)
        .ToListAsync(cancellationToken);
    
    return new MessageListDto(data, total);
});

app.MapGet("/anonymous-users/messages/", async (
    [FromServices] CommunicationDbContext dbContext,
    [FromQuery] bool onlyUnread = false,
    [FromQuery] int page = 1,
    [FromQuery] int limit = 10,
    CancellationToken cancellationToken = default) =>
{
    var dbQuery = dbContext.Messages
        .AsQueryable()
        .Where(x => x.RecipentUserId == null); // Recipient UserId == null -> anonymous user from Inquiries
    
    if (onlyUnread)
    {
        dbQuery = dbQuery.Where(x => !x.IsRead);
    }
    
    var total = await dbQuery.CountAsync(cancellationToken);
    
    var data = await dbQuery
        .OrderByDescending(x => x.Timestamp)
        .Skip((page - 1) * limit)
        .Take(limit)
        .ToListAsync(cancellationToken);
    
    return new MessageListDto(data, total);
});

app.MapPut("/messages/{messageId}", async (
    [FromRoute] Guid messageId,
    [FromQuery] bool isRead,
    [FromServices] CommunicationDbContext dbContext,
    CancellationToken cancellationToken) =>
{
    var message = await dbContext.Messages.SingleOrDefaultAsync(x => x.Id == messageId, cancellationToken);
    message.IsRead = isRead;
    await dbContext.SaveChangesAsync(cancellationToken);
    return Results.Ok();
});

app.MapPost("/messages", async (
    [FromBody] Message message,
    [FromServices] CommunicationDbContext dbContext,
    CancellationToken cancellationToken) =>
{
    new MessageValidator().Validate(message);

    dbContext.Messages.Add(message);
    await dbContext.SaveChangesAsync(cancellationToken);
    return Results.Ok();
});

app.Run();
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
    
    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.Communication.Core\TicketFlow.Services.Communication.Core.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Configurations/AlertConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Communication.Core.Data.Models;

namespace TicketFlow.Services.Communication.Core.Data.Configurations;

public class AlertConfiguration : IEntityTypeConfiguration<Alert>
{

    public void Configure(EntityTypeBuilder<Alert> builder)
    {
        builder.HasKey(x => x.Id);

        builder.Property(x => x.Message).IsRequired();
        builder.Property(x => x.CreatedAt).IsRequired();
        builder.Property(x => x.IsRead).IsRequired();
        builder.Property(x => x.Type).IsRequired();
        
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Configurations/MessageConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Communication.Core.Data.Models;

namespace TicketFlow.Services.Communication.Core.Data.Configurations;

public class MessageConfiguration : IEntityTypeConfiguration<Message>
{

    public void Configure(EntityTypeBuilder<Message> builder)
    {
        builder.HasKey(x => x.Id);

        builder.Property(x => x.RecipentEmail);
        builder.Property(x => x.RecipentUserId);
        builder.Property(x => x.SenderUserId); // If NULL -> sender == SYSTEM
        builder.Property(x => x.Title).IsRequired();
        builder.Property(x => x.Content).IsRequired();
        builder.Property(x => x.Timestamp).IsRequired();
        builder.Property(x => x.IsRead).IsRequired();
        
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223145106_Initial.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    /// <inheritdoc />
    public partial class Initial : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.EnsureSchema(
                name: "communication");

            migrationBuilder.CreateTable(
                name: "Alerts",
                schema: "communication",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Message = table.Column<string>(type: "text", nullable: false),
                    CreatedAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false),
                    IsRead = table.Column<bool>(type: "boolean", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Alerts", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Messages",
                schema: "communication",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    RecipentEmail = table.Column<string>(type: "text", nullable: false),
                    RecipentUserId = table.Column<Guid>(type: "uuid", nullable: true),
                    SenderUserId = table.Column<Guid>(type: "uuid", nullable: true),
                    Title = table.Column<string>(type: "text", nullable: false),
                    Content = table.Column<string>(type: "text", nullable: false),
                    Timestamp = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false),
                    IsUnread = table.Column<bool>(type: "boolean", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Messages", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Alerts",
                schema: "communication");

            migrationBuilder.DropTable(
                name: "Messages",
                schema: "communication");
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223145106_Initial.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Communication.Core.Data;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    [DbContext(typeof(CommunicationDbContext))]
    [Migration("20241223145106_Initial")]
    partial class Initial
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("communication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Alert", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Alerts", "communication");
                });

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Message", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsUnread")
                        .HasColumnType("boolean");

                    b.Property<string>("RecipentEmail")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid?>("RecipentUserId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("SenderUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Messages", "communication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223150802_Consolidate_IsRead_props.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    /// <inheritdoc />
    public partial class Consolidate_IsRead_props : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "IsUnread",
                schema: "communication",
                table: "Messages",
                newName: "IsRead");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "IsRead",
                schema: "communication",
                table: "Messages",
                newName: "IsUnread");
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223150802_Consolidate_IsRead_props.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Communication.Core.Data;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    [DbContext(typeof(CommunicationDbContext))]
    [Migration("20241223150802_Consolidate_IsRead_props")]
    partial class Consolidate_IsRead_props
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("communication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Alert", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Alerts", "communication");
                });

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Message", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("RecipentEmail")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<Guid?>("RecipentUserId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("SenderUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Messages", "communication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223152905_Recipient_Email.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    /// <inheritdoc />
    public partial class Recipient_Email : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "RecipentEmail",
                schema: "communication",
                table: "Messages",
                type: "text",
                nullable: true,
                oldClrType: typeof(string),
                oldType: "text");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "RecipentEmail",
                schema: "communication",
                table: "Messages",
                type: "text",
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "text",
                oldNullable: true);
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/20241223152905_Recipient_Email.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Communication.Core.Data;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    [DbContext(typeof(CommunicationDbContext))]
    [Migration("20241223152905_Recipient_Email")]
    partial class Recipient_Email
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("communication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Alert", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Alerts", "communication");
                });

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Message", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("RecipentEmail")
                        .HasColumnType("text");

                    b.Property<Guid?>("RecipentUserId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("SenderUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Messages", "communication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/Communication/CommunicationDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Communication.Core.Data;

#nullable disable

namespace TicketFlow.Services.Communication.Core.Data.Migrations.Communication
{
    [DbContext(typeof(CommunicationDbContext))]
    partial class CommunicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("communication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Alert", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("Message")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Alerts", "communication");
                });

            modelBuilder.Entity("TicketFlow.Services.Communication.Core.Data.Models.Message", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Content")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<bool>("IsRead")
                        .HasColumnType("boolean");

                    b.Property<string>("RecipentEmail")
                        .HasColumnType("text");

                    b.Property<Guid?>("RecipentUserId")
                        .HasColumnType("uuid");

                    b.Property<Guid?>("SenderUserId")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("Timestamp")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Messages", "communication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Migrations/scripts.txt">
// Create migration for Communication schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Communication --startup-project ./../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context CommunicationDbContext

// Apply migration for Communication schema
dotnet ef database update --startup-project ../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context CommunicationDbContext

// Create migration for Deduplication schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Deduplication --startup-project ./../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context DeduplicationDbContext

// Apply migration for Deduplication schema
dotnet ef database update --startup-project ../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context DeduplicationDbContext

// Create migration for Outbox schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Outbox --startup-project ./../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context OutboxDbContext

// Apply migration for Outbox schema
dotnet ef database update --startup-project ../TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context OutboxDbContext
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Models/Alert.cs">
namespace TicketFlow.Services.Communication.Core.Data.Models;

public class Alert
{
    public Guid Id { get; set; }
    public string Message { get; set; }
    public DateTimeOffset CreatedAt { get; set; }
    public bool IsRead { get; set; }
    public string Type { get; set; }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/Models/Message.cs">
namespace TicketFlow.Services.Communication.Core.Data.Models;

public class Message
{
    public Guid Id { get; set; } = Guid.NewGuid();
    public string? RecipentEmail { get; set; }
    public Guid? RecipentUserId { get; set; }
    public Guid? SenderUserId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
    public DateTimeOffset Timestamp { get; set; }
    public bool IsRead { get; set; }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Data/CommunicationDbContext.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Communication.Core.Data.Models;

namespace TicketFlow.Services.Communication.Core.Data;

public class CommunicationDbContext(DbContextOptions options) : DbContext(options)
{
    public DbSet<Message> Messages { get; set; }
    public DbSet<Alert> Alerts { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(GetType().Assembly);
        modelBuilder.HasDefaultSchema("communication");
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Http/Tickets/ITicketsClient.cs">
namespace TicketFlow.Services.Communication.Core.Http.Tickets;

public interface ITicketsClient
{
    Task<TicketDto> GetTicketDetails(string ticketId, CancellationToken cancellationToken);
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Http/Tickets/TicketDetails.cs">
namespace TicketFlow.Services.Communication.Core.Http.Tickets;

public record TicketDto(
    string Id,
    string Email,
    string Status,
    Guid? AssignedAgentUserId,
    string? Resolution);
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Http/Tickets/TicketsClient.cs">
using TicketFlow.Shared.Serialization;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace TicketFlow.Services.Communication.Core.Http.Tickets;

internal class TicketsClient : ITicketsClient
{
    private readonly HttpClient _httpClient;
    
    public TicketsClient(HttpClient httpClient)
    {
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
    }
    
    public async Task<TicketDto> GetTicketDetails(string ticketId, CancellationToken cancellationToken)
    {
        var json = await _httpClient.GetStringAsync($"/tickets/{ticketId}", cancellationToken);
        var result = JsonSerializer.Deserialize<TicketDto>(json, SerializationOptions.Default);
        return result;
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/Consuming/AlertsHandler.cs">
using TicketFlow.Services.Communication.Core.Data;
using TicketFlow.Services.Communication.Core.Data.Models;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Communication.Core.Messaging.Consuming;

public class AlertsHandler(CommunicationDbContext dbContext) : IMessageHandler<ProducerAgnosticAlertMessage>
{
    public async Task HandleAsync(ProducerAgnosticAlertMessage message, CancellationToken cancellationToken = default)
    {
        var alert = new Alert
        {
            CreatedAt = DateTimeOffset.UtcNow,
            Type = message.AlertType,
            Message = message.AlertMessageContent
        };
        
        await dbContext.AddAsync(alert, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/Consuming/ProducerAgnosticAlertMessage.cs">
using TicketFlow.Services.Communication.Alerting;

namespace TicketFlow.Services.Communication.Core.Messaging.Consuming;

public class ProducerAgnosticAlertMessage : IAlertMessage
{
    public string AlertMessageContent { get; set; }
    public string AlertType { get; set; }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/Consuming/TicketResolvedHandler.cs">
using TicketFlow.Services.Communication.Core.Data;
using TicketFlow.Services.Communication.Core.Data.Models;
using TicketFlow.Services.Communication.Core.Http.Tickets;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Communication.Core.Messaging.Consuming;

public class TicketResolvedHandler(ITicketsClient ticketsClient, CommunicationDbContext dbContext)
    : IMessageHandler<TicketResolved>
{
    public async Task HandleAsync(TicketResolved message, CancellationToken cancellationToken = default)
    {
        var ticketDetails = await ticketsClient.GetTicketDetails(message.TicketId.ToString(), cancellationToken);
        if (ticketDetails is null)
        {
            throw new TicketFlowException($"Could not fetch data of ticket: {message.TicketId}");
        }

        await dbContext.Messages.AddAsync(
            new Message
            {
                RecipentEmail = ticketDetails.Email,
                Title = "Zgłoszenie zamknięte!",
                Content =
                    $@"Zakończono procesowanie twojego zgłoszenia 
                        ze statusem: [{ticketDetails.Status}], 
                        rozwiązaniem: {ticketDetails.Resolution}",
                SenderUserId = ticketDetails.AssignedAgentUserId,
                Timestamp = DateTimeOffset.UtcNow
            }, cancellationToken);
        
        await dbContext.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/CommunicationConsumer.cs">
using Microsoft.Extensions.Hosting;
using TicketFlow.Services.Communication.Core.Messaging.Consuming;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Communication.Core.Messaging;

public class CommunicationConsumer(IMessageConsumer messageConsumer, AnomalySynchronizationConfigurator anomalyConfigurator) : BackgroundService
{
    public const string TicketResolvedQueue = "communication-ticket-resolved";
    public const string AlertsQueue = "communication-alerts";
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await messageConsumer
            .ConsumeMessage<TicketResolved>(
                queue: TicketResolvedQueue,
                acceptedMessageTypes: null, /* Accept all of them */
                cancellationToken: stoppingToken);
        
        await messageConsumer
            .ConsumeMessage<ProducerAgnosticAlertMessage>(
                queue: AlertsQueue,
                acceptedMessageTypes: null, /* Accept all of them */
                cancellationToken: stoppingToken);
        
        await anomalyConfigurator.ConsumeAnomalyChanges();
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/CommunicationTopologyInitializer.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.Communication.Core.Messaging;

public class CommunicationTopologyInitializer : TopologyInitializerBase
{
    public CommunicationTopologyInitializer(IServiceProvider serviceProvider) : base(serviceProvider)
    {}

    protected override async Task CreateTopologyAsync(CancellationToken stoppingToken)
    {
        await CreateAnomalySynchronizationTopology(stoppingToken);
        
        var topologyBuilder = ServiceProvider.GetService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: "tickets-exchange",
            consumerDestination: CommunicationConsumer.TicketResolvedQueue,
            TopologyType.PublishSubscribe,
            filter: "ticket-resolved",
            cancellationToken: stoppingToken
        );

        await topologyBuilder.CreateTopologyAsync(
            publisherSource: AlertingTopologyBuilder.AlertsExchange,
            consumerDestination: CommunicationConsumer.AlertsQueue,
            TopologyType.PublishSubscribe,
            cancellationToken: stoppingToken
        );
    }
    
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Messaging/TicketResolved.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Communication.Core.Messaging;

public record TicketResolved(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Validators/MessageValidator.cs">
using TicketFlow.Services.Communication.Core.Data.Models;
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Services.Communication.Core.Validators;

public class MessageValidator
{
    public void Validate(Message message)
    {
        if (message.RecipentUserId is null && message.RecipentEmail is null)
        {
            throw new TicketFlowException("Either recipient's email or userId must be provided");
        }

        if (string.IsNullOrEmpty(message.Title))
        {
            throw new TicketFlowException("Title must be provided");
        }
        
        if (string.IsNullOrEmpty(message.Content))
        {
            throw new TicketFlowException("Content must be provided");
        }
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.Communication.Core.Data;
using TicketFlow.Services.Communication.Core.Http.Tickets;
using TicketFlow.Services.Communication.Core.Messaging;
using TicketFlow.Services.SystemMetrics.Generator;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Deduplication;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.Communication.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services
            .AddExceptions()
            .AddSerialization()
            .AddApp(configuration)
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x
                .UseRabbitMq()
                .UseMessageConsumerConvention<DontUseConventionalTopology>()
                .UseDeduplication()
                .UseOutbox()
                .UseAnomalies()
                .UseResiliency())
            .AddPostgres<CommunicationDbContext>(configuration)
            .AddSystemMetrics(configuration)
            .AddObservability(configuration);


        services.AddHttpClient<ITicketsClient, TicketsClient>(builder =>
        {
            builder.BaseAddress = new Uri(configuration.GetValue<string>("Services:Tickets"));
        });

        services.AddHostedService<CommunicationConsumer>();
        services.AddHostedService<CommunicationTopologyInitializer>();
        
        return services;
    }
}
</file>

<file path="src/Communication/TicketFlow.Services.Communication.Core/TicketFlow.Services.Communication.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\..\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
      <ProjectReference Include="..\TicketFlow.Services.Communication.Alerting\TicketFlow.Services.Communication.Alerting.csproj" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Data\Migrations\Communication\" />
    </ItemGroup>

</Project>
</file>

<file path="src/Communication/run-migrations.sh">
dotnet ef database update --startup-project ./TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context CommunicationDbContext
dotnet ef database update --startup-project ./TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context DeduplicationDbContext
dotnet ef database update --startup-project ./TicketFlow.Services.Communication.Api/TicketFlow.Services.Communication.Api.csproj --context OutboxDbContext
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:54650",
      "sslPort": 44310
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5011",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7160;http://localhost:5078",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "OpenAi" : {
    "ApiKey" : "test"
  }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "App": {
    "AppName" : "inquiries-service"
  },
  "Observability" : {
    "Enabled" : false,
    "Endpoint" : "http://localhost:4317"
  },
  "OpenAi" : {
    "Enabled": false,
    "ApiKey" : ""
  },
  "Postgres": {
    "ConnectionString": "Host=localhost;Database=TicketFlow.Inquiries;Username=postgres;Password="
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Metrics": {
    "Enabled": false
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 10
    },
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/inquiries-api.http">
@url = http://localhost:5011
@email = user@test.com

###
GET {{url}}

###
POST {{url}}/inquiries/submit-sync
Content-Type: application/json

{
  "name": "John Doe",
  "email": "{{email}}",
  "category": "general",
  "title" : "Help",
  "description": "Hi, got an issue:/"
}

###
POST {{url}}/inquiries/submit
Content-Type: application/json

{
  "name": "John Doe",
  "email": "{{email}}",
  "category": "general",
  "title" : "Help",
  "description": "Hi, got an issue:/"
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/Program.cs">
using Microsoft.AspNetCore.Mvc;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Inquiries.Core;
using TicketFlow.Services.Inquiries.Core.Commands.SubmitInquiry;
using TicketFlow.Services.Inquiries.Core.Commands.SubmitInquirySynchronously;
using TicketFlow.Services.Inquiries.Core.Queries;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AspNetCore;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Queries;

var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddCore(builder.Configuration)
    .AddApiForFrontendConfigured();

var app = builder.Build();

app.ExposeApiForFrontend();
app.UseAnomalyEndpoints();

app.MapGet("/", () => "Inquiries Service");

app.MapGet("/inquiries", async (
    [FromQuery] int page,
    [FromQuery] int limit,
    [FromServices] IQueryHandler<ListInquiries, InquiriesListDto> handler,
    CancellationToken cancellationToken) 
    => Results.Ok((object?)await handler.HandleAsync(new(page, limit), cancellationToken)));

app.MapPost("/inquiries/submit", async (
    [FromBody] SubmitInquiry command, 
    [FromServices] ICommandHandler<SubmitInquirySynchronously> synchronousHandler,
    [FromServices] ICommandHandler<SubmitInquiry> handler,
    CancellationToken cancellationToken) =>
{
    if (FeatureFlags.UseSynchronousIntegration)
    {
        var synchronousCommand = new SubmitInquirySynchronously(command.Name, command.Email, command.Title, command.Description, command.Category);
        await synchronousHandler.HandleAsync(synchronousCommand);
        return Results.Ok();
    }
    else
    {
        await handler.HandleAsync(command, cancellationToken);
        return Results.Ok();
    }
});

app.MapPost("/inquiries/submit-sync", async ([FromBody] SubmitInquirySynchronously command, [FromServices] ICommandHandler<SubmitInquirySynchronously> handler,
    CancellationToken cancellationToken) =>
{
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.Run();

public partial class Program { }
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Api/TicketFlow.Services.Inquiries.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.Inquiries.Core\TicketFlow.Services.Inquiries.Core.csproj" />
    </ItemGroup>


</Project>
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Commands/SubmitInquiry/SubmitInquiry.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Inquiries.Core.Commands.SubmitInquiry;

public sealed record SubmitInquiry(string Name, string Email, string Title, string Description, string Category) : ICommand;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Commands/SubmitInquiry/SubmitInquiryHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Inquiries.Core.Data.Models;
using TicketFlow.Services.Inquiries.Core.Data.Repositories;
using TicketFlow.Services.Inquiries.Core.LanguageDetection;
using TicketFlow.Services.Inquiries.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Commands.SubmitInquiry;

internal sealed class SubmitInquiryHandler(IInquiriesRepository repository, ILanguageDetector languageDetector, 
    IMessagePublisher messagePublisher, ILogger<SubmitInquiryHandler> logger) : ICommandHandler<SubmitInquiry>
{
    private const string EnglishLanguageCode = "en";
    public async Task HandleAsync(SubmitInquiry command, CancellationToken cancellationToken = default)
    {
        var (name, email, title, description, category) = command;
        var categoryParsed = ParseCategory(category);
        var inquiry = new Inquiry(name, email, title, description, categoryParsed);
        
        await repository.AddAsync(inquiry, cancellationToken);
        var languageCode = await languageDetector.GetTextLanguageCode(inquiry.Description, cancellationToken);

        var inquiryReportedMessage = new InquirySubmitted(
            inquiry.Id,
            inquiry.Name,
            inquiry.Email,
            inquiry.Title,
            inquiry.Description,
            inquiry.Category.ToString(),
            languageCode,
            inquiry.CreatedAt);
        await messagePublisher.PublishAsync(inquiryReportedMessage, cancellationToken: cancellationToken);
        
        logger.LogInformation($"Inquiry with id: {inquiry.Id} submitted successfully.");
        
        if (languageCode is not EnglishLanguageCode)
        {
            var requestTranslationV1 = new RequestTranslationV1(inquiry.Description, inquiry.Id);
            var requestTranslationV2 = new RequestTranslationV2(inquiry.Description, languageCode, inquiry.Id);
            
            await messagePublisher.PublishAsync(requestTranslationV1, destination: "", routingKey: "request-translation-v1-queue", cancellationToken: cancellationToken);
            await messagePublisher.PublishAsync(requestTranslationV2, destination: "", routingKey: "request-translation-v2-queue", cancellationToken: cancellationToken);
            
            logger.LogInformation($"Translation for inquiry with id: {inquiry.Id} has been requested.");
        }
    }

    private static InquiryCategory ParseCategory(string category)
    {
        CapitalizeInput();
        var parseSucceeded = Enum.TryParse<InquiryCategory>(category, out var categoryParsed);
        
        if (!parseSucceeded)
        {
            categoryParsed = InquiryCategory.Other;
        }

        return categoryParsed;

        void CapitalizeInput()
        {
            category = category[0].ToString().ToUpper() + category.Substring(1, category.Length - 1);
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Commands/SubmitInquirySynchronously/CreateTicketSynchronously.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Inquiries.Core.Commands.SubmitInquirySynchronously;

public sealed record CreateTicketSynchronously(
    Guid Id,
    string Name,
    string Email,
    string Title,
    string Description,
    string TranslatedDescription,
    string Category,
    string LanguageCode,
    DateTimeOffset CreatedAt) : ICommand;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Commands/SubmitInquirySynchronously/SubmitInquirySynchronously.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Inquiries.Core.Commands.SubmitInquirySynchronously;

public record SubmitInquirySynchronously(string Name, string Email, string Title, string Description, string Category) : ICommand;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Commands/SubmitInquirySynchronously/SubmitInquirySynchronouslyHandler.cs">
using System.Net.Http.Json;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Inquiries.Core.Commands.SubmitInquiry;
using TicketFlow.Services.Inquiries.Core.Data.Models;
using TicketFlow.Services.Inquiries.Core.Data.Repositories;
using TicketFlow.Services.Inquiries.Core.LanguageDetection;
using TicketFlow.Services.Inquiries.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Commands.SubmitInquirySynchronously;

public class SubmitInquirySynchronouslyHandler(
    IInquiriesRepository repository, 
    ILanguageDetector languageDetector, 
    IHttpClientFactory httpClientFactory, 
    ILogger<SubmitInquirySynchronouslyHandler> logger) : ICommandHandler<SubmitInquirySynchronously>
{
    private const string EnglishLanguageCode = "en";
    
    public async Task HandleAsync(SubmitInquirySynchronously command, CancellationToken cancellationToken = default)
    {
        var (name, email, title, description, category) = command;
        
        var httpClient = httpClientFactory.CreateClient();
        var categoryParsed = ParseCategory(category);
        var inquiry = new Inquiry(name, email, title, description, categoryParsed);
        
        await repository.AddAsync(inquiry, cancellationToken);
        
        var languageCode = await languageDetector.GetTextLanguageCode(inquiry.Description, cancellationToken);
        var translatedDescription = string.Empty;
        
        if (languageCode is not EnglishLanguageCode)
        {
            logger.LogInformation($"Translation for inquiry with id: {inquiry.Id} has been requested.");

            var translationResponse = await httpClient.PostAsJsonAsync("http://localhost:5274/translations", new {Text = inquiry.Description}, cancellationToken);
            translationResponse.EnsureSuccessStatusCode();

            translatedDescription = await translationResponse.Content.ReadFromJsonAsync<string>(cancellationToken);
        }
        
        var inquiryReportedMessage = new CreateTicketSynchronously(
            inquiry.Id,
            inquiry.Name,
            inquiry.Email,
            inquiry.Title,
            inquiry.Description,
            translatedDescription,
            inquiry.Category.ToString(),
            languageCode,
            inquiry.CreatedAt);
        
        var ticketsResponse = await httpClient.PostAsJsonAsync("http://localhost:5112/tickets", inquiryReportedMessage, cancellationToken);
        ticketsResponse.EnsureSuccessStatusCode();
    }

    private static InquiryCategory ParseCategory(string category)
    {
        CapitalizeInput();
        var parseSucceeded = Enum.TryParse<InquiryCategory>(category, out var categoryParsed);
        
        if (!parseSucceeded)
        {
            categoryParsed = InquiryCategory.Other;
        }

        return categoryParsed;

        void CapitalizeInput()
        {
            category = category[0].ToString().ToUpper() + category.Substring(1, category.Length - 1);
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Configurations/InquiryConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Inquiries.Core.Data.Models;

namespace TicketFlow.Services.Inquiries.Core.Data.Configurations;

internal sealed class InquiryConfiguration : IEntityTypeConfiguration<Inquiry>
{
    public void Configure(EntityTypeBuilder<Inquiry> builder)
    {
        builder.HasKey(x => x.Id);
        builder.Property(x => x.Name).IsRequired();
        builder.Property(x => x.Email).IsRequired();
        builder.Property(x => x.Description).IsRequired();
        builder.Property(x => x.CreatedAt).IsRequired();
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241026110344_Init.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    /// <inheritdoc />
    public partial class Init : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Inquiries",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Email = table.Column<string>(type: "text", nullable: false),
                    Description = table.Column<string>(type: "text", nullable: false),
                    CreatedAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Inquiries", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Inquiries");
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241026110344_Init.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Inquiries.Core.Data;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    [DbContext(typeof(InquiriesDbContext))]
    [Migration("20241026110344_Init")]
    partial class Init
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Inquiries.Core.Data.Models.Inquiry", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Inquiries");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241116205352_FE_alignment.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    /// <inheritdoc />
    public partial class FE_alignment : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<int>(
                name: "Category",
                table: "Inquiries",
                type: "integer",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<int>(
                name: "Status",
                table: "Inquiries",
                type: "integer",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<string>(
                name: "Title",
                table: "Inquiries",
                type: "text",
                nullable: false,
                defaultValue: "");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Category",
                table: "Inquiries");

            migrationBuilder.DropColumn(
                name: "Status",
                table: "Inquiries");

            migrationBuilder.DropColumn(
                name: "Title",
                table: "Inquiries");
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241116205352_FE_alignment.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Inquiries.Core.Data;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    [DbContext(typeof(InquiriesDbContext))]
    [Migration("20241116205352_FE_alignment")]
    partial class FE_alignment
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Inquiries.Core.Data.Models.Inquiry", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Inquiries");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241228190704_Inquiry_TicketId.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    /// <inheritdoc />
    public partial class Inquiry_TicketId : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<Guid>(
                name: "TicketId",
                table: "Inquiries",
                type: "uuid",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "TicketId",
                table: "Inquiries");
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/20241228190704_Inquiry_TicketId.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Inquiries.Core.Data;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    [DbContext(typeof(InquiriesDbContext))]
    [Migration("20241228190704_Inquiry_TicketId")]
    partial class Inquiry_TicketId
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Inquiries.Core.Data.Models.Inquiry", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<Guid?>("TicketId")
                        .HasColumnType("uuid");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Inquiries");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/InquiriesDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Inquiries.Core.Data;

#nullable disable

namespace TicketFlow.Services.Inquiries.Core.Data.Migrations
{
    [DbContext(typeof(InquiriesDbContext))]
    partial class InquiriesDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Inquiries.Core.Data.Models.Inquiry", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("Status")
                        .HasColumnType("integer");

                    b.Property<Guid?>("TicketId")
                        .HasColumnType("uuid");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Inquiries");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Migrations/scripts.txt">
// Create migration for Inquiries schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations --startup-project ./../TicketFlow.Services.Inquiries.Api/TicketFlow.Services.Inquiries.Api.csproj --context InquiriesDbContext

// Apply migration for Inquiries schema
dotnet ef database update --startup-project ../TicketFlow.Services.Inquiries.Api/TicketFlow.Services.Inquiries.Api.csproj --context InquiriesDbContext
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Models/Inquiry.cs">
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Services.Inquiries.Core.Data.Models;

public sealed class Inquiry
{
    public Guid Id { get; private set; }
    public string Name { get; private set; }
    public string Email { get; private set; }
    
    public string Title { get; private set; }
    public string Description { get; private set; }
    public DateTimeOffset CreatedAt { get; private set; }
    public InquiryStatus Status { get; private set; }
    public InquiryCategory Category { get; private set; }
    public Guid? TicketId { get; private set; }

    private Inquiry()
    {
    }

    public Inquiry(string name, string email, string title, string description, InquiryCategory category)
    {
        Id = Guid.NewGuid();
        Name = name;
        Email = email;
        Title = title;
        Description = description;
        Category = category;
        Status = InquiryStatus.New;
        CreatedAt = DateTimeOffset.UtcNow;
    }

    public void SetRelatedTicketId(Guid ticketId)
    {
        if (TicketId != null && TicketId != ticketId)
        {
            throw new TicketFlowException("Inquiry is already correlated with another ticket!");
        }
        TicketId = ticketId;
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Models/InquiryCategory.cs">
namespace TicketFlow.Services.Inquiries.Core.Data.Models;

public enum InquiryCategory
{
    General,
    Technical,
    Billing,
    Other
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Models/InquiryStatus.cs">
namespace TicketFlow.Services.Inquiries.Core.Data.Models;

public enum InquiryStatus
{
    New,
    InProgress,
    Closed,
    Resolved
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Repositories/IInquiriesRepository.cs">
using TicketFlow.Services.Inquiries.Core.Data.Models;

namespace TicketFlow.Services.Inquiries.Core.Data.Repositories;

public interface IInquiriesRepository
{
    Task<IEnumerable<Inquiry>> GetByEmailAsync(string email, CancellationToken cancellationToken = default);
    Task<Inquiry?> GetAsync(Guid id, CancellationToken cancellationToken = default);
    Task AddAsync(Inquiry inquiry, CancellationToken cancellationToken = default);
    Task UpdateAsync(Inquiry inquiry, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/Repositories/InquiriesRepository.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Inquiries.Core.Data.Models;

namespace TicketFlow.Services.Inquiries.Core.Data.Repositories;

internal sealed class InquiriesRepository(InquiriesDbContext dbContext) : IInquiriesRepository
{
    public async Task<IEnumerable<Inquiry>> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
        => await dbContext.Inquiries.Where(x => x.Email == email).ToListAsync(cancellationToken);
    
    public async Task<Inquiry?> GetAsync(Guid id, CancellationToken cancellationToken = default)
        => await dbContext.Inquiries.SingleOrDefaultAsync(x => x.Id == id, cancellationToken);
    
    public async Task AddAsync(Inquiry inquiry, CancellationToken cancellationToken = default)
    {
        dbContext.Inquiries.Add(inquiry);
        await dbContext.SaveChangesAsync(cancellationToken);
    }

    public async Task UpdateAsync(Inquiry inquiry, CancellationToken cancellationToken = default)
    {
        dbContext.Update(inquiry);
        await dbContext.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Data/InquiriesDbContext.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Inquiries.Core.Data.Models;

namespace TicketFlow.Services.Inquiries.Core.Data;

public sealed class InquiriesDbContext(DbContextOptions<InquiriesDbContext> options) : DbContext(options)
{
    public DbSet<Inquiry> Inquiries { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(GetType().Assembly);
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/LanguageDetection/Extensions.cs">
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.OpenAI;

namespace TicketFlow.Services.Inquiries.Core.LanguageDetection;

public static class Extensions
{
    public static IServiceCollection AddLanguageDetection(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddOpenAi(configuration);
        services.AddSingleton<ILanguageDetector>(sp =>
        {
            var options = sp.GetRequiredService<IOptions<OpenAIOptions>>();

            return options.Value.Enabled
                ? new OpenAiLanguageDetector(sp.GetRequiredService<IChatClient>())
                : new NoopLanguageDetector();
        });

        return services;
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/LanguageDetection/ILanguageDetector.cs">
namespace TicketFlow.Services.Inquiries.Core.LanguageDetection;

public interface ILanguageDetector
{
    Task<string> GetTextLanguageCode(string text, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/LanguageDetection/NoopLanguageDetector.cs">
namespace TicketFlow.Services.Inquiries.Core.LanguageDetection;

internal sealed class NoopLanguageDetector : ILanguageDetector
{
    public Task<string> GetTextLanguageCode(string text, CancellationToken cancellationToken = default)
        => Task.FromResult("en");
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/LanguageDetection/OpenAiLanguageDetector.cs">
using Microsoft.Extensions.AI;

namespace TicketFlow.Services.Inquiries.Core.LanguageDetection;

internal sealed class OpenAiLanguageDetector(IChatClient chatClient) : ILanguageDetector
{
    public async Task<string> GetTextLanguageCode(string text, CancellationToken cancellationToken = default)
    {
        var prompt = $@"Respond only with language code that you detect. Text:'{text}'";
        var response = await chatClient.CompleteAsync(prompt, cancellationToken: cancellationToken);

        return response.Message.Text!;
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/Consuming/TicketCreated/TicketCreated.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging.Consuming.TicketCreated;

public record TicketCreated(Guid Id, Guid InquiryId, int Version) : IMessage;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/Consuming/TicketCreated/TicketCreatedHandler.cs">
using TicketFlow.Services.Inquiries.Core.Data.Repositories;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging.Consuming.TicketCreated;

public class TicketCreatedHandler(IInquiriesRepository inquiriesRepository) : IMessageHandler<TicketCreated>
{
    public async Task HandleAsync(TicketCreated message, CancellationToken cancellationToken = default)
    {
        var inquiry = await inquiriesRepository.GetAsync(message.InquiryId, cancellationToken);

        if (inquiry == null)
        {
            throw new TicketFlowException("Inquiry not found");
        }
        
        inquiry.SetRelatedTicketId(message.Id);
        await inquiriesRepository.UpdateAsync(inquiry, cancellationToken);
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/Publishing/InquirySubmitted.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging.Publishing;

public sealed record InquirySubmitted(
    Guid Id,
    string Name,
    string Email,
    string Title,
    string Description,
    string Category,
    string LanguageCode,
    DateTimeOffset CreatedAt) : IMessage;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/Publishing/RequestTranslationV1.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging.Publishing;

public sealed record RequestTranslationV1(string Text, Guid TicketId) : IMessage;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/Publishing/RequestTranslationV2.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging.Publishing;

public sealed record RequestTranslationV2(string Text, string LanguageCode, Guid ReferenceId) : IMessage;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/InquiriesConsumerService.cs">
using Microsoft.Extensions.Hosting;
using TicketFlow.Services.Inquiries.Core.Messaging.Consuming.TicketCreated;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Inquiries.Core.Messaging;

public class InquiriesConsumerService(IMessageConsumer messageConsumer, AnomalySynchronizationConfigurator anomalyConfigurator) : BackgroundService
{
    public const string TicketCreatedQueue = "inquiries-ticket-created";
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await messageConsumer
            .ConsumeMessage<TicketCreated>(
                queue: TicketCreatedQueue,
                acceptedMessageTypes: null, // Handled by binding on RMQ instead (routing-key: ticket-created)
                cancellationToken: stoppingToken);
        
        await anomalyConfigurator.ConsumeAnomalyChanges();
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Messaging/InquiriesTopologyInitializer.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.Inquiries.Core.Messaging;

public class InquiriesTopologyInitializer : TopologyInitializerBase
{
    public InquiriesTopologyInitializer(IServiceProvider serviceProvider) : base(serviceProvider)
    {}
    
    protected override async Task CreateTopologyAsync(CancellationToken stoppingToken)
    {
        await CreateAnomalySynchronizationTopology(stoppingToken);
        
        var topologyBuilder = ServiceProvider.GetService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: "tickets-exchange",
            consumerDestination: InquiriesConsumerService.TicketCreatedQueue,
            TopologyType.PublishSubscribe,
            filter: "ticket-created",
            cancellationToken: stoppingToken
        );
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Queries/InquiriesListDto.cs">
using TicketFlow.Services.Inquiries.Core.Data.Models;

namespace TicketFlow.Services.Inquiries.Core.Queries;

public record InquiriesListDto(List<InquiriesListEntryDto> Data, int TotalCount);

public record InquiriesListEntryDto(
    string Id,
    string Name,
    string Title,
    string Email,
    string Description,
    InquiryCategory Category,
    InquiryStatus Status,
    string CreatedAt,
    string? TicketId);
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Queries/ListInquiries.cs">
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Inquiries.Core.Queries;

public record ListInquiries(int Page, int Limit) : IQuery<InquiriesListDto>;
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Queries/ListInquiriesHandler.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Inquiries.Core.Data;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Inquiries.Core.Queries;

public class ListInquiriesHandler : IQueryHandler<ListInquiries, InquiriesListDto>
{
    private readonly InquiriesDbContext _dbContext;

    public ListInquiriesHandler(InquiriesDbContext dbContext)
    {
        _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
    }
    
    public async Task<InquiriesListDto> HandleAsync(ListInquiries query, CancellationToken cancellationToken = default)
    {
        var (page, limit) = query;
        if (limit > 25)
        {
            limit = 25;
        }

        var count = await _dbContext.Inquiries.CountAsync(cancellationToken);

        var data = await _dbContext.Inquiries
            .OrderByDescending(x => x.CreatedAt)
            .Skip((page - 1) * limit)
            .Take(limit)
            .ToListAsync(cancellationToken);
        

        return new InquiriesListDto(
            Data: data.Select(x => new InquiriesListEntryDto(
                x.Id.ToString(),
                x.Name,
                x.Title,
                x.Email,
                x.Description,
                x.Category,
                x.Status,
                x.CreatedAt.ToString("O"),
                x.TicketId?.ToString())
            ).ToList(),
            TotalCount: count);
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.Inquiries.Core.Data;
using TicketFlow.Services.Inquiries.Core.Data.Repositories;
using TicketFlow.Services.Inquiries.Core.LanguageDetection;
using TicketFlow.Services.Inquiries.Core.Messaging;
using TicketFlow.Services.SystemMetrics.Generator;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Deduplication;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.Inquiries.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddScoped<IInquiriesRepository, InquiriesRepository>();
        
        services
            .AddHttpClient()
            .AddSerialization()
            .AddApp(configuration)
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x
                .UseRabbitMq()
                .UseMessageConsumerConvention<DontUseConventionalTopology>()
                .UseAnomalies()
                .UseResiliency())
            .AddPostgres<InquiriesDbContext>(configuration)
            .AddLanguageDetection(configuration)
            .AddSystemMetrics(configuration)
            .AddObservability(configuration);

        services.AddHostedService<InquiriesConsumerService>();
        services.AddHostedService<InquiriesTopologyInitializer>();
        
        return services;
    }
}
</file>

<file path="src/Inquiries/TicketFlow.Services.Inquiries.Core/TicketFlow.Services.Inquiries.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\..\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
    </ItemGroup>
    
</Project>
</file>

<file path="src/Inquiries/run-migrations.sh">
dotnet ef database update --startup-project ./TicketFlow.Services.Inquiries.Api/TicketFlow.Services.Inquiries.Api.csproj --context InquiriesDbContext
</file>

<file path="src/Shared/TicketFlow.CourseUtils/FeatureFlags.cs">
namespace TicketFlow.CourseUtils;

public static class FeatureFlags
{
    public const bool UseSynchronousIntegration = false;
    public const bool UseTopicPerTypeExample = false;
    public const bool UseListenToYourselfExample = false;
    public const bool UsePartitioningExample = false;
    public const bool ExtendPartitioningExample = false;
}
</file>

<file path="src/Shared/TicketFlow.CourseUtils/TicketFlow.CourseUtils.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net8.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

</Project>
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Anomalies/AnomalyException.cs">
namespace TicketFlow.Shared.AnomalyGeneration.Anomalies;

public class AnomalyException() : Exception("Error anomaly has been generated!");
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Anomalies/ConsumerAnomalies.cs">
using TicketFlow.Shared.AnomalyGeneration.HttpApi;

namespace TicketFlow.Shared.AnomalyGeneration.Anomalies;

internal record ConsumerErrorBeforeHandlerAnomaly(string MessageType, string? StatusFilter = null) : IAnomaly
{
    public Task Run(string messageType, object? message)
    {
        if (messageType.Equals(MessageType) && message.StatusMatches(StatusFilter))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }

    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(
            ((IAnomaly)this).AnomalyName, 
            MessageType, 
            new()
            {
                { nameof(StatusFilter), StatusFilter }
            });
    }
}

internal record ConsumerErrorAfterHandlerAnomaly(string MessageType, string? StatusFilter = null) : IAnomaly
{
    public Task Run(string messageType, object? message)
    {
        if (messageType.Equals(MessageType) && message.StatusMatches(StatusFilter))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }

    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(
            ((IAnomaly)this).AnomalyName, 
            MessageType, 
            new()
            {
                { nameof(StatusFilter), StatusFilter }
            });
    }
}

internal record ConsumerDelayBeforeHandlerAnomaly(string MessageType, int DelayInMs, string? StatusFilter = null) : IAnomaly
{
    public async Task Run(string messageType, object? message)
    {
        if (messageType.Equals(MessageType) && message.StatusMatches(StatusFilter))
        {
            await Task.Delay(DelayInMs);
        }
    }

    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(
            ((IAnomaly)this).AnomalyName, 
            MessageType, 
            new()
            {
                { nameof(DelayInMs), DelayInMs.ToString() },
                { nameof(StatusFilter), StatusFilter }
            });
    }
}

internal record ConsumerDelayAfterHandlerAnomaly(string MessageType, int DelayInMs, string? StatusFilter = null) : IAnomaly
{
    public async Task Run(string messageType, object? message)
    {
        if (messageType.Equals(MessageType) && message.StatusMatches(StatusFilter))
        {
            await Task.Delay(DelayInMs);
        }
    }

    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(
            ((IAnomaly)this).AnomalyName, 
            MessageType, 
            new()
            {
                { nameof(DelayInMs), DelayInMs.ToString() },
                { nameof(StatusFilter), StatusFilter }
            });
    }
}

internal static class MessageStatusChecker
{
    public static bool StatusMatches(this object? obj, string? expectedValue)
    {
        if (obj is null || string.IsNullOrWhiteSpace(expectedValue))
        {
            return true; // No filtering to be done
        }
        
        var statusProp = obj.GetType().GetProperty("Status");
        if (statusProp is null)
        {
            return true; // No filtering to be done either
        }
        
        var statusValue = statusProp.GetValue(obj);
        
        return (statusValue?.ToString() ?? "").Equals(expectedValue, StringComparison.OrdinalIgnoreCase);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Anomalies/IAnomaly.cs">
using TicketFlow.Shared.AnomalyGeneration.HttpApi;

namespace TicketFlow.Shared.AnomalyGeneration.Anomalies;

internal interface IAnomaly
{
    Task Run(string messageType, object? message);
    
    string MessageType { get; }

    public string AnomalyName
    {
        get
        {
            return GetType().Name.Replace("Anomaly", string.Empty);            
        }
    }
    AnomalyDescription Describe();
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Anomalies/OutboxAnomalies.cs">
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;

namespace TicketFlow.Shared.AnomalyGeneration.Anomalies;

internal record OutboxErrorOnSaveAnomaly(string MessageType) : IAnomaly
{
    public Task Run(string messageType, object message)
    {
        if (messageType.Equals(MessageType))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }

    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(((IAnomaly)this).AnomalyName, MessageType, new());
    }
}

internal record OutboxErrorOnPublishAnomaly(string MessageType) : IAnomaly
{
    public Task Run(string messageType, object message)
    {
        if (messageType.Equals(MessageType))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }
    
    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(((IAnomaly)this).AnomalyName, MessageType, new());
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Anomalies/ProducerAnomalies.cs">
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;

namespace TicketFlow.Shared.AnomalyGeneration.Anomalies;

internal record ProducerErrorBeforeTransactionAnomaly(string MessageType) : IAnomaly
{
    public Task Run(string messageType, object message)
    {
        if (messageType.Equals(MessageType))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }
    
    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(((IAnomaly)this).AnomalyName, MessageType, new());
    }
}

internal record ProducerErrorWithinTransactionAnomaly(string MessageType) : IAnomaly
{
    public Task Run(string messageType, object message)
    {
        if (messageType.Equals(MessageType))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }
    
    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(((IAnomaly)this).AnomalyName, MessageType, new());
    }
}

internal record ProducerErrorAfterTransactionAnomaly(string MessageType) : IAnomaly
{
    public Task Run(string messageType, object message)
    {
        if (messageType.Equals(MessageType))
        {
            throw new AnomalyException();   
        }
        
        return Task.CompletedTask;
    }
    
    public AnomalyDescription Describe()
    {
        return new AnomalyDescription(((IAnomaly)this).AnomalyName, MessageType, new());
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/AnomalyContext.cs">
namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

public class AnomalyContextAccessor
{
    private readonly AsyncLocal<AnomalyContext> _context = new();
    
    public AnomalyContext? Get()
        => _context.Value;

    public AnomalyContext InitializeIfEmpty()
    {
        if (_context.Value is not null)
        {
            return _context.Value;
        }
        
        var ctx = new AnomalyContext(new());
        _context.Value = ctx;
        
        return ctx;
    }
}

public record AnomalyContext(HashSet<string> DetectedMessageTypes);
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/AnomalyExecutionSteps.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

internal sealed class AnomalyBeforeExecutionSteps(
    IProducerAnomalyGenerator anomalies,
    AnomalyContextAccessor contextAccessor) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.BeforeTransaction;

    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default)
    {
        foreach (var messageType in contextAccessor.Get()?.DetectedMessageTypes ?? [])
        {
            await anomalies.GenerateOnProduceAsync(messageType, ExecutionType.BeforeTransaction);   
        }
        await next();
    }
}

internal sealed class AnomalyWithinTransactionExecutionStep(
    IProducerAnomalyGenerator anomalies,
    AnomalyContextAccessor contextAccessor) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.WithinTransaction;

    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default)
    {
        foreach (var messageType in contextAccessor.Get()?.DetectedMessageTypes ?? [])
        {
            await anomalies.GenerateOnProduceAsync(messageType, ExecutionType.WithinTransaction);   
        }
        await next();
    }
}

internal sealed class AnomalyAfterExecutionStep(
    IProducerAnomalyGenerator anomalies,
    AnomalyContextAccessor contextAccessor) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.AfterTransaction;

    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default)
    {
        foreach (var messageType in contextAccessor.Get()?.DetectedMessageTypes ?? [])
        {
            await anomalies.GenerateOnProduceAsync(messageType, ExecutionType.AfterTransaction);   
        }
        await next();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/IConsumerAnomalyGenerator.cs">
namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

public interface IConsumerAnomalyGenerator
{
    Task GenerateBeforeHandlerAsync<TMessage>(TMessage message);
    Task GenerateAfterHandlerAsync<TMessage>(TMessage message);
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/IOutboxAnomalyGenerator.cs">
using TicketFlow.Shared.Messaging.Outbox;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

public interface IOutboxAnomalyGenerator
{
    Task GenerateOnSaveAsync(OutboxMessage message);
    Task GenerateOnPublishAsync(OutboxMessage message);
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/IProducerAnomalyGenerator.cs">
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

public interface IProducerAnomalyGenerator
{
    Task GenerateOnProduceAsync(string messageType, ExecutionType when);
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/MessageHandlerAnomalyDecorator.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

internal sealed class MessageHandlerAnomalyDecorator<TMessage>(
    IMessageHandler<TMessage> messageHandler,
    IConsumerAnomalyGenerator anomalies) 
    : IMessageHandler<TMessage> where TMessage : class, IMessage
{
    public async Task HandleAsync(TMessage message, CancellationToken cancellationToken = default)
    {
        await anomalies.GenerateBeforeHandlerAsync(message);
        await messageHandler.HandleAsync(message, cancellationToken);
        await anomalies.GenerateAfterHandlerAsync(message);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/MessageOutboxAnomalyDecorator.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

internal sealed class MessageOutboxAnomalyDecorator(
    IMessageOutbox messageOutbox,
    IOutboxAnomalyGenerator anomalies,
    ISerializer serializer,
    AnomalyContextAccessor contextAccessor) : IMessageOutbox
{
    public Task<IReadOnlyList<OutboxMessage>> GetUnsentAsync(int batchSize = default, CancellationToken cancellationToken = default)
        => messageOutbox.GetUnsentAsync(batchSize, cancellationToken);

    public async Task AddAsync<TMessage>(TMessage message, string messageId, string? destination = default, string? routingKey = default,
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : IMessage
    {
        await messageOutbox.AddAsync(message, messageId, destination, routingKey, headers, cancellationToken);

        contextAccessor.InitializeIfEmpty();
        contextAccessor.Get().DetectedMessageTypes.Add(MessageTypeName.CreateFor<TMessage>());
        
        var outboxMessage = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            MessageId = messageId,
            Destination = destination,
            RoutingKey = routingKey,
            Headers = headers ?? new Dictionary<string, object>(),
            MessageType = message.GetType().AssemblyQualifiedName,
            Message = message,
            SerializedMessage = serializer.Serialize(message),
            StoredAt = DateTimeOffset.UtcNow
        };
        
        await anomalies.GenerateOnSaveAsync(outboxMessage);
    }

    public Task MarkAsProcessedAsync(OutboxMessage outboxMessage, CancellationToken cancellationToken = default)
        => messageOutbox.MarkAsProcessedAsync(outboxMessage, cancellationToken);
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/CodeApi/MessagePublisherAnomalyDecorator.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.AnomalyGeneration.CodeApi;

internal sealed class MessagePublisherAnomalyDecorator(
    IMessagePublisher messagePublisher, 
    IOutboxAnomalyGenerator anomalies, 
    ISerializer serializer,
    AnomalyContextAccessor contextAccessor) : IMessagePublisher
{
    public async Task PublishAsync<TMessage>(TMessage message, string? destination = default, string? routingKey = default,
        string? messageId = default, IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : class, IMessage
    {
        contextAccessor.InitializeIfEmpty();
        contextAccessor.Get().DetectedMessageTypes.Add(MessageTypeName.CreateFor<TMessage>());
        
        var outboxMessage = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            MessageId = messageId,
            Destination = destination,
            RoutingKey = routingKey,
            Headers = headers ?? new Dictionary<string, object>(),
            MessageType = message.GetType().AssemblyQualifiedName,
            Message = message,
            SerializedMessage = serializer.Serialize(message),
            StoredAt = DateTimeOffset.UtcNow
        };
        
        await messagePublisher.PublishAsync(message, destination, routingKey, messageId, headers, cancellationToken);
        await anomalies.GenerateOnPublishAsync(outboxMessage);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/HttpApi/AnomalyDescription.cs">
namespace TicketFlow.Shared.AnomalyGeneration.HttpApi;

public record AnomalyDescription(string AnomalyType, string MessageType, Dictionary<string, string> Params);
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/HttpApi/AnomalyEndpoints.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Routing;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Shared.AnomalyGeneration.HttpApi;

public static class AnomalyEndpoints
{
    public static void UseAnomalyEndpoints(this IEndpointRouteBuilder endpoints)
    {
        endpoints.MapGet("anomalies", ([FromServices] IAnomaliesStorage anomaliesStorage) =>
        {
            var anomalies = anomaliesStorage.GetAnomalies();
            return anomalies;
        });

        endpoints.MapPost("anomalies", async (
            [FromServices] IAnomaliesStorage anomaliesStorage,
            [FromServices] IEnumerable<IMessagePublisher> publishers,
            [FromServices] IOptions<AppOptions> appOptions,
            [FromBody] EnableAnomalyRequest request) =>
        {
            anomaliesStorage.EnableAnomaly(request);
            
            // Skip outbox to reduce the noise
            var publisher = publishers.FirstOrDefault(x => !x.GetType().Name.Contains("Outbox"));
            await publisher.PublishAsync(
                message: AnomalyEnabled.FromRequest(request).Wrapped(), 
                destination: AnomalyTopologyBuilder.AnomaliesExchange,
                routingKey: appOptions.Value.AppName);
        });
        
        endpoints.MapDelete("anomalies/{anomalyType}/messages/{messageType}", async (
            [FromServices] IAnomaliesStorage anomaliesStorage, 
            [FromServices] IEnumerable<IMessagePublisher> publishers,
            [FromServices] IOptions<AppOptions> appOptions,
            [FromRoute] string anomalyType,
            [FromRoute] string messageType) =>
        {
            var anomalyParsed = Enum.Parse<AnomalyType>(anomalyType);
            anomaliesStorage.DisableAnomaly(anomalyParsed, messageType);
            
            // Skip outbox to reduce the noise
            var publisher = publishers.FirstOrDefault(x => !x.GetType().Name.Contains("Outbox"));
            await publisher.PublishAsync(
                message: new AnomalyDisabled(anomalyParsed, messageType).Wrapped(), 
                destination: AnomalyTopologyBuilder.AnomaliesExchange,
                routingKey: appOptions.Value.AppName);
        });
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/HttpApi/EnableAnomalyRequest.cs">
namespace TicketFlow.Shared.AnomalyGeneration.HttpApi;

public record EnableAnomalyRequest(AnomalyType AnomalyType, string MessageType, Dictionary<string, string> AdditionalParams);
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/HttpApi/IAnomaliesStorage.cs">
namespace TicketFlow.Shared.AnomalyGeneration.HttpApi;

public interface IAnomaliesStorage
{
    void EnableAnomaly(EnableAnomalyRequest request);

    List<AnomalyDescription> GetAnomalies();

    void DisableAnomaly(AnomalyType typeToDisable, string messageType);
    
    void ResetAllAnomalies();
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/MessagingApi/AnomalyDisabled.cs">
namespace TicketFlow.Shared.AnomalyGeneration.MessagingApi;

public record AnomalyDisabled(AnomalyType AnomalyType, string MessageType)
{
    public AnomalyEventWrapper Wrapped()
    {
        return new AnomalyEventWrapper(default, this);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/MessagingApi/AnomalyEnabled.cs">
using TicketFlow.Shared.AnomalyGeneration.HttpApi;

namespace TicketFlow.Shared.AnomalyGeneration.MessagingApi;

public record AnomalyEnabled(
    AnomalyType AnomalyType,
    string MessageType,
    Dictionary<string, string> AdditionalParams)
{
    public static AnomalyEnabled FromRequest(EnableAnomalyRequest request)
    {
        return new AnomalyEnabled(request.AnomalyType, request.MessageType, request.AdditionalParams);
    }

    public AnomalyEventWrapper Wrapped()
    {
        return new AnomalyEventWrapper(this, default);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/MessagingApi/AnomalyEventWrapper.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Shared.AnomalyGeneration.MessagingApi;

// TODO:
// This is needed due to the fact, that there only exists IMessageConsumer.ConsumeMessage<TMessage>
// In theory one could instead implement non-generic ConsumeMessage that accept mandatory delegate with (JSON + messageType) input,
// so that you can demultiplex messages on your own when consuming and route them to specific handler
public record AnomalyEventWrapper(AnomalyEnabled? Enabled, AnomalyDisabled? Disabled) : IMessage;
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/MessagingApi/AnomalySynchronizationConfigurator.cs">
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Shared.AnomalyGeneration.MessagingApi;

public class AnomalySynchronizationConfigurator(
    IAnomaliesStorage storage,
    IMessageConsumer messageConsumer,
    IOptions<AppOptions> appOptions,
    ILogger<AnomalySynchronizationConfigurator> logger)
{
    public async Task ConsumeAnomalyChanges()
    {
        await messageConsumer
            .ConsumeMessage<AnomalyEventWrapper>(
                handle: message =>
                {
                    var isAnomalyEnabled = message.Enabled is not null;
                    
                    if (isAnomalyEnabled)
                    {
                        storage.EnableAnomaly(new EnableAnomalyRequest(
                            message.Enabled!.AnomalyType, 
                            message.Enabled!.MessageType, 
                            message.Enabled!.AdditionalParams));
                    }
                    else
                    {
                        storage.DisableAnomaly(
                            message.Disabled!.AnomalyType, 
                            message.Disabled!.MessageType);
                    }
                    
                    return Task.CompletedTask;
                },
                queue: AnomalyTopologyBuilder.AnomaliesAppExclusiveQueuePrefix(appOptions.Value),
                acceptedMessageTypes: null, /* All of them */
                cancellationToken: CancellationToken.None);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/MessagingApi/AnomalyTopologyBuilder.cs">
using Microsoft.Extensions.Options;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Shared.AnomalyGeneration.MessagingApi;

public class AnomalyTopologyBuilder(ITopologyBuilder topologyBuilder, IOptions<AppOptions> appOptions)
{
    public const string AnomaliesExchange = "anomalies-sync";
    public static string AnomaliesAppExclusiveQueuePrefix(AppOptions opts) => "anomalies-sync-" + opts.AppName + "-" + opts.InstanceId;
    
    public async Task CreateTopologyAsync(CancellationToken cancellationToken)
    {
        await topologyBuilder.CreateTopologyAsync(
            AnomaliesExchange,
            AnomaliesAppExclusiveQueuePrefix(appOptions.Value),
            TopologyType.PublishSubscribe,
            filter: appOptions.Value.AppName,
            consumerCustomArgs: new Dictionary<string, object>
            {
                { "x-expires", 1000 * 60 * 1 }, // Delete queue if no one is listening after 1min
                { "x-dead-letter-exchange", "" } // No DLQ for anomaly syncs
            },
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/AnomalyGenerator.cs">
using TicketFlow.Shared.AnomalyGeneration.Anomalies;
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox;

namespace TicketFlow.Shared.AnomalyGeneration;

internal class AnomalyGenerator : IConsumerAnomalyGenerator, IProducerAnomalyGenerator, IOutboxAnomalyGenerator, IAnomaliesStorage
{
    private readonly Dictionary<AnomalyType, List<IAnomaly>> _anomalies = new();

    public AnomalyGenerator()
    {
        foreach (var enumValue in Enum.GetValues(typeof(AnomalyType)))
        {
            _anomalies.Add((AnomalyType)enumValue, new List<IAnomaly>());
        }
    }
    
    public void EnableAnomaly(EnableAnomalyRequest request)
    {
        var anomaly = MapFromRequest(request);
        if (_anomalies[request.AnomalyType]
            .Any(x => x.MessageType == anomaly.MessageType && x.AnomalyName == anomaly.AnomalyName))
        {
            return;
        }
        _anomalies[request.AnomalyType].Add(anomaly);
    }

    public List<AnomalyDescription> GetAnomalies()
    {
        return _anomalies.Values.SelectMany(x => x).Select(x => x.Describe()).ToList();
    }

    public void DisableAnomaly(AnomalyType typeToDisable, string messageType)
    {
        var anomaliesEnabled = _anomalies.TryGetValue(typeToDisable, out var anomalies);
        if (!anomaliesEnabled || anomalies is null) return;

        var anomaliesLeft = anomalies.ToList();
        foreach (var anomaly in anomalies.Where(x => x.MessageType.Equals(messageType)))
        {
            anomaliesLeft.Remove(anomaly);
        }
        
        _anomalies[typeToDisable] = anomaliesLeft;
        
    }

    public void ResetAllAnomalies()
    {
        foreach (var type in _anomalies.Keys)
        {
            _anomalies[type].Clear();
        }
    }

    public async Task GenerateBeforeHandlerAsync<TMessage>(TMessage message)
    {
        if (message is null)
        {
            return;
        }
        
        var anomaliesToRun = _anomalies[AnomalyType.ConsumerDelayBeforeHandler]
            .Concat(_anomalies[AnomalyType.ConsumerErrorBeforeHandler]);

        foreach (var anomaly in anomaliesToRun)
        {
            await anomaly.Run(message.GetType().Name, message);
        }
    }

    public async Task GenerateAfterHandlerAsync<TMessage>(TMessage message)
    {
        if (message is null)
        {
            return;
        }
        
        var anomaliesToRun = _anomalies[AnomalyType.ConsumerDelayAfterHandler]
            .Concat(_anomalies[AnomalyType.ConsumerErrorAfterHandler]);

        foreach (var anomaly in anomaliesToRun)
        {
            await anomaly.Run(message.GetType().Name, message);
        }
    }

    public async Task GenerateOnProduceAsync(string messageType, ExecutionType when)
    {
        if (string.IsNullOrEmpty(messageType))
        {
            return;
        }

        foreach (var anomaly in _anomalies[when.AsAnomalyType()])
        {
            await anomaly.Run(messageType, default);
        }
    }

    public async Task GenerateOnSaveAsync(OutboxMessage message)
    {
        if (message is null)
        {
            return;
        }

        foreach (var anomaly in _anomalies[AnomalyType.OutboxErrorOnSave])
        {
            await anomaly.Run(message.Message.GetType().Name, message.Message);
        }
    }

    public async Task GenerateOnPublishAsync(OutboxMessage message)
    {
        if (message is null)
        {
            return;
        }

        foreach (var anomaly in _anomalies[AnomalyType.OutboxErrorOnPublish])
        {
            await anomaly.Run(message.Message.GetType().Name, message.Message);
        }
    }

    private static IAnomaly MapFromRequest(EnableAnomalyRequest request)
    {
        const string delayParamName = "DelayInMs";
        var delayParamExists = request.AdditionalParams.TryGetValue(delayParamName, out var delayParam);
        var delayInMs = 1;
        var delayParseSuccess = delayParamExists && int.TryParse(delayParam, out delayInMs);
        
        const string statusFilterParamName = "StatusFilter";
        request.AdditionalParams.TryGetValue(statusFilterParamName, out var statusFilter);
        
        switch (request.AnomalyType)
        {
            case AnomalyType.ConsumerDelayBeforeHandler:
                if (delayParseSuccess is false) { throw new ArgumentNullException(delayParamName); }
                return new ConsumerDelayBeforeHandlerAnomaly(request.MessageType, delayInMs, statusFilter);
            case AnomalyType.ConsumerDelayAfterHandler:
                if (delayParseSuccess is false) { throw new ArgumentNullException(delayParamName); }
                return new ConsumerDelayAfterHandlerAnomaly(request.MessageType, delayInMs, statusFilter);
            case AnomalyType.ConsumerErrorBeforeHandler:
                return new ConsumerErrorBeforeHandlerAnomaly(request.MessageType, statusFilter);
            case AnomalyType.ConsumerErrorAfterHandler:
                return new ConsumerErrorAfterHandlerAnomaly(request.MessageType, statusFilter);
            case AnomalyType.ProducerErrorBeforeTransaction:
                return new ProducerErrorBeforeTransactionAnomaly(request.MessageType);
            case AnomalyType.ProducerErrorWithinTransaction:
                return new ProducerErrorWithinTransactionAnomaly(request.MessageType);
            case AnomalyType.ProducerErrorAfterTransaction:
                return new ProducerErrorAfterTransactionAnomaly(request.MessageType);
            case AnomalyType.OutboxErrorOnSave:
                return new OutboxErrorOnSaveAnomaly(request.MessageType);
            case AnomalyType.OutboxErrorOnPublish:
                return new OutboxErrorOnPublishAnomaly(request.MessageType);
            default:
                throw new NotImplementedException(request.AnomalyType.ToString());
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/AnomalyType.cs">
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.AnomalyGeneration;

public enum AnomalyType
{
    ConsumerErrorBeforeHandler,
    ConsumerErrorAfterHandler,
    ConsumerDelayBeforeHandler,
    ConsumerDelayAfterHandler,
    ProducerErrorBeforeTransaction,
    ProducerErrorWithinTransaction,
    ProducerErrorAfterTransaction,
    OutboxErrorOnSave,
    OutboxErrorOnPublish
}

internal static class AnomalyTypeExtensions
{
    public static AnomalyType AsAnomalyType(this ExecutionType executionType)
    {
        switch (executionType)
        {
            case ExecutionType.AfterTransaction:
                return AnomalyType.ProducerErrorAfterTransaction;
            case ExecutionType.BeforeTransaction:
                return AnomalyType.ProducerErrorBeforeTransaction;
            case ExecutionType.WithinTransaction:
                return AnomalyType.ProducerErrorWithinTransaction;
            default:
                throw new NotImplementedException(executionType.ToString());
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AnomalyGeneration/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox;

namespace TicketFlow.Shared.AnomalyGeneration;

public static class Extensions
{
    public static IMessagingRegisterer UseAnomalies(this IMessagingRegisterer registerer)
    {
        var generator = new AnomalyGenerator();
        registerer.Services.AddSingleton(generator);
        
        registerer.Services.AddSingleton<IConsumerAnomalyGenerator>(generator);
        registerer.Services.AddSingleton<IOutboxAnomalyGenerator>(generator);
        registerer.Services.AddSingleton<IProducerAnomalyGenerator>(generator);
        registerer.Services.AddSingleton<IAnomaliesStorage>(generator);
        
        registerer.Services.AddScoped<IMessageExecutionStep, AnomalyBeforeExecutionSteps>();
        registerer.Services.AddScoped<IMessageExecutionStep, AnomalyWithinTransactionExecutionStep>();
        registerer.Services.AddScoped<IMessageExecutionStep, AnomalyAfterExecutionStep>();

        registerer.Services.TryDecorate(typeof(IMessageHandler<>), typeof(MessageHandlerAnomalyDecorator<>));
        registerer.Services.TryDecorate(typeof(IMessageOutbox), typeof(MessageOutboxAnomalyDecorator));
        registerer.Services.TryDecorate(typeof(IMessagePublisher), typeof(MessagePublisherAnomalyDecorator));

        registerer.Services.AddSingleton<AnomalySynchronizationConfigurator>();
        registerer.Services.AddSingleton<AnomalyContextAccessor>();
        
        return registerer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/App/AppOptions.cs">
namespace TicketFlow.Shared.App;

public class AppOptions
{
    public string AppName { get; set; }
    public string InstanceId { get; init; } = Guid.NewGuid().ToString();
}
</file>

<file path="src/Shared/TicketFlow.Shared/App/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.App;

public static class Extensions
{
    private const string SectionName = "App";
    
    public static IServiceCollection AddApp(this IServiceCollection services, IConfiguration configuration, string sectionName = SectionName)
    {
        var section = configuration.GetSection(sectionName);
        services.Configure<AppOptions>(section);
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/AspNetCore/HttpApiExtensions.cs">
using System.Text.Json;
using System.Text.Json.Serialization;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http.Json;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.AspNetCore;

public static class HttpApiExtensions
{
    private static readonly string CorsPolicyName = "CorsPolicy";

    public static IServiceCollection AddApiForFrontendConfigured(this IServiceCollection service)
    {
        return service.AddCors(options =>
            {
                options.AddPolicy(CorsPolicyName, cors =>
                    cors.SetIsOriginAllowed(_ => true)
                        .AllowAnyMethod()
                        .AllowAnyHeader()
                        .AllowCredentials());
            })
            .Configure<JsonOptions>(opts =>
            {
                var enumConverter = new JsonStringEnumConverter();
                opts.SerializerOptions.Converters.Add(enumConverter);
                opts.SerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
            });
    }

    public static void ExposeApiForFrontend(this WebApplication app)
    {
        app.UseCors(CorsPolicyName);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Commands/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Commands;

public static class Extensions
{
    public static IServiceCollection AddCommands(this IServiceCollection services)
    {
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        services.Scan(x => x.FromAssemblies(assemblies)
            .AddClasses(c => c.AssignableTo(typeof(ICommandHandler<>)))
            .AsImplementedInterfaces()
            .WithTransientLifetime());
        
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Commands/ICommand.cs">
namespace TicketFlow.Shared.Commands;

public interface ICommand
{
}
</file>

<file path="src/Shared/TicketFlow.Shared/Commands/ICommandHandler.cs">
namespace TicketFlow.Shared.Commands;

public interface ICommandHandler<in TCommand> where TCommand : class, ICommand
{
    Task HandleAsync(TCommand command, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Data/Extensions.cs">
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Data;

public static class Extensions
{
    private const string SectionName = "Postgres";

    public static IServiceCollection AddPostgres<TDbContext>(
        this IServiceCollection services,
        IConfiguration configuration, 
        string sectionName = SectionName) where TDbContext : DbContext
    {
        var dbConnectionString = configuration.GetValue<string>($"{SectionName}:ConnectionString");
        
        services.AddDbContext<TDbContext>(x => x.UseNpgsql(dbConnectionString, 
            options => options.MigrationsAssembly(typeof(TDbContext).Assembly.GetName().Name)));
        services.AddScoped<DbContext>(sp => sp.GetRequiredService<TDbContext>());
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/DependencyInjection/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.DependencyInjection;

internal static class Extensions
{
    public static IServiceCollection ReplaceWithSingletonService<TService, TImplementation>(this IServiceCollection services) 
        where TService : class where TImplementation : class, TService
    {
        var serviceDescriptor = services.FirstOrDefault(descriptor => descriptor.ServiceType == typeof(TService));
        services.Remove(serviceDescriptor!);

        services.AddSingleton<TService, TImplementation>();
        return services;
    }
    
    public static IServiceCollection ReplaceWithTransientService<TService, TImplementation>(this IServiceCollection services) 
        where TService : class where TImplementation : class, TService
    {
        var serviceDescriptor = services.FirstOrDefault(descriptor => descriptor.ServiceType == typeof(TService));
        services.Remove(serviceDescriptor!);

        services.AddTransient<TService, TImplementation>();
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Exceptions/ExceptionMiddleware.cs">
using Microsoft.AspNetCore.Http;
using TicketFlow.Shared.Serialization;
namespace TicketFlow.Shared.Exceptions;

internal sealed class ExceptionMiddleware(ISerializer serializer) : IMiddleware
{
    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        try
        {
            await next(context);
        }
        catch (TicketFlowException ex)
        {
            var response = new BadRequestResponse(ex.Message);

            context.Response.StatusCode = 400;
            context.Response.ContentType = "application/json";
            await context.Response.WriteAsync(serializer.Serialize(response));
        }
        catch (Exception ex)
        {
            context.Response.StatusCode = 500;
        }
    }

    public sealed record BadRequestResponse(string Message);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Exceptions/Extensions.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Exceptions;

public static class Extensions
{
    public static IServiceCollection AddExceptions(this IServiceCollection services)
    {
        services.AddSingleton<ExceptionMiddleware>();
        return services;
    }
    
    public static WebApplication UseExceptions(this WebApplication app)
    {
        app.UseMiddleware<ExceptionMiddleware>();
        return app;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Exceptions/TicketFlowException.cs">
namespace TicketFlow.Shared.Exceptions;

public class TicketFlowException(string message) : Exception(message);
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/Migrations/20241116134015_Init.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Deduplication
{
    /// <inheritdoc />
    public partial class Init : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.EnsureSchema(
                name: "deduplication");

            migrationBuilder.CreateTable(
                name: "DeduplicationEntries",
                schema: "deduplication",
                columns: table => new
                {
                    MessageId = table.Column<string>(type: "text", nullable: false),
                    ProcessedAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_DeduplicationEntries", x => x.MessageId);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "DeduplicationEntries",
                schema: "deduplication");
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/Migrations/20241116134015_Init.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Shared.Messaging.Deduplication.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Deduplication
{
    [DbContext(typeof(DeduplicationDbContext))]
    [Migration("20241116134015_Init")]
    partial class Init
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("deduplication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Shared.Messaging.Deduplication.Data.DeduplicationEntry", b =>
                {
                    b.Property<string>("MessageId")
                        .HasColumnType("text");

                    b.Property<DateTimeOffset>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.HasKey("MessageId");

                    b.ToTable("DeduplicationEntries", "deduplication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/Migrations/DeduplicationDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Shared.Messaging.Deduplication.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Deduplication
{
    [DbContext(typeof(DeduplicationDbContext))]
    partial class DeduplicationDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("deduplication")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Shared.Messaging.Deduplication.Data.DeduplicationEntry", b =>
                {
                    b.Property<string>("MessageId")
                        .HasColumnType("text");

                    b.Property<DateTimeOffset>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.HasKey("MessageId");

                    b.ToTable("DeduplicationEntries", "deduplication");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/DeduplicationDbContext.cs">
using Microsoft.EntityFrameworkCore;

namespace TicketFlow.Shared.Messaging.Deduplication.Data;

public sealed class DeduplicationDbContext(DbContextOptions<DeduplicationDbContext> options) : DbContext(options)
{
    public DbSet<DeduplicationEntry> DeduplicationEntries { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.HasDefaultSchema("deduplication");
        modelBuilder.ApplyConfiguration(new DeduplicationEntryConfiguration());
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/DeduplicationEntry.cs">
namespace TicketFlow.Shared.Messaging.Deduplication.Data;

public class DeduplicationEntry
{
    public string MessageId { get; init; }
    public DateTimeOffset ProcessedAt { get; init; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/DeduplicationEntryConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace TicketFlow.Shared.Messaging.Deduplication.Data;

internal sealed class DeduplicationEntryConfiguration : IEntityTypeConfiguration<DeduplicationEntry>
{
    public void Configure(EntityTypeBuilder<DeduplicationEntry> builder)
    {
        builder.ToTable("DeduplicationEntries");
        builder.HasKey(x => x.MessageId);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/NoopDeduplicationStore.cs">
namespace TicketFlow.Shared.Messaging.Deduplication.Data;

internal sealed class NoopDeduplicationStore : IDeduplicationStore
{
    public Task<bool> ExistsAsync(string messageId, CancellationToken cancellationToken = default)
        => Task.FromResult(false);

    public Task AddEntryAsync(string messageId, CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Data/PostgresDeduplicationStore.cs">
using Microsoft.EntityFrameworkCore;

namespace TicketFlow.Shared.Messaging.Deduplication.Data;

internal sealed class PostgresDeduplicationStore(DeduplicationDbContext deduplicationDbContext) : IDeduplicationStore
{
    public Task<bool> ExistsAsync(string messageId, CancellationToken cancellationToken = default)
        => deduplicationDbContext.DeduplicationEntries.AnyAsync(x => x.MessageId == messageId, cancellationToken);

    public async Task AddEntryAsync(string messageId, CancellationToken cancellationToken = default)
    {
        var deduplicationEntry = new DeduplicationEntry { MessageId = messageId, ProcessedAt = DateTimeOffset.UtcNow };
        await deduplicationDbContext.DeduplicationEntries.AddAsync(deduplicationEntry, cancellationToken);
        await deduplicationDbContext.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/DeduplicationBeforeExecutionStep.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.Messaging.Deduplication;

internal sealed class DeduplicationBeforeExecutionStep(
    IDeduplicationStore deduplicationStore, 
    ILogger<DeduplicationBeforeExecutionStep> logger) 
    : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.BeforeTransaction;

    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken)
    {
        var messageId = messageProperties.MessageId;

        if (await deduplicationStore.ExistsAsync(messageId, cancellationToken))
        {
            throw new MessageExecutionAbortedException($"Message with id: {messageId} is already processed.");
        }

        await next();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/DeduplicationOptions.cs">
namespace TicketFlow.Shared.Messaging.Deduplication;

public class DeduplicationOptions
{
    public bool Enabled { get; set; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/DeduplicationTransactionExecutionStep.cs">
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.Messaging.Deduplication;

internal sealed class DeduplicationTransactionExecutionStep(IDeduplicationStore deduplicationStore) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.WithinTransaction;

    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken)
    {
        var messageId = messageProperties.MessageId;
        await deduplicationStore.AddEntryAsync(messageId, cancellationToken);
        await next();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Messaging.Deduplication.Data;
using TicketFlow.Shared.Messaging.Executor;

namespace TicketFlow.Shared.Messaging.Deduplication;

public static class Extensions
{
    private const string DeduplicationSection = "deduplication";

    public static IMessagingRegisterer UseDeduplication(this IMessagingRegisterer registerer, string sectionName = DeduplicationSection)
    {
        var enabled = registerer.Configuration.GetValue<bool>($"{sectionName}:enabled");
        
        if (enabled is false)
        {
            registerer.Services.AddScoped<IDeduplicationStore, NoopDeduplicationStore>();
            // Required, so that initial migration succeeds
            registerer.Services.AddPostgres<DeduplicationDbContext>(registerer.Configuration);
            return registerer;
        }
        
        var section = registerer.Configuration.GetSection(sectionName);
        registerer.Services.Configure<DeduplicationOptions>(section);
        registerer.Services.AddPostgres<DeduplicationDbContext>(registerer.Configuration);
        registerer.Services.AddScoped<IDeduplicationStore, PostgresDeduplicationStore>();
        registerer.Services.AddScoped<IMessageExecutionStep, DeduplicationBeforeExecutionStep>();
        registerer.Services.AddScoped<IMessageExecutionStep, DeduplicationTransactionExecutionStep>();
        return registerer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Deduplication/IDeduplicationStore.cs">
using TicketFlow.Shared.Messaging.Deduplication.Data;

namespace TicketFlow.Shared.Messaging.Deduplication;

public interface IDeduplicationStore
{
    Task<bool> ExistsAsync(string messageId, CancellationToken cancellationToken = default);
    Task AddEntryAsync(string messageId, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/CommandHandlerExecutorDecorator.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Shared.Messaging.Executor;

internal sealed class CommandHandlerExecutorDecorator<TCommand>(ICommandHandler<TCommand> handler, IMessageExecutor executor) 
    : ICommandHandler<TCommand> where TCommand : class, ICommand
{
    public async Task HandleAsync(TCommand command, CancellationToken cancellationToken = default)
    {
        await executor.ExecuteAsync(async () => await handler.HandleAsync(command, cancellationToken), cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/IMessageExecutionStep.cs">
namespace TicketFlow.Shared.Messaging.Executor;

internal interface IMessageExecutionStep
{
    ExecutionType Type { get; }
    Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default);
}

public enum ExecutionType
{
    BeforeTransaction,
    WithinTransaction,
    AfterTransaction,
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/IMessageExecutor.cs">
namespace TicketFlow.Shared.Messaging.Executor;

public interface IMessageExecutor
{
    Task ExecuteAsync(Func<Task> handle, CancellationToken cancellationToken);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/MessageExecutionAbortedException.cs">
namespace TicketFlow.Shared.Messaging.Executor;

internal sealed class MessageExecutionAbortedException(string message) : Exception(message);
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/MessageExecutor.cs">
using System.Diagnostics;
using System.Transactions;
using Microsoft.Extensions.Logging;
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.Observability;

namespace TicketFlow.Shared.Messaging.Executor;

internal sealed class MessageExecutor(
    IEnumerable<IMessageExecutionStep> executionSteps,
    MessagePropertiesAccessor messagePropertiesAccessor, 
    ILogger<MessageExecutor> logger,
    AnomalyContextAccessor anomalyContextAccessor) : IMessageExecutor
{
    public async Task ExecuteAsync(Func<Task> handle, CancellationToken cancellationToken)
    {
        var messageProperties = messagePropertiesAccessor.InitializeIfEmpty();
        anomalyContextAccessor.InitializeIfEmpty();
        using var activity = CreateMessagingExecutionActivity(messageProperties);

        try
        {
            await ExecuteStepsAsync(ExecutionType.BeforeTransaction, cancellationToken);

            using (var scope = BeginTransaction())
            {
                await handle();
                await ExecuteStepsAsync(ExecutionType.WithinTransaction, cancellationToken);

                scope.Complete();
                logger.LogInformation("Transactional processing of the message finished.");
            }

            await ExecuteStepsAsync(ExecutionType.AfterTransaction, cancellationToken);
        }
        catch (MessageExecutionAbortedException ex)
        {
            logger.LogWarning("Message execution aborted due to the: {Message}", ex.Message);
        }
        catch (Exception ex)
        {
            logger.LogError("Error occured during transactional processing of the message: {Error}. Rolling back.", ex.Message);
            activity?.SetStatus(ActivityStatusCode.Error, ex.Message);
            throw;
        }
    }

    private async Task ExecuteStepsAsync(ExecutionType type, CancellationToken cancellationToken)
    {
        var messageProperties = messagePropertiesAccessor.Get();
        var steps = executionSteps.Where(x => x.Type == type);

        var pipeline = () => Task.CompletedTask;

        foreach (var step in steps.Reverse())
        {
            var nextStep = pipeline;
            pipeline = () => step.ExecuteAsync(messageProperties!, nextStep, cancellationToken);
        }

        await pipeline();
    }

    private TransactionScope BeginTransaction()
    {
        var opts = new TransactionOptions
        {
            IsolationLevel = IsolationLevel.ReadCommitted,
            Timeout = TimeSpan.FromSeconds(30),
        };
        return new TransactionScope(
            TransactionScopeOption.Required,
            opts,
            TransactionScopeAsyncFlowOption.Enabled);
    }

    private Activity? CreateMessagingExecutionActivity(MessageProperties messageProperties)
    {
        var activitySource = new ActivitySource(MessagingActivitySources.MessagingPublishSourceName);
        var activity = activitySource.StartActivity($"Message Execution: {messageProperties.MessageType}", ActivityKind.Producer, Activity.Current?.Context ?? default);

        if (activity is not null)
        {
            messageProperties.Headers.TryAdd(MessagingObservabilityHeaders.TraceParent, activity.Id);
        }

        return activity;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Executor/MessageHandlerExecutorDecorator.cs">
namespace TicketFlow.Shared.Messaging.Executor;

internal sealed class MessageHandlerExecutorDecorator<TMessage>(IMessageHandler<TMessage> handler, IMessageExecutor executor) 
    : IMessageHandler<TMessage> where TMessage : class, IMessage
{
    public async Task HandleAsync(TMessage message, CancellationToken cancellationToken = default)
    {
        await executor.ExecuteAsync(async () => await handler.HandleAsync(message, cancellationToken), cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Ordering/OutOfOrderDetection/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

public static class Extensions
{
    public const string SectionName = "OutOfOrderDetection";
    
    public static IMessagingRegisterer UseOutOfOrderDetection(this IMessagingRegisterer messagingRegisterer)
    {
        var enabled = messagingRegisterer.Configuration.GetValue<bool>($"{SectionName}:Enabled");

        if (!enabled)
        {
            return messagingRegisterer;
        }
        
        messagingRegisterer.Services.TryDecorate(typeof(IMessageHandler<>), typeof(IgnoreOutOfOrderMessageDecorator<>));
        messagingRegisterer.Services.AddSingleton(provider =>
        {
            var factory = (Type t) =>
            {
                var scope = provider.CreateScope();
                return scope.ServiceProvider.GetService(t);
            };
            var logger = provider.GetService<ILogger<OutOfOrderDetector>>();
            return new OutOfOrderDetector(factory, logger!);
        });
        
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        messagingRegisterer.Services.Scan(x => x.FromAssemblies(assemblies)
            .AddClasses(c => c.AssignableTo(typeof(IGetMessageRelatedEntityVersion<>)))
            .AsImplementedInterfaces()
            .WithScopedLifetime());
        
        return messagingRegisterer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Ordering/OutOfOrderDetection/IGetMessageRelatedEntityVersion.cs">
namespace TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

public interface IGetMessageRelatedEntityVersion<TMessage> where TMessage : IVersionedMessage
{
    Task<int?> GetEntityVersionAsync(TMessage message, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Ordering/OutOfOrderDetection/IgnoreOutOfOrderMessageDecorator.cs">
using Microsoft.Extensions.Logging;

namespace TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

public class IgnoreOutOfOrderMessageDecorator<TMessage> : IMessageHandler<TMessage> where TMessage : class, IMessage
{
    private readonly IMessageHandler<TMessage> _decorated;
    private readonly OutOfOrderDetector _outOfOrderDetector;
    private readonly ILogger<IgnoreOutOfOrderMessageDecorator<TMessage>> _logger;

    public IgnoreOutOfOrderMessageDecorator(
        IMessageHandler<TMessage> decorated,
        OutOfOrderDetector outOfOrderDetector,
        ILogger<IgnoreOutOfOrderMessageDecorator<TMessage>> logger)
    {
        _decorated = decorated ?? throw new ArgumentNullException(nameof(decorated));
        _outOfOrderDetector = outOfOrderDetector;
        _logger = logger;
    }
    
    public async Task HandleAsync(TMessage message, CancellationToken cancellationToken = default)
    {
        if (typeof(IVersionedMessage).IsAssignableFrom(typeof(TMessage)) is false)
        {
            await _decorated.HandleAsync(message, cancellationToken);
            return;
        }
        
        var isOutOfOrder = await _outOfOrderDetector.Check(message);
        if (isOutOfOrder)
        {
            _logger.LogWarning($"[{DateTime.UtcNow:O}] Detected ouf of order message - skipping! Message:{Environment.NewLine} {message}");
            return;
        }
        
        await _decorated.HandleAsync(message, cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Ordering/OutOfOrderDetection/IVersionedMessage.cs">
namespace TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

public interface IVersionedMessage : IMessage
{
    int Version { get; }
    string ToHumanReadableString();
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Ordering/OutOfOrderDetection/OutOfOrderDetector.cs">
using Microsoft.Extensions.Logging;

namespace TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

public class OutOfOrderDetector
{
    private readonly Func<Type, object?> _currentVersionAccessorFactory;
    private readonly ILogger<OutOfOrderDetector> _logger;

    public OutOfOrderDetector(
        /* The only reason this is not IServiceProvider is so that you can test it easily */
        Func<Type, object?> currentVersionAccessorFactory,
        ILogger<OutOfOrderDetector> logger)
    {
        _currentVersionAccessorFactory = currentVersionAccessorFactory;
        _logger = logger;
    }
    
    public async Task<bool> Check<TMessage>(TMessage message) where TMessage : IMessage
    {
        if (message is not IVersionedMessage versionedMessage)
        {
            _logger.LogInformation("{MessageType} is not versioned, thus cannot be verified", typeof(TMessage));
            return false;
        }
        
        var currentVersion = await GetCurrentVersion(versionedMessage);

        if (currentVersion == null)
        {
            return false;
        }
        
        return currentVersion >= versionedMessage.Version;
    }

    private async Task<int?> GetCurrentVersion<TMessage>(TMessage message) where TMessage : IVersionedMessage
    {
        var getterType = typeof(IGetMessageRelatedEntityVersion<>).MakeGenericType(message.GetType());
        var getter = _currentVersionAccessorFactory(getterType);

        if (getter is null)
        {
            _logger.LogWarning("No predicate for type {MessageType} found; version will not be checked!", typeof(TMessage));
            return null;
        }
        
        return await (Task<int?>)
            getterType.GetMethod(nameof(IGetMessageRelatedEntityVersion<IVersionedMessage>.GetEntityVersionAsync))
                .Invoke(getter, new object[] { message, CancellationToken.None });
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/Migrations/20241116114642_Init.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Outbox
{
    /// <inheritdoc />
    public partial class Init : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.EnsureSchema(
                name: "outbox");

            migrationBuilder.CreateTable(
                name: "OutboxMessages",
                schema: "outbox",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    MessageId = table.Column<string>(type: "text", nullable: false),
                    SerializedMessage = table.Column<string>(type: "text", nullable: false),
                    MessageType = table.Column<string>(type: "text", nullable: false),
                    StoredAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false),
                    Destination = table.Column<string>(type: "text", nullable: true),
                    RoutingKey = table.Column<string>(type: "text", nullable: true),
                    Headers = table.Column<string>(type: "text", nullable: false),
                    ProcessedAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_OutboxMessages", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "OutboxMessages",
                schema: "outbox");
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/Migrations/20241116114642_Init.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Shared.Messaging.Outbox.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Outbox
{
    [DbContext(typeof(OutboxDbContext))]
    [Migration("20241116114642_Init")]
    partial class Init
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("outbox")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Shared.Messaging.Outbox.OutboxMessage", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Destination")
                        .HasColumnType("text");

                    b.Property<string>("Headers")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("MessageId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("MessageType")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTimeOffset?>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("RoutingKey")
                        .HasColumnType("text");

                    b.Property<string>("SerializedMessage")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTimeOffset>("StoredAt")
                        .HasColumnType("timestamp with time zone");

                    b.HasKey("Id");

                    b.ToTable("OutboxMessages", "outbox");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/Migrations/OutboxDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Shared.Messaging.Outbox.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Outbox
{
    [DbContext(typeof(OutboxDbContext))]
    partial class OutboxDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("outbox")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Shared.Messaging.Outbox.OutboxMessage", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("Destination")
                        .HasColumnType("text");

                    b.Property<string>("Headers")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("MessageId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("MessageType")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTimeOffset?>("ProcessedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("RoutingKey")
                        .HasColumnType("text");

                    b.Property<string>("SerializedMessage")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<DateTimeOffset>("StoredAt")
                        .HasColumnType("timestamp with time zone");

                    b.HasKey("Id");

                    b.ToTable("OutboxMessages", "outbox");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/OutboxDbContext.cs">
using Microsoft.EntityFrameworkCore;

namespace TicketFlow.Shared.Messaging.Outbox.Data;

public sealed class OutboxDbContext(DbContextOptions<OutboxDbContext> options) : DbContext(options)
{
    public DbSet<OutboxMessage> OutboxMessages { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.HasDefaultSchema("outbox");
        modelBuilder.ApplyConfiguration(new OutboxMessageConfiguration());
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/OutboxLocalCache.cs">
using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;

namespace TicketFlow.Shared.Messaging.Outbox.Data;

internal sealed class OutboxLocalCache(MessagePropertiesAccessor messagePropertiesAccessor, ILogger<OutboxLocalCache> logger)
{
    private readonly IDictionary<string,OutboxPendingMessages> _cache = new ConcurrentDictionary<string, OutboxPendingMessages>();

    public IReadOnlyList<OutboxMessage> GetForPublish()
    {
        var messageId = messagePropertiesAccessor.Get()?.MessageId;

        if (messageId is null)
        {
            return Array.Empty<OutboxMessage>();
        }
        
        var hasPendingMessages = _cache.TryGetValue(messageId, out var result);
        _cache.Remove(messageId);
        
        logger.LogInformation($"Outbox local cache for messageId: {messageId} returns {result!.Messages.Count} messages");
        return hasPendingMessages ? result!.Messages : Array.Empty<OutboxMessage>();
    }

    public void Initialize()
    {
        var messageId = messagePropertiesAccessor.Get()?.MessageId;

        if (messageId is null || _cache.ContainsKey(messageId))
        {
            return;
        }
        
        _cache.Add(messageId, new OutboxPendingMessages());
        logger.LogInformation($"Outbox local cache initialized for messageId: {messageId}");
    }

    public void Add(OutboxMessage message)
    {
        var messageId = messagePropertiesAccessor.Get()?.MessageId;
        
        if (messageId is null)
        {
            return;
        }
        
        _cache.TryGetValue(messageId, out var result);
        result!.Messages.Add(message);
    }
    
    private class OutboxPendingMessages
    {
        public List<OutboxMessage> Messages { get; } = new();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/OutboxMessageConfiguration.cs">
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace TicketFlow.Shared.Messaging.Outbox.Data;

internal sealed class OutboxMessageConfiguration : IEntityTypeConfiguration<OutboxMessage>
{
    private static readonly JsonSerializerOptions SerializerOptions = new()
    {
        PropertyNameCaseInsensitive = true
    };
    
    public void Configure(EntityTypeBuilder<OutboxMessage> builder)
    {
        builder.ToTable("OutboxMessages");
        builder.HasKey(x => x.Id);
        builder.Property(x => x.SerializedMessage).IsRequired();
        builder.Property(x => x.Headers)
            .HasConversion(x => JsonSerializer.Serialize(x, SerializerOptions),
                x => JsonSerializer.Deserialize<IDictionary<string, object>>(x, SerializerOptions),
                new ValueComparer<IDictionary<string, object>>(
                    (c1, c2) => c1.SequenceEqual(c2),
                    c => c.Aggregate(0, (a, v) => HashCode.Combine(a, v.GetHashCode())),
                    c => c.ToDictionary(x => x.Key, x => x.Value)));

        builder.Property(x => x.StoredAt).IsRequired();
        builder.Ignore(x => x.Message);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Data/PostgresMessageOutbox.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.Messaging.Outbox.Data;

internal sealed class PostgresMessageOutbox(OutboxDbContext dbContext, OutboxLocalCache cache, ISerializer serializer, ILogger<PostgresMessageOutbox> logger) : IMessageOutbox
{
    public async Task AddAsync<TMessage>(TMessage message, string messageId, string? destination = default, string? routingKey = default,
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : IMessage
    {
        var outboxMessage = new OutboxMessage
        {
            Id = Guid.NewGuid(),
            MessageId = messageId,
            Destination = destination,
            RoutingKey = routingKey,
            Headers = headers ?? new Dictionary<string, object>(),
            MessageType = message.GetType().AssemblyQualifiedName,
            Message = message,
            SerializedMessage = serializer.Serialize(message),
            StoredAt = DateTimeOffset.UtcNow
        };
        
        await dbContext.OutboxMessages.AddAsync(outboxMessage, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
        
        cache.Add(outboxMessage);
        logger.LogInformation("Message with id: {MessageId} added to outbox", outboxMessage.Id);
    }

    public async Task<IReadOnlyList<OutboxMessage>> GetUnsentAsync(int batchSize = default, CancellationToken cancellationToken = default)
    {
        var sqlQuery = $"SELECT * FROM outbox.\"OutboxMessages\" WHERE \"ProcessedAt\" IS NULL ORDER BY \"StoredAt\" DESC {(batchSize > 0? $"LIMIT {batchSize}" : "")} FOR UPDATE SKIP LOCKED";
        
        return await dbContext.OutboxMessages
            .FromSqlRaw(sqlQuery)
            .ToListAsync(cancellationToken);
    }

    public async Task MarkAsProcessedAsync(OutboxMessage outboxMessage, CancellationToken cancellationToken = default)
    {
        outboxMessage.MarkAsProcessed();
        dbContext.OutboxMessages.Update(outboxMessage);
        await dbContext.SaveChangesAsync(cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox.Data;

namespace TicketFlow.Shared.Messaging.Outbox;

public static class Extensions
{
    private const string OutboxSection = "outbox";

    public static IMessagingRegisterer UseOutbox(this IMessagingRegisterer registerer, string sectionName = OutboxSection)
    {
        var enabled = registerer.Configuration.GetValue<bool>($"{sectionName}:enabled");
        
        if (enabled is false)
        {
            registerer.Services.AddPostgres<OutboxDbContext>(registerer.Configuration);
            return registerer;
        }
        
        var section = registerer.Configuration.GetSection(sectionName);
        registerer.Services.Configure<OutboxOptions>(section);
        registerer.Services.AddPostgres<OutboxDbContext>(registerer.Configuration);
        registerer.Services.AddScoped<IMessageOutbox, PostgresMessageOutbox>();
        registerer.Services.AddTransient<IMessagePublisher, OutboxMessagePublisher>();
        registerer.Services.AddHostedService<OutboxBackgroundService>();
        registerer.Services.AddSingleton<OutboxLocalCache>();
        registerer.Services.AddSingleton<OutboxPublishChannel>();
        registerer.Services.AddScoped<IMessageExecutionStep, OutboxBeforeExecutionStep>();
        registerer.Services.AddScoped<IMessageExecutionStep, OutboxAfterExecutionStep>();
        return registerer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/IMessageOutbox.cs">
namespace TicketFlow.Shared.Messaging.Outbox;

public interface IMessageOutbox
{
    Task<IReadOnlyList<OutboxMessage>> GetUnsentAsync(int batchSize = default, CancellationToken cancellationToken = default);
    Task AddAsync<TMessage>(TMessage message, string messageId, string? destination = default, string? routingKey = default, 
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : IMessage;
    Task MarkAsProcessedAsync(OutboxMessage outboxMessage, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxAfterExecutionStep.cs">
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox.Data;

namespace TicketFlow.Shared.Messaging.Outbox;

internal sealed class OutboxAfterExecutionStep(OutboxLocalCache cache, OutboxPublishChannel outboxPublishChannel, IOptions<OutboxOptions> outboxOptions, 
    ILogger<OutboxAfterExecutionStep> logger) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.AfterTransaction;
    
    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default)
    {
        if (outboxOptions.Value.PublishOnCommit)
        {
            var outboxMessages = cache.GetForPublish();
            logger.LogInformation("Publish on commit enabled. Publishing {MessagesNumber} outbox messages...", outboxMessages.Count);

            foreach (var outboxMessage in outboxMessages)
            {
                await outboxPublishChannel.PublishAsync(outboxMessage, cancellationToken);
            }
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxBackgroundService.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.AnomalyGeneration.CodeApi;
using TicketFlow.Shared.Messaging.Outbox.Data;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.Messaging.Outbox;

public class OutboxBackgroundService(IServiceProvider serviceProvider, IOptions<OutboxOptions> options,
    ILogger<OutboxBackgroundService> logger) : BackgroundService
{
    private OutboxDbContext _dbContext;
    private IMessageOutbox _messageOutbox;
    private IMessagePublisher _brokerPublisher;
    private ISerializer _serializer;
    
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        try
        {
            var scope = serviceProvider.CreateScope();
            _dbContext = scope.ServiceProvider.GetRequiredService<OutboxDbContext>();
            _messageOutbox = scope.ServiceProvider.GetRequiredService<IMessageOutbox>();
            _serializer = scope.ServiceProvider.GetRequiredService<ISerializer>();
            var publishers = scope.ServiceProvider.GetRequiredService<IEnumerable<IMessagePublisher>>();
            var outboxPublishChannel = scope.ServiceProvider.GetRequiredService<OutboxPublishChannel>();
            _brokerPublisher = publishers.FirstOrDefault(x => x.GetType() != typeof(OutboxMessagePublisher));

            ProcessOutboxChannelAsync(outboxPublishChannel, cancellationToken);
        
            while (cancellationToken.IsCancellationRequested is false)
            {
                await using var transaction = await _dbContext.Database.BeginTransactionAsync(cancellationToken);
            
                try
                {
                    var unprocessedMessages = await _messageOutbox.GetUnsentAsync(options.Value.BatchSize, cancellationToken);
                    if (unprocessedMessages.Count > 0)
                    {
                        logger.LogInformation("Found {unprocessedMessageCount} unprocessed outbox messages. Publishing...",
                            unprocessedMessages.Count);
                    }
                    foreach (var outboxMessage in unprocessedMessages)
                    {
                        await PublishOutboxMessageAsync(outboxMessage, cancellationToken);
                    }
                
                    await transaction.CommitAsync(cancellationToken);
                }
                catch(Exception ex)
                {
                    await transaction.RollbackAsync(cancellationToken);
                    Console.WriteLine("Failed to publish outbox messages.");
                }
            
                await Task.Delay(options.Value.IntervalMilliseconds, cancellationToken);
            }
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
            throw;
        }
       
    }

    private async void ProcessOutboxChannelAsync(OutboxPublishChannel outboxPublishChannel, CancellationToken cancellationToken)
    {
        await foreach (var outboxMessage in outboxPublishChannel.GetAsync(cancellationToken))
        {
            await PublishOutboxMessageAsync(outboxMessage, cancellationToken);
        }
    }

    private async Task PublishOutboxMessageAsync(OutboxMessage outboxMessage, CancellationToken cancellationToken)
    {
        var messageType = Type.GetType(outboxMessage.MessageType);
        var deserializedMessage = _serializer.Deserialize(outboxMessage.SerializedMessage, messageType);
        
        await (Task)_brokerPublisher.GetType()
            .GetMethod(nameof(IMessagePublisher.PublishAsync))
            .MakeGenericMethod(messageType)
            .Invoke(_brokerPublisher, new[] { deserializedMessage,outboxMessage.Destination,
                outboxMessage.RoutingKey, outboxMessage.MessageId, outboxMessage.Headers, cancellationToken });
        
        await _messageOutbox.MarkAsProcessedAsync(outboxMessage, cancellationToken);
        logger.LogInformation("Outbox message of type {messageType} with id {messageId} marked as processed.",
            Type.GetType(outboxMessage.MessageType).Name, outboxMessage.Id);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxBeforeExecutionStep.cs">
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox.Data;

namespace TicketFlow.Shared.Messaging.Outbox;

internal sealed class OutboxBeforeExecutionStep(OutboxLocalCache cache) : IMessageExecutionStep
{
    public ExecutionType Type => ExecutionType.BeforeTransaction;
    
    public async Task ExecuteAsync(MessageProperties messageProperties, Func<Task> next, CancellationToken cancellationToken = default)
    {
        cache.Initialize();
        await next();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxMessage.cs">
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Shared.Messaging.Outbox;

public sealed class OutboxMessage
{
    public required Guid Id { get; init; }
    public required string MessageId { get; init; }
    public required string SerializedMessage { get; init; }
    public required object Message { get; init; } 
    public required string MessageType { get; init; } 
    public required DateTimeOffset StoredAt { get; init; }

    public string? Destination { get; init; } 
    public string? RoutingKey { get; init; } 
    public IDictionary<string, object> Headers { get; init; } = new Dictionary<string, object>();
    public DateTimeOffset? ProcessedAt { get; private set; }
    
    public void MarkAsProcessed()
    {
        if (ProcessedAt is not null)
        {
            throw new TicketFlowException($"Cannot change processed datetime for outbox message.");
        }
        
        ProcessedAt = DateTimeOffset.UtcNow;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxMessagePublisher.cs">
using Microsoft.Extensions.Logging;

namespace TicketFlow.Shared.Messaging.Outbox;

internal sealed class OutboxMessagePublisher(IMessageOutbox messageOutbox, ILogger<OutboxMessagePublisher> logger, MessagePropertiesAccessor propertiesAccessor) : IMessagePublisher
{
    public async Task PublishAsync<TMessage>(TMessage message, string? destination = default,
        string? routingKey = default, string? messageId = default,
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default)
        where TMessage : class, IMessage
    {
        var messageProperties = propertiesAccessor.Get();
        var messageIdSafe = messageProperties?.MessageId ?? messageId ?? Guid.NewGuid().ToString();
        
        await messageOutbox.AddAsync(message, messageIdSafe, destination, routingKey, messageProperties?.Headers ?? headers, cancellationToken);
        logger.LogInformation($"Save message to outbox: {typeof(TMessage).Name}");
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxOptions.cs">
namespace TicketFlow.Shared.Messaging.Outbox;

public class OutboxOptions
{
    public bool Enabled { get; set; }
    public bool PublishOnCommit { get; set; }
    public int IntervalMilliseconds { get; set; } = 2_000;
    public int BatchSize { get; set; } = 1;
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Outbox/OutboxPublishChannel.cs">
using System.Threading.Channels;

namespace TicketFlow.Shared.Messaging.Outbox;

internal sealed class OutboxPublishChannel
{
    private readonly Channel<OutboxMessage> _channel = Channel.CreateUnbounded<OutboxMessage>();
    
    public ValueTask PublishAsync(OutboxMessage message, CancellationToken cancellationToken) 
        => _channel.Writer.WriteAsync(message, cancellationToken);
    
    public IAsyncEnumerable<OutboxMessage> GetAsync(CancellationToken cancellationToken) 
        => _channel.Reader.ReadAllAsync(cancellationToken);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Partitioning/IConsumerSpecificPartitioningSetup.cs">
namespace TicketFlow.Shared.Messaging.Partitioning;

public interface IConsumerSpecificPartitioningSetup
{
    List<int> PartitionNumbersToConsume { get; }
    PartitioningOptions PartitioningOptions { get; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Partitioning/IMessageWithPartitionKey.cs">
namespace TicketFlow.Shared.Messaging.Partitioning;

public interface IMessageWithPartitionKey
{
    string PartitionKey { get; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Partitioning/PartitioningOptions.cs">
namespace TicketFlow.Shared.Messaging.Partitioning;

public record PartitioningOptions(int NumberOfPartitions, bool OnlyOneActiveConsumerPerPartition)
{
    public static PartitioningOptions Default => new(NumberOfPartitions: 1, OnlyOneActiveConsumerPerPartition: false);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Partitioning/PartitionName.cs">
namespace TicketFlow.Shared.Messaging.Partitioning;

public static class PartitionName
{
    public static string ForConsumerDedicatedExchange(string targetQueueName) => $"{targetQueueName}-partitioned-exchange";
    public static string ForQueue(string queueName, int partitionNum) => $"{queueName}-partition-{partitionNum}";
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/ChannelFactory.cs">
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using TicketFlow.Shared.App;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class ChannelFactory(ConnectionProvider connectionProvider, IOptions<AppOptions> appOptions) : IDisposable
{
    private readonly ThreadLocal<IModel> _consumerCache = new(true);
    private readonly ThreadLocal<IModel> _producerCache = new(true);

    public IModel CreateForProducer() => Create(connectionProvider.ProducerConnection, _producerCache);
    
    public IModel CreateForConsumer() => Create(connectionProvider.ConsumerConnection, _consumerCache);
    
    private IModel Create(IConnection connection, ThreadLocal<IModel> cache)
    {
        if (cache.Value is not null)
        {
            return cache.Value;
        }
        
        var channel = connection.CreateModel();
        cache.Value = channel;
        return channel;
    }
    
    public void Dispose()
    {
        foreach (var channel in _consumerCache.Values)
        {
            channel.Dispose();
        }
        foreach (var channel in _producerCache.Values)
        {
            channel.Dispose();
        }
        
        _consumerCache.Dispose();
        _producerCache.Dispose();
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/ConnectionProvider.cs">
using RabbitMQ.Client;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class ConnectionProvider(IConnection consumerConnection, IConnection producerConnection)
{
    public IConnection ConsumerConnection { get; } = consumerConnection;
    public IConnection ProducerConnection { get; } = producerConnection;
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using TicketFlow.Shared.DependencyInjection;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

public static class Extensions
{
    private const string SectionName = "rabbitMq";
    
    public static IMessagingRegisterer UseRabbitMq(this IMessagingRegisterer registerer, string sectionName = SectionName)
    {
        var services = registerer.Services;
        var section = registerer.Configuration.GetSection(sectionName);
        var appName = registerer.Configuration.GetValue<string>("App:AppName");
        services.Configure<RabbitMqOptions>(section);
        
        services.AddSingleton(svc =>
        {
            var options = new RabbitMqOptions();
            section.Bind(options);
            
            var factory = new ConnectionFactory
            {
                HostName = options.HostName,
                Port = options.Port,
                UserName = options.Username,
                Password = options.Password,
                VirtualHost = options.VirtualHost
            };
        
            var consumerConnection = factory.CreateConnection($"{appName}-consumer");
            var producerConnection = factory.CreateConnection($"{appName}-producer");
            var connectionProvider = new ConnectionProvider(consumerConnection, producerConnection);
            return connectionProvider;
        });
        services.AddTransient<ChannelFactory>();

        services.AddSingleton<IMessagePublisher, RabbitMqMessagePublisher>();
        services.AddSingleton<IMessageConsumer, RabbitMqMessageConsumer>();
        services.AddSingleton<IMessageConsumerConventionProvider, RabbitMqDefaultMessageConventionProvider>();
        services.AddSingleton<IMessagePublisherConventionProvider, RabbitMqDefaultMessageConventionProvider>();
        services.AddTransient<ITopologyBuilder, RabbitMqTopologyBuilder>();
        services.AddSingleton(provider => new TopologyOptions(
            CreateTopology: provider.GetRequiredService<IOptions<RabbitMqOptions>>().Value.CreateTopology));
        services.AddHostedService<RabbitMqTopologyInitializer>();
        return registerer;
    }

    public static IMessagingRegisterer UseMessageConsumerConvention<TProvider>(this IMessagingRegisterer registerer)
        where TProvider : class, IMessageConsumerConventionProvider
        => UseConvention<IMessageConsumerConventionProvider, TProvider>(registerer);
    
    public static IMessagingRegisterer UseMessagePublisherConvention<TProvider>(this IMessagingRegisterer registerer) 
        where TProvider : class, IMessagePublisherConventionProvider
        => UseConvention<IMessagePublisherConventionProvider, TProvider>(registerer);
    
    private static IMessagingRegisterer UseConvention<TInterface, TProvider>(this IMessagingRegisterer registerer) where TProvider : class, TInterface where TInterface : class
    {
        registerer.Services.ReplaceWithSingletonService<TInterface, TProvider>();
        return registerer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqDefaultMessageConventionProvider.cs">
using Microsoft.Extensions.Options;
using TicketFlow.Shared.App;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class RabbitMqDefaultMessageConventionProvider(IOptions<AppOptions> options) 
    : IMessageConsumerConventionProvider, IMessagePublisherConventionProvider
{
    (string destination, string routingKey) IMessagePublisherConventionProvider.Get<TMessage>()
    {
        var transformedMessageName = PascalToKebabCase(typeof(TMessage).Name);
        var destination = $"{transformedMessageName}-exchange";
        return (destination, "");
    }

    (string destination, string routingKey) IMessageConsumerConventionProvider.Get<TMessage>()
    {
        var transformedMessageName = PascalToKebabCase(typeof(TMessage).Name);
        var destination = $"{transformedMessageName}-{options.Value.AppName.ToLowerInvariant()}-queue";
        return (destination, "");
    }
    
    private static string PascalToKebabCase(string str)
    {
        return string.Concat(str.SelectMany(ConvertChar));

        IEnumerable<char> ConvertChar(char c, int index)
        {
            if (char.IsUpper(c) && index != 0) yield return '-';
            yield return char.ToLower(c);
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessageConsumer.cs">
using System.Diagnostics;
using System.Text;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using TicketFlow.Shared.Messaging.Partitioning;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class RabbitMqMessageConsumer(
    ChannelFactory channelFactory,
    IMessageConsumerConventionProvider conventionProvider,
    IServiceProvider serviceProvider,
    MessagePropertiesAccessor messagePropertiesAccessor,
    ISerializer serializer,
    ILogger<RabbitMqMessageConsumer> logger,
    TopologyReadinessAccessor topologyReadinessAccessor,
    ReliableConsuming reliableConsuming,
    ResiliencyOptions resiliencyOptions) : IMessageConsumer
{
    public async Task<IMessageConsumer> ConsumeMessage<TMessage>(
        Func<TMessage, Task>? handle = default, 
        string? queue = default,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage
    {
        var channel = channelFactory.CreateForConsumer();
        ConfigureConsumerQos(channel);
        var consumer = new EventingBasicConsumer(channel);
        var (destination, _) = conventionProvider.Get<TMessage>();
        var destinationResolved = queue ?? destination;
        
        consumer.Received += async (model, ea) =>
        {
            SetMessageProperties(ea.BasicProperties, ea.Redelivered);
            using var activity = CreateMessagingConsumeActivity(ea.BasicProperties);

            if (IsNotAcceptedMessageType(acceptedMessageTypes, ea))
            {
                channel.BasicAck(ea.DeliveryTag, false); // ACK instead of NACK or REJECT to not trigger DLQ routing
                return;
            }

            try
            {
                await HandleMessageAsync(ea, handle, cancellationToken);
            }
            catch (Exception exception)
            {
                logger.LogError(exception, "An error occured while handling a message");
                Activity.Current?.SetStatus(ActivityStatusCode.Error, exception.Message);
                await OnHandleFailure<TMessage>(ea, channel, exception, destinationResolved);
                return;
            }
            
            channel.BasicAck(ea.DeliveryTag, false);
        };

        await EnsureTopologyReady(cancellationToken);
        
        channel.BasicConsume(queue: destinationResolved, autoAck: false, consumer: consumer);
        return this;
    }

    public async Task<IMessageConsumer> ConsumeNonGeneric(Func<MessageData, Task> handleRawPayload, string queue, string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default)
    {
        var channel = channelFactory.CreateForConsumer();
        ConfigureConsumerQos(channel);
        var consumer = new EventingBasicConsumer(channel);
        var destinationResolved = queue;
        
        consumer.Received += async (model, ea) =>
        {
            SetMessageProperties(ea.BasicProperties, ea.Redelivered);
            using var activity = CreateMessagingConsumeActivity(ea.BasicProperties);

            if (IsNotAcceptedMessageType(acceptedMessageTypes, ea))
            {
                channel.BasicAck(ea.DeliveryTag, false); // ACK instead of NACK or REJECT to not trigger DLQ routing
                return;
            }

            try
            {
                var messageData = CreateMessageData(ea);
                await handleRawPayload(messageData);
            }
            catch (Exception exception)
            {
                logger.LogError(exception, "An error occured while handling a message");
                Activity.Current?.SetStatus(ActivityStatusCode.Error, exception.Message);
                await OnHandleFailureNonGeneric(ea, channel, exception, destinationResolved);
                return;
            }
          
            channel.BasicAck(ea.DeliveryTag, false);
        };

        await EnsureTopologyReady(cancellationToken);
        
        channel.BasicConsume(queue: queue, autoAck: false, consumer: consumer);
        return this;
    }

    public async Task GetMessage<TMessage>(
        Func<TMessage, Task> handle,
        string? queue = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage
    {
        var channel = channelFactory.CreateForConsumer();
        var (destination, _) = conventionProvider.Get<TMessage>();

        await EnsureTopologyReady(cancellationToken);
        
        var result = channel.BasicGet(queue: queue ?? destination, autoAck: false);
        if (result is null)
        {
            return;
        }
        var message = serializer.DeserializeBinary<TMessage>(result.Body.ToArray());
        SetMessageProperties(result.BasicProperties, result.Redelivered);

        await handle(message);
        
        channel.BasicAck(result.DeliveryTag, false);
    }

    public async Task<IMessageConsumer> ConsumeMessageFromPartitions<TMessage>(
        IConsumerSpecificPartitioningSetup consumerPartitioningSetup,
        Func<TMessage, Task>? handle = default,
        string? queue = default,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage
    {
        ArgumentNullException.ThrowIfNull(consumerPartitioningSetup);

        if (consumerPartitioningSetup.PartitionNumbersToConsume.Count == 0)
        {
            throw new ArgumentOutOfRangeException(
                nameof(consumerPartitioningSetup.PartitionNumbersToConsume), 
                "At least one partition must be provided.");
        }

        if (consumerPartitioningSetup.PartitionNumbersToConsume.Any(x => x < 1 || x > consumerPartitioningSetup.PartitioningOptions.NumberOfPartitions))
        {
            throw new ArgumentOutOfRangeException(
                nameof(consumerPartitioningSetup.PartitionNumbersToConsume), 
                $"Consumed partitions must be in range 1-{consumerPartitioningSetup.PartitioningOptions.NumberOfPartitions}!");
        }

        foreach (var partition in consumerPartitioningSetup.PartitionNumbersToConsume.Distinct())
        {
            var partitionQueue = PartitionName.ForQueue(queue, partition);
            await ConsumeMessage(handle, partitionQueue, acceptedMessageTypes, cancellationToken);
        }

        return this;
    }

    public async Task<IMessageConsumer> ConsumeNonGenericFromPartitions(
        IConsumerSpecificPartitioningSetup consumerPartitioningSetup,
        Func<MessageData, Task> handleRawPayload, 
        string? queue, 
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(consumerPartitioningSetup);

        if (consumerPartitioningSetup.PartitionNumbersToConsume.Count == 0)
        {
            throw new ArgumentOutOfRangeException(
                nameof(consumerPartitioningSetup.PartitionNumbersToConsume), 
                "At least one partition must be provided.");
        }

        if (consumerPartitioningSetup.PartitionNumbersToConsume.Any(x => x < 1 || x > consumerPartitioningSetup.PartitioningOptions.NumberOfPartitions))
        {
            throw new ArgumentOutOfRangeException(
                nameof(consumerPartitioningSetup.PartitionNumbersToConsume), 
                $"Consumed partitions must be in range 1-{consumerPartitioningSetup.PartitioningOptions.NumberOfPartitions}!");
        }

        foreach (var partition in consumerPartitioningSetup.PartitionNumbersToConsume.Distinct())
        {
            var partitionQueue = PartitionName.ForQueue(queue, partition);
            await ConsumeNonGeneric(handleRawPayload, partitionQueue, acceptedMessageTypes, cancellationToken);
        }

        return this;
    }

    private async Task HandleMessageAsync<TMessage>(BasicDeliverEventArgs ea, Func<TMessage, Task>? handle = default, 
        CancellationToken cancellationToken = default) where TMessage : class, IMessage
    {
        var message = serializer.DeserializeBinary<TMessage>(ea.Body.ToArray());

        logger.LogWarning($"[{DateTime.UtcNow:O}] Received message:{Environment.NewLine} {message}");
        
        if (handle is null)
        {
            var scope = serviceProvider.CreateScope();
            var messageHandler = scope.ServiceProvider.GetRequiredService<IMessageHandler<TMessage>>();

            await messageHandler.HandleAsync(message, cancellationToken);
        }
        else
        {
            await handle(message);
        }
        
        logger.LogWarning($"[{DateTime.UtcNow:O}] Processed message:{Environment.NewLine} {message}");
    }
    
    private async Task OnHandleFailure<TMessage>(BasicDeliverEventArgs ea, IModel channel, Exception exception,
            string destinationResolved) where TMessage : class, IMessage
    {
        var messageId = GetMessageId(ea.BasicProperties);
        reliableConsuming.OnConsumeFailed(messageId);
                
        if (reliableConsuming.CanBrokerRetry(messageId))
        {
            // Let broker handle the retry
            logger.LogWarning("Consume failed for messageId: {messageId}; will retry via broker", messageId);
            channel.BasicNack(ea.DeliveryTag, false, requeue: true);
        }
        else
        {
            // Retries exhausted - say goodbye to the message
            logger.LogError("Broker retries limit exhausted for messageId: {messageId}", messageId);
            channel.BasicReject(ea.DeliveryTag, false);
                    
            var message = serializer.DeserializeBinary<TMessage>(ea.Body.ToArray());
            SetMessageProperties(ea.BasicProperties, ea.Redelivered);
            await reliableConsuming.OnBrokerRetriesExhausted(message, exception, destinationResolved);
        }
    }
    
    private async Task OnHandleFailureNonGeneric(BasicDeliverEventArgs ea, IModel channel, Exception exception,
        string destinationResolved)
    {
        var messageId = GetMessageId(ea.BasicProperties);
        reliableConsuming.OnConsumeFailed(messageId);
                
        if (reliableConsuming.CanBrokerRetry(messageId))
        {
            // Let broker handle the retry
            logger.LogWarning("Consume failed for messageId: {messageId}; will retry via broker", messageId);
            channel.BasicNack(ea.DeliveryTag, false, requeue: true);
        }
        else
        {
            // Retries exhausted - say goodbye to the message
            logger.LogError("Broker retries limit exhausted for messageId: {messageId}", messageId);
            channel.BasicReject(ea.DeliveryTag, false);
                    
            var message = serializer.DeserializeBinary<string>(ea.Body.ToArray());
            SetMessageProperties(ea.BasicProperties);
            await reliableConsuming.OnBrokerRetriesExhaustedNonGeneric(message, exception, destinationResolved);
        }
    }
    
    private static bool IsNotAcceptedMessageType(string[]? acceptedMessageTypes, BasicDeliverEventArgs ea)
    {
            return acceptedMessageTypes is not null && !acceptedMessageTypes.Contains(ea.BasicProperties.Type);
        }

    private void SetMessageProperties(IBasicProperties props, bool redelivered = false)
    {
        var messageId = props.MessageId;
        var headers = props.Headers?
            .Select(x => (x.Key, (object)Encoding.UTF8.GetString((byte[]) x.Value))).ToDictionary();
        var messageType = props.Type;
        var messageProperties = new MessageProperties(messageId, headers, messageType, redelivered);
        messagePropertiesAccessor.Set(messageProperties);
    }

    private MessageData CreateMessageData(BasicDeliverEventArgs ea)
    {
        var messageId = GetMessageId(ea.BasicProperties);
        var messageType = ea.BasicProperties.Type;
        var payload = ea.Body.ToArray();
        
        return new MessageData(messageId, payload, messageType);
    }

    /// <summary>
    /// Build children span due to the -> https://github.com/jaegertracing/jaeger/issues/4516
    /// </summary>
    private Activity? CreateMessagingConsumeActivity(IBasicProperties props)
    {
        var isHeaderPresent = props.Headers?.ContainsKey(MessagingObservabilityHeaders.TraceParent) ?? false;

        if (isHeaderPresent is false)
        {
            return Activity.Current;
        }
        
        var traceIdBytes = props.Headers[MessagingObservabilityHeaders.TraceParent];
        var traceId = Encoding.UTF8.GetString((byte[]) traceIdBytes);
        var activitySource = new ActivitySource(MessagingActivitySources.MessagingConsumeSourceName);
        var parentContext = ActivityContext.Parse(traceId, default);
        return activitySource.StartActivity(
            $"Messaging Consume: {messagePropertiesAccessor.Get()?.MessageType}", 
            kind: ActivityKind.Consumer, 
            parentContext: parentContext,
            links: [new ActivityLink(parentContext)]);
    }

    private static Guid GetMessageId(IBasicProperties props)
    {
        var messageId = props.MessageId;
        return Guid.Parse(messageId);
    }

    private void ConfigureConsumerQos(IModel channel)
    {
        if (resiliencyOptions.Consumer.MaxMessagesFetchedPerConsumer > 0)
        {
            channel.BasicQos(
                prefetchSize: 0, 
                prefetchCount: (ushort)resiliencyOptions.Consumer.MaxMessagesFetchedPerConsumer, 
                global: false);
        }
        
    }
    
    private async Task EnsureTopologyReady(CancellationToken cancellationToken)
    {
        while (topologyReadinessAccessor.TopologyProvisioned is false)
        {
            logger.LogInformation("Waiting for topology to be provisioned...");
            await Task.Delay(1000, cancellationToken);
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqMessagePublisher.cs">
using RabbitMQ.Client;
using TicketFlow.CourseUtils;
using TicketFlow.Shared.Messaging.Partitioning;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class RabbitMqMessagePublisher(ChannelFactory channelFactory, IMessagePublisherConventionProvider conventionProvider, 
    ISerializer serializer, MessagePropertiesAccessor propertiesAccessor, ReliablePublishing reliablePublishing) : IMessagePublisher
{
    public async Task PublishAsync<TMessage>(TMessage message, string? destination = default, string? routingKey = default, string? messageId = default,
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : class,IMessage
    {
        var channel = channelFactory.CreateForProducer();
        var payload = serializer.SerializeBinary(message);
        var properties = CreateMessageProperties<TMessage>(channel, messageId, headers);
        SetPartitionKey(properties, message);
        
        var (conventionDestination, conventionRoutingKey) = conventionProvider.Get<TMessage>();
        
        ConfigureReliablePublishing<TMessage>(channel, messageId);
        
        channel.BasicPublish(
            exchange: destination ?? conventionDestination,
            routingKey: routingKey ?? conventionRoutingKey,
            basicProperties: properties,
            body: payload,
            mandatory: reliablePublishing.ShouldPublishAsMandatory<TMessage>());

        EnsureReliablePublish(channel);
            
        await Task.CompletedTask;
    }

    private IBasicProperties CreateMessageProperties<TMessage>(IModel channel, string?  messageId = default, IDictionary<string, object>? headers = default)
        where TMessage : class,IMessage
    {
        var messageProperties = propertiesAccessor.Get();
        var basicProperties = channel.CreateBasicProperties();

        basicProperties.MessageId = messageId ?? Guid.NewGuid().ToString();
        basicProperties.Type = MessageTypeName.CreateFor<TMessage>();
        basicProperties.DeliveryMode = 2;
        basicProperties.Headers = new Dictionary<string, object>();
        
        var headersToAdd = headers 
                           ?? messageProperties?.Headers 
                           ?? Enumerable.Empty<KeyValuePair<string, object>>();

        foreach (var header in headersToAdd)
        {
            basicProperties.Headers.Add(header.Key, header.Value.ToString());
        }
        
        return basicProperties;
    }

    private void ConfigureReliablePublishing<TMessage>(IModel channel, string? messageId)
    {
        if (reliablePublishing.UsePublisherConfirms)
        {
            channel.ConfirmSelect();
        }

        if (reliablePublishing.ShouldPublishAsMandatory<TMessage>())
        {
            channel.BasicReturn += (s, args) =>
            {
                Console.WriteLine($"Message {typeof(TMessage).Name}, id: {messageId} was not routed properly to any consumer!)");
            };
        }
    }
    
    private void EnsureReliablePublish(IModel channel)
    {
        if (reliablePublishing.UsePublisherConfirms)
        {
            try
            {
                channel.WaitForConfirmsOrDie();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex);
                throw;
            }
        }
    }

    private void SetPartitionKey<TMessage>(IBasicProperties basicProperties, TMessage? message)
    {
        if (FeatureFlags.UsePartitioningExample is false)
        {
            return;
        }

        if (typeof(IMessageWithPartitionKey).IsAssignableFrom(typeof(TMessage)))
        {
            var partitionKey = (message as IMessageWithPartitionKey)?.PartitionKey;
            basicProperties.Headers.Add(RabbitMqTopologyBuilder.PartitionKeyHeaderName, partitionKey);
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqOptions.cs">
namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class RabbitMqOptions
{
    public string HostName { get; set; }
    public int Port { get; set; }
    public string Username { get; set; }
    public string Password { get; set; }
    public string VirtualHost { get; set; } = "/";
    public bool CreateTopology { get; set; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqTopologyBuilder.cs">
using Microsoft.Extensions.Logging;
using RabbitMQ.Client;
using TicketFlow.Shared.Messaging.Partitioning;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal class RabbitMqTopologyBuilder(ChannelFactory channelFactory, ResiliencyOptions resiliencyOptions, ILogger<RabbitMqTopologyBuilder> logger) : ITopologyBuilder
{
    public const string PartitionKeyHeaderName = "hash-on";

    public Task CreateTopologyAsync(
        string publisherSource,
        string consumerDestination,
        TopologyType topologyType,
        string filter = "",
        Dictionary<string, object>? consumerCustomArgs = default,
        PartitioningOptions? partitioningOptions = default,
        CancellationToken cancellationToken = default)
    {
        var channel = channelFactory.CreateForConsumer();

        consumerCustomArgs ??= new Dictionary<string, object>();
        
        ConfigureDeadletter(consumerDestination, consumerCustomArgs, channel);
        
        switch (topologyType)
        {
            case TopologyType.Direct:
                CreateDirect(publisherSource, consumerDestination, filter, consumerCustomArgs, channel);
                break;
            case TopologyType.PublishSubscribe:
                if (partitioningOptions == null)
                {
                    CreatePubSub(publisherSource, consumerDestination, filter, consumerCustomArgs, channel);
                }
                else
                {
                    CreatePubSubWithPartitioning(publisherSource, consumerDestination, filter, consumerCustomArgs, channel, partitioningOptions);
                }
                break;
            case TopologyType.PublisherToPublisher:
                CreatePubToPub(publisherSource, consumerDestination, filter, channel);
                break;
            default:
                throw new NotImplementedException($"{nameof(topologyType)} is not supported!");
        }

        return Task.CompletedTask;
    }

    private void ConfigureDeadletter(string consumerDestination, Dictionary<string, object> consumerCustomArgs, IModel channel)
    {
        var dlqDeclaredByCaller = consumerCustomArgs.TryGetValue("x-dead-letter-exchange", out var dlqDeclared);
        var dlqExchange = dlqDeclared?.ToString();
        
        if (dlqDeclaredByCaller is false && resiliencyOptions.Consumer.UseDeadletter)
        {
            dlqExchange = consumerDestination + "-dlq-exchange";
            consumerCustomArgs.Add("x-dead-letter-exchange", dlqExchange);
        }

        // (Override) Caller explicitly set DLQ to be empty -> no DLQ
        if (dlqDeclaredByCaller && dlqExchange!.Equals(string.Empty))
        {
            consumerCustomArgs.Remove("x-dead-letter-exchange");
            return;
        }

        if (resiliencyOptions.Consumer.UseDeadletter && !string.IsNullOrEmpty(consumerDestination))
        {
            var dlqQueue = consumerDestination + "-dlq";
            CreatePubSub(dlqExchange, dlqQueue, "", null!, channel);
        }
    }

    private void CreateDirect(
        string publisherSource,
        string consumerDestination,
        string filter,
        Dictionary<string, object> consumerCustomArgs,
        IModel channel)
    {
        if (!string.IsNullOrEmpty(publisherSource))
        {
            logger.LogInformation($"Declaring exchange of name {publisherSource}");
            channel.ExchangeDeclare(publisherSource, ExchangeType.Direct, durable: true);
        }
        else
        {
            logger.LogInformation("Skipping publisher and binding due to direct publish to queue");
        }

        logger.LogInformation($"Declaring queue of name {consumerDestination}");
        channel.QueueDeclare(consumerDestination, durable: true, exclusive: false, autoDelete: false, consumerCustomArgs);

        if (!string.IsNullOrEmpty(publisherSource))
        {
            channel.QueueBind(queue: consumerDestination, exchange: publisherSource, routingKey: filter);
        }
    }

    private void CreatePubSub(
        string publisherSource,
        string consumerDestination,
        string filter,
        Dictionary<string, object> consumerCustomArgs,
        IModel channel)
    {
        logger.LogInformation($"Declaring exchange of name {publisherSource}");
        channel.ExchangeDeclare(publisherSource, ExchangeType.Topic, durable: true);

        if (string.IsNullOrEmpty(consumerDestination))
        {
            logger.LogInformation($"In {nameof(TopologyType.PublishSubscribe)} publisher is consumer-ignorant; skipping consumer creation and binding...");
            return;
        }
        
        logger.LogInformation($"Declaring queue of name {consumerDestination}");
        channel.QueueDeclare(consumerDestination, durable: true, exclusive: false, autoDelete: false, consumerCustomArgs);
        
        channel.QueueBind(queue: consumerDestination, exchange: publisherSource, 
            routingKey: string.IsNullOrEmpty(filter) 
                ? "#"       // Broadcast like fanout
                : filter    // custom filter pattern with substitute chars ('#' or '*')
        );
    }

    private void CreatePubSubWithPartitioning(
        string publisherSource,
        string consumerDestination,
        string filter,
        Dictionary<string, object> consumerCustomArgs,
        IModel channel,
        PartitioningOptions? partitioningOptions = default)
    {
        logger.LogInformation($"Declaring exchange of name {publisherSource}");
        channel.ExchangeDeclare(publisherSource, ExchangeType.Topic, durable: true);

        if (string.IsNullOrEmpty(consumerDestination))
        {
            logger.LogInformation($"In {nameof(TopologyType.PublishSubscribe)} publisher is consumer-ignorant; skipping consumer creation and binding...");
            return;
        }
        
        logger.LogInformation($"Requested partitioned topology for {consumerDestination}");
        var partitionedExchange = PartitionName.ForConsumerDedicatedExchange(consumerDestination);
        logger.LogInformation($"Declaring dedicated exchange for consumer with name {consumerDestination}");
        CreatePubToPub(publisherSource, partitionedExchange, filter, channel, forPartitioning: true);

        var consumerCustomArgsForPartitioning = new Dictionary<string, object>(consumerCustomArgs);
        consumerCustomArgsForPartitioning.Add("x-single-active-consumer", partitioningOptions.OnlyOneActiveConsumerPerPartition);
            
        logger.LogInformation($"Requested {partitioningOptions.NumberOfPartitions} partitions for {consumerDestination}");
            
        foreach (var partitionNum in Enumerable.Range(1, partitioningOptions.NumberOfPartitions))
        {
            var partitionedQueueName = PartitionName.ForQueue(consumerDestination, partitionNum);
            logger.LogInformation($"Declaring queue of name {partitionedQueueName}");
                
            channel.QueueDeclare(partitionedQueueName, durable: true, exclusive: false, autoDelete: false, consumerCustomArgsForPartitioning);
            
            channel.QueueBind(queue: partitionedQueueName, exchange: partitionedExchange, 
                routingKey: "1" /* Let's assume that each consumer has same weight, so they get partitions split evenly */
            );
        }
    }

    private void CreatePubToPub(string publisherSource, string consumerDestination, string filter, IModel channel, bool forPartitioning = false)
    {
        logger.LogInformation($"Declaring exchange of name {publisherSource}");
        channel.ExchangeDeclare(publisherSource, ExchangeType.Topic, durable: true);
            
        logger.LogInformation($"Declaring exchange of name {consumerDestination}");
        if (!forPartitioning)
        {
            channel.ExchangeDeclare(consumerDestination, ExchangeType.Topic, durable: true);
        }
        else
        {
            channel.ExchangeDeclare(
                consumerDestination,
                "x-consistent-hash",
                durable: true,
                arguments: new Dictionary<string, object>
                {
                    {
                        "hash-header", PartitionKeyHeaderName
                    }
                });
        }

        channel.ExchangeBind(source: publisherSource, destination: consumerDestination, routingKey: string.IsNullOrEmpty(filter) 
                ? "#"       // Broadcast like fanout
                : filter    // custom filter pattern with substitute chars ('#' or '*')
        );
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/RabbitMQ/RabbitMqTopologyInitializer.cs">
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RabbitMQ.Client;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Shared.Messaging.RabbitMQ;

internal sealed class RabbitMqTopologyInitializer : BackgroundService
{
    private readonly ITopologyBuilder _topologyBuilder;
    private readonly IOptions<RabbitMqOptions> _options;
    private readonly IMessageConsumerConventionProvider _messageConventionProvider;
    private readonly ILogger<RabbitMqTopologyInitializer> _logger;
    private readonly TopologyReadinessAccessor _topologyReadinessAccessor;

    public RabbitMqTopologyInitializer(
        ITopologyBuilder topologyBuilder, 
        IOptions<RabbitMqOptions> options,
        IMessageConsumerConventionProvider messageConventionProvider,
        ILogger<RabbitMqTopologyInitializer> logger,
        TopologyReadinessAccessor topologyReadinessAccessor)
    {
        _topologyBuilder = topologyBuilder;
        _options = options;
        _messageConventionProvider = messageConventionProvider;
        _logger = logger;
        _topologyReadinessAccessor = topologyReadinessAccessor;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (_options.Value.CreateTopology is false)
        {
            _logger.LogInformation("RabbitMq topology creation disabled");
            return;
        }
        if (_messageConventionProvider is not RabbitMqDefaultMessageConventionProvider)
        {
            _logger.LogInformation("RabbitMq topology not set due to custom convention provider.");
            return;
        }

        var messageTypes = AppDomain.CurrentDomain
            .GetAssemblies()
            .SelectMany(x => x.GetTypes())
            .Where(x => x is {IsClass: true, IsAbstract: false} && typeof(IMessage).IsAssignableFrom(x))
            .Where(x => x.Namespace.Contains("Consuming"));

        _topologyReadinessAccessor.MarkTopologyProvisioningStart(GetType().Name);
        
        foreach (var messageType in messageTypes)
        {
            var (publisherDestination, _) = ((string, string)) typeof(IMessagePublisherConventionProvider)
                .GetMethod(nameof(IMessagePublisherConventionProvider.Get))
                .MakeGenericMethod(messageType)
                .Invoke(_messageConventionProvider, null);
            
            var (consumerDestination, _) = ((string, string)) typeof(IMessageConsumerConventionProvider)
                .GetMethod(nameof(IMessageConsumerConventionProvider.Get))
                .MakeGenericMethod(messageType)
                .Invoke(_messageConventionProvider, null);

            await _topologyBuilder.CreateTopologyAsync(publisherDestination, consumerDestination, TopologyType.Direct);
        }
        
        _topologyReadinessAccessor.MarkTopologyProvisioningEnd(GetType().Name);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Messaging.Resiliency;

public static class Extensions
{
    private static ResiliencyOptions DefaultOpts = new ResiliencyOptions(
        new ConsumerResiliencyOptions(
            BrokerRetriesEnabled: false,
            BrokerRetriesLimit: 3,
            ConsumerRetriesEnabled: false,
            ConsumerRetriesLimit: 3,
            UseDeadletter: false,
            PublishFaultOnFailure: false,
            MaxMessagesFetchedPerConsumer: 5),
        new ProducerResiliencyOptions(PublisherConfirmsEnabled: false, PublishMandatoryEnabled: false));

    public static IMessagingRegisterer UseResiliency(this IMessagingRegisterer registerer)
    {
        var services = registerer.Services;
        var configuration = registerer.Configuration;

        ResiliencyOptions options = DefaultOpts;

        var section = configuration.GetSection("Resiliency");
        if (section.Exists())
        {
            section.Bind(options, opts => { opts.BindNonPublicProperties = true; });
        }
        
        services.AddSingleton(options);
        services.AddSingleton<ReliablePublishing>();
        services.AddSingleton<ReliableConsuming>();

        if (options.Consumer.ConsumerRetriesEnabled)
        {
            registerer.Services.TryDecorate(typeof(IMessageHandler<>), typeof(MessageHandlerRetryDecorator<>));
        }

        return registerer;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/Fault.cs">
namespace TicketFlow.Shared.Messaging.Resiliency;

public record Fault<TMessage>(
    TMessage FaultedMessage,
    string ExceptionType,
    string ExceptionMessage,
    string FailedOnQueue) : IMessage;
    
public record Fault(
    string FaultedMessage,
    string ExceptionType,
    string ExceptionMessage,
    string FailedOnQueue) : IMessage;
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/INonMandatoryMessage.cs">
namespace TicketFlow.Shared.Messaging.Resiliency;

// Marker interface
public interface INonMandatoryMessage : IMessage {}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/MessageHandlerRetryDecorator.cs">
using Microsoft.Extensions.Logging;
using Polly;
using Polly.Retry;

namespace TicketFlow.Shared.Messaging.Resiliency;

internal sealed class MessageHandlerRetryDecorator<TMessage> : IMessageHandler<TMessage> where TMessage : class, IMessage
{
    private readonly RetryStrategyOptions _options;

    private readonly IMessageHandler<TMessage> _messageHandler;

    public MessageHandlerRetryDecorator(
        IMessageHandler<TMessage> messageHandler,
        ResiliencyOptions resiliencyOptions,
        ILogger<MessageHandlerRetryDecorator<TMessage>> logger)
    {
        _messageHandler = messageHandler;
        _options = new()
        {
            Delay = TimeSpan.FromSeconds(1),
            MaxRetryAttempts = resiliencyOptions.Consumer.ConsumerRetriesLimit,
            OnRetry = _ =>
            {
                if (_.AttemptNumber < resiliencyOptions.Consumer.ConsumerRetriesLimit - 1)
                {
                    logger.LogWarning("Consume failed - will retry via consumer (client-side)");
                }
                else
                {
                    logger.LogError("Consumer retries limit exhausted");
                }
                return ValueTask.CompletedTask;
            }
        };
    }

    public async Task HandleAsync(TMessage message, CancellationToken cancellationToken = default)
    {
        var retryPolicy = new ResiliencePipelineBuilder()
            .AddRetry(_options)
            .Build();

        await retryPolicy.ExecuteAsync(async ct => await _messageHandler.HandleAsync(message, ct), cancellationToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/ReliableConsuming.cs">
using System.Collections.Concurrent;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Messaging.Resiliency;

public class ReliableConsuming
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ConcurrentDictionary<Guid, int> _messageIdAttemptsMade = new();
    private readonly bool _enabled;
    private readonly int _maxRetries;
    private readonly bool _produceFaults;

    public ReliableConsuming(ResiliencyOptions options, IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
        _maxRetries = options.Consumer.BrokerRetriesLimit;
        _enabled = options.Consumer.BrokerRetriesEnabled;
        _produceFaults = options.Consumer.PublishFaultOnFailure;
    }

    public bool CanBrokerRetry(Guid messageId)
    {
        if (_enabled is false)
        {
            return true;
        }
        
        if (!_messageIdAttemptsMade.TryGetValue(messageId, out int consumeAttempts))
        {
            _messageIdAttemptsMade.TryAdd(messageId, 0);
            consumeAttempts = 0;
        }
        
        return consumeAttempts < _maxRetries + 1;
    }

    public void OnConsumeFailed(Guid messageId)
    {
        if (_enabled is false)
        {
            return;
        }
        
        if (!_messageIdAttemptsMade.TryGetValue(messageId, out int consumeAttempts))
        {
            _messageIdAttemptsMade.TryAdd(messageId, 0);
            consumeAttempts = 0;
        }
        
        _messageIdAttemptsMade.TryUpdate(messageId, consumeAttempts + 1, consumeAttempts);
    }

    public async Task OnBrokerRetriesExhausted<TMessage>(TMessage message, Exception exception, string failedQueue)
    {
        if (_produceFaults is false)
        {
            return;
        }
        
        var faultMessage = new Fault<TMessage>
        (
            message,
            exception.GetType().Name,
            exception.Message,
            failedQueue
        );

        var iocScope = _serviceProvider.CreateScope();
        var publisher = iocScope.ServiceProvider.GetService(typeof(IMessagePublisher)) as IMessagePublisher;
        
        await publisher!.PublishAsync(faultMessage);
    }
    
    public async Task OnBrokerRetriesExhaustedNonGeneric(string message, Exception exception, string failedQueue)
    {
        if (_produceFaults is false)
        {
            return;
        }
        
        var faultMessage = new Fault
        (
            message,
            exception.GetType().Name,
            exception.Message,
            failedQueue
        );

        var iocScope = _serviceProvider.CreateScope();
        var publisher = iocScope.ServiceProvider.GetService(typeof(IMessagePublisher)) as IMessagePublisher;
        
        await publisher!.PublishAsync(faultMessage);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/ReliablePublishing.cs">
namespace TicketFlow.Shared.Messaging.Resiliency;

internal class ReliablePublishing(ResiliencyOptions options)
{
    public bool UsePublisherConfirms => options.Producer.PublisherConfirmsEnabled;

    public bool ShouldPublishAsMandatory<TMessage>()
    {
        if (options.Producer.PublishMandatoryEnabled is false)
        {
            return false;
        }
        
        if (typeof(INonMandatoryMessage).IsAssignableFrom(typeof(TMessage)))
        {
            return false;
        }

        return true;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Resiliency/ResiliencyOptions.cs">
namespace TicketFlow.Shared.Messaging.Resiliency;

public class ResiliencyOptions
{
    public ResiliencyOptions(ConsumerResiliencyOptions consumer, ProducerResiliencyOptions producer)
    {
        Consumer = consumer;
        Producer = producer;
    }

    public ConsumerResiliencyOptions Consumer { get; private set; }
    public ProducerResiliencyOptions Producer { get; private set; }
}

public record ConsumerResiliencyOptions(
    bool BrokerRetriesEnabled,
    int BrokerRetriesLimit,
    bool ConsumerRetriesEnabled,
    int ConsumerRetriesLimit,
    bool UseDeadletter,
    bool PublishFaultOnFailure,
    int MaxMessagesFetchedPerConsumer);
    
public record ProducerResiliencyOptions(bool PublisherConfirmsEnabled, bool PublishMandatoryEnabled);
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Topology/DontUseConventionalTopology.cs">
namespace TicketFlow.Shared.Messaging.Topology;

public class DontUseConventionalTopology : IMessageConsumerConventionProvider
{
    public (string destination, string routingKey) Get<TMessage>() where TMessage : class, IMessage
    {
        return (default, default);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Topology/ITopologyBuilder.cs">
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Shared.Messaging.Topology;

public interface ITopologyBuilder
{
    Task CreateTopologyAsync(
        string publisherSource,
        string consumerDestination,
        TopologyType topologyType,
        string filter = "",
        Dictionary<string, object>? consumerCustomArgs = default,
        PartitioningOptions? partitioningOptions = default,
        CancellationToken cancellationToken = default);
}

public enum TopologyType
{
    Direct,
    PublishSubscribe,
    PublisherToPublisher
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Topology/TopologyInitializerBase.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;

namespace TicketFlow.Shared.Messaging.Topology;

public abstract class TopologyInitializerBase : BackgroundService
{
    protected readonly IServiceProvider ServiceProvider;
    private readonly TopologyReadinessAccessor _topologyReadinessAccessor;
    private readonly TopologyOptions _topologyOptions;
    

    public TopologyInitializerBase(IServiceProvider serviceProvider)
    {
        ServiceProvider = serviceProvider;
        
        _topologyReadinessAccessor = ServiceProvider.GetService<TopologyReadinessAccessor>();
        _topologyReadinessAccessor.MarkTopologyProvisioningStart(GetType().Name);
        
        _topologyOptions = ServiceProvider.GetService<TopologyOptions>();
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        if (_topologyOptions.CreateTopology)
        {
            await CreateTopologyAsync(stoppingToken);
        }
        else
        {
            await CreateAnomalySynchronizationTopology(stoppingToken);
        }
        
        _topologyReadinessAccessor.MarkTopologyProvisioningEnd(GetType().Name);
        
    }
    
    protected abstract Task CreateTopologyAsync(CancellationToken stoppingToken);
    
    protected async Task CreateAnomalySynchronizationTopology(CancellationToken stoppingToken)
    {
        var anomalyTopologyBuilder = new AnomalyTopologyBuilder(
            ServiceProvider.GetService<ITopologyBuilder>(),
            ServiceProvider.GetService<IOptions<AppOptions>>());

        await anomalyTopologyBuilder.CreateTopologyAsync(stoppingToken);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Topology/TopologyOptions.cs">
namespace TicketFlow.Shared.Messaging.Topology;

public record TopologyOptions(bool CreateTopology);
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Topology/TopologyReadinessAccessor.cs">
namespace TicketFlow.Shared.Messaging.Topology;

public class TopologyReadinessAccessor(TopologyOptions topologyOptions)
{
    private Dictionary<string, bool> _readinessMap = new();

    public void MarkTopologyProvisioningStart(string source)
    {
        _readinessMap.Add(source, false);
    }

    public void MarkTopologyProvisioningEnd(string source)
    {
        _readinessMap[source] = true;
    }
    
    public bool TopologyProvisioned
    {
        get
        {
            return topologyOptions.CreateTopology is false || _readinessMap.Values.All(x => x);
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Messaging.Executor;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Shared.Messaging;

public static class Extensions
{
    public static IServiceCollection AddMessaging(this IServiceCollection services, IConfiguration configuration,
        Action<IMessagingRegisterer> register)
    {
        var registerer = new MessagingRegisterer(services, configuration);

        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        services.Scan(x => x.FromAssemblies(assemblies)
            .AddClasses(c => c.AssignableTo(typeof(IMessageHandler<>)))
            .AsImplementedInterfaces()
            .WithTransientLifetime());
        
        register(registerer); //Required here because otherwise won't find IMessageHandler<> to decorate

        services.AddSingleton<MessagePropertiesAccessor>();
        services.AddSingleton<TopologyReadinessAccessor>();
        registerer.Services.AddScoped<IMessageExecutor, MessageExecutor>();
        registerer.Services.TryDecorate(typeof(ICommandHandler<>), typeof(CommandHandlerExecutorDecorator<>));
        registerer.Services.TryDecorate(typeof(IMessageHandler<>), typeof(MessageHandlerExecutorDecorator<>));
        
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessage.cs">
namespace TicketFlow.Shared.Messaging;

// Marker interface
public interface IMessage
{
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessageConsumer.cs">
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Shared.Messaging;

public interface IMessageConsumer
{
    Task<IMessageConsumer> ConsumeMessage<TMessage>(
        Func<TMessage, Task>? handle = default,
        string? queue = default,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage;
    
    Task<IMessageConsumer> ConsumeNonGeneric(
        Func<MessageData, Task> handleRawPayload,
        string queue,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default);

    
    Task GetMessage<TMessage>(
        Func<TMessage, Task> handle,
        string? queue = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage;

    Task<IMessageConsumer> ConsumeMessageFromPartitions<TMessage>(
        IConsumerSpecificPartitioningSetup consumerPartitioningSetup,
        Func<TMessage, Task>? handle = default,
        string? queue = default,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default) where TMessage : class, IMessage;

    Task<IMessageConsumer> ConsumeNonGenericFromPartitions(
        IConsumerSpecificPartitioningSetup consumerPartitioningSetup,
        Func<MessageData, Task> handleRawPayload,
        string? queue,
        string[]? acceptedMessageTypes = default,
        CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessageConventionProvider.cs">
namespace TicketFlow.Shared.Messaging;

public interface IMessagePublisherConventionProvider
{
    (string destination, string routingKey) Get<TMessage>() where TMessage : class, IMessage;
}

public interface IMessageConsumerConventionProvider
{
    (string destination, string routingKey) Get<TMessage>() where TMessage : class, IMessage;
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessageHandler.cs">
namespace TicketFlow.Shared.Messaging;

public interface IMessageHandler<in TMessage> where TMessage : class, IMessage
{
    Task HandleAsync(TMessage message, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessagePublisher.cs">
namespace TicketFlow.Shared.Messaging;

public interface IMessagePublisher
{
    Task PublishAsync<TMessage>(TMessage message, string? destination = default, string? routingKey = default, string? messageId = default,
        IDictionary<string, object>? headers = default, CancellationToken cancellationToken = default) where TMessage : class, IMessage;
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/IMessagingRegisterer.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Messaging;

public interface IMessagingRegisterer
{
    internal IServiceCollection Services { get; }
    internal IConfiguration Configuration { get; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/MessageData.cs">
namespace TicketFlow.Shared.Messaging;

public record MessageData(Guid MessageId, byte[] Payload, string Type) : IMessage;
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/MessagePropertiesAccessor.cs">
namespace TicketFlow.Shared.Messaging;

internal sealed class MessagePropertiesAccessor
{
    private readonly AsyncLocal<MessageProperties> _messageProperties = new();
    
    public MessageProperties? Get()
        => _messageProperties.Value;

    public MessageProperties InitializeIfEmpty()
    {
        if (_messageProperties.Value is not null)
        {
            return _messageProperties.Value;
        }
        
        var messageProperties = new MessageProperties(Guid.NewGuid().ToString(), new Dictionary<string, object>(), string.Empty, false);
        _messageProperties.Value = messageProperties;
        
        return messageProperties;
    }
    
    public void Set(MessageProperties messageProperties)
        => _messageProperties.Value = messageProperties;
}

public record MessageProperties(string MessageId, IDictionary<string, object> Headers, string MessageType, bool Redelivered);
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/MessageTypeName.cs">
using TicketFlow.Shared.Messaging.Resiliency;

namespace TicketFlow.Shared.Messaging;

public static class MessageTypeName
{
    public static string CreateFor<TMessage>() where TMessage : IMessage
    {
        var messageType = typeof(TMessage);
        
        if (messageType.IsGenericType && messageType.GetGenericTypeDefinition() == typeof(Fault<>))
        {
            var wrappedMessageType = messageType.GetGenericArguments()[0];
            return "Fault." + wrappedMessageType.Name;
        }
        return messageType.Name;
    }
    
}
</file>

<file path="src/Shared/TicketFlow.Shared/Messaging/MessagingRegisterer.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Messaging;

internal sealed record MessagingRegisterer(IServiceCollection Services, IConfiguration Configuration) : IMessagingRegisterer;
</file>

<file path="src/Shared/TicketFlow.Shared/Observability/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using OpenTelemetry.Resources;
using OpenTelemetry.Trace;

namespace TicketFlow.Shared.Observability;

public static class Extensions
{
    private const string ObservabilitySection = "observability";

    public static IServiceCollection AddObservability(this IServiceCollection services, IConfiguration configuration, string sectionName = ObservabilitySection)
    {
        var serviceName = configuration.GetValue<string>("App:AppName");
        var enabled = configuration.GetValue<bool>($"{sectionName}:enabled");

        if (enabled is false)
        {
            return services;
        }
        
        var section = configuration.GetSection(sectionName);
        services.Configure<ObservabilityOptions>(section);
        var endpoint = configuration.GetValue<string>($"{sectionName}:endpoint");

        services.AddOpenTelemetry().WithTracing(x =>
        {
            x
            .SetResourceBuilder(
                ResourceBuilder.CreateDefault()
                   .AddService(serviceName))
            .AddSource(
                MessagingActivitySources.MessagingPublishSourceName, 
                MessagingActivitySources.MessagingConsumeSourceName)
            .AddAspNetCoreInstrumentation()
            .AddHttpClientInstrumentation()
            .AddOtlpExporter(options =>
            {
                options.Endpoint = new Uri(endpoint);
            });
        });
        
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Observability/MessagingActivitySources.cs">
namespace TicketFlow.Shared.Observability;

internal static class MessagingActivitySources
{
    public const string MessagingPublishSourceName = "Messaging Publish";
    public const string  MessagingConsumeSourceName= "Messaging Consume";
}
</file>

<file path="src/Shared/TicketFlow.Shared/Observability/MessagingObservabilityHeaders.cs">
namespace TicketFlow.Shared.Observability;

public static class MessagingObservabilityHeaders
{
    public const string TraceParent = "traceparent";
    public const string TraceState = "tracestate";
}
</file>

<file path="src/Shared/TicketFlow.Shared/Observability/ObservabilityOptions.cs">
namespace TicketFlow.Shared.Observability;

public sealed class ObservabilityOptions
{
    public bool Enabled {get; set; }
    public string Endpoint {get; set; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/OpenAI/Extensions.cs">
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using OpenAI;

namespace TicketFlow.Shared.OpenAI;

public static class Extensions
{
    private const string SectionName = "OpenAI";
    
    public static IServiceCollection AddOpenAi(this IServiceCollection services, IConfiguration configuration, string sectionName = SectionName)
    {
        services.Configure<OpenAIOptions>(configuration.GetSection(sectionName));
        services.AddSingleton(sp =>
        {
            var options = sp.GetRequiredService<IOptions<OpenAIOptions>>();
            return new OpenAIClient(options.Value.ApiKey).AsChatClient(modelId: "gpt-4o-mini");
        });
        
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/OpenAI/OpenAIOptions.cs">
namespace TicketFlow.Shared.OpenAI;

public class OpenAIOptions
{
    public bool Enabled { get; set; }
    public string ApiKey { get; set; }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Queries/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Queries;

public static class Extensions
{
    public static IServiceCollection AddQueries(this IServiceCollection services)
    {
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();
        services.Scan(x => x.FromAssemblies(assemblies)
            .AddClasses(c => c.AssignableTo(typeof(IQueryHandler<,>)))
            .AsImplementedInterfaces()
            .WithTransientLifetime());
        
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Queries/IQuery.cs">
namespace TicketFlow.Shared.Queries;

public interface IQuery<TResult> where TResult : class
{
}
</file>

<file path="src/Shared/TicketFlow.Shared/Queries/IQueryHandler.cs">
namespace TicketFlow.Shared.Queries;

public interface IQueryHandler<in TQuery, TResult> where TQuery : IQuery<TResult> where TResult : class
{
    Task<TResult> HandleAsync(TQuery query, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Serialization/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Shared.Serialization;

public static class Extensions
{
    public static IServiceCollection AddSerialization(this IServiceCollection services)
    {
        services.AddSingleton<ISerializer, JsonSerializer>();
        return services;
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Serialization/ISerializer.cs">
namespace TicketFlow.Shared.Serialization;

public interface ISerializer
{
    string Serialize(object obj);
    TObject? Deserialize<TObject>(string json);
    object Deserialize(string json, Type obj);
    byte[] SerializeBinary(object @object);
    TObject? DeserializeBinary<TObject>(byte[] objectBytes);
}
</file>

<file path="src/Shared/TicketFlow.Shared/Serialization/JsonSerializer.cs">
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TicketFlow.Shared.Serialization;

internal sealed class JsonSerializer : ISerializer
{
    public string Serialize(object obj)
        => System.Text.Json.JsonSerializer.Serialize(obj, SerializationOptions.Default);

    public TObject? Deserialize<TObject>(string json)
        => System.Text.Json.JsonSerializer.Deserialize<TObject>(json, SerializationOptions.Default);

    public object Deserialize(string json, Type obj)
       => System.Text.Json.JsonSerializer.Deserialize(json, obj, SerializationOptions.Default)!;

    public byte[] SerializeBinary(object @object)
    {
        var json = System.Text.Json.JsonSerializer.Serialize(@object, SerializationOptions.Default);
        return Encoding.UTF8.GetBytes(json);
    }

    public TObject? DeserializeBinary<TObject>(byte[] objectBytes)
    {
        var json = Encoding.UTF8.GetString(objectBytes);
        return System.Text.Json.JsonSerializer.Deserialize<TObject>(json, SerializationOptions.Default);
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/Serialization/SerializationOptions.cs">
using System.Text.Json;
using System.Text.Json.Serialization;

namespace TicketFlow.Shared.Serialization;

public static class SerializationOptions
{
    public static readonly JsonSerializerOptions Default = new(JsonSerializerOptions.Default)
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        Converters =
        {
            new JsonStringEnumConverter()
        }
    };
}
</file>

<file path="src/Shared/TicketFlow.Shared/Testing/MessagingIntegrationTestProvider.cs">
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using RabbitMQ.Client;
using RabbitMQ.Client.Events;
using Testcontainers.RabbitMq;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Shared.Testing;

public sealed class MessagingIntegrationTestProvider<TProgram> : IAsyncDisposable where TProgram : class
{
    public RabbitMqContainer RabbitMqContainer { get; }
    public WebApplicationFactory<TProgram> Factory;
    
    private IConnection _rabbitConnection;
    private IModel _rabbitChannel;
    private readonly JsonSerializer _jsonSerializer = new();

    public MessagingIntegrationTestProvider(Action<IServiceCollection> configureServices)
    {
        RabbitMqContainer = new RabbitMqBuilder()
            .WithImage("rabbitmq:3-management-alpine")
            .WithName("rabbitmq-integration-test")
            .WithUsername("guest")
            .WithPassword("guest")
            .WithPortBinding(5672, assignRandomHostPort: true)
            .Build();
        
        Factory = new WebApplicationFactory<TProgram>()
            .WithWebHostBuilder(builder =>
            {
                builder
                    .ConfigureAppConfiguration((_, config) =>
                    {
                        config.AddInMemoryCollection(new[]
                        {
                            new KeyValuePair<string, string>("rabbitMq:hostName", RabbitMqContainer.Hostname),
                            new KeyValuePair<string, string>("rabbitMq:port", RabbitMqContainer.GetMappedPublicPort(5672).ToString()),
                            new KeyValuePair<string, string>("rabbitMq:username", "guest"),
                            new KeyValuePair<string, string>("rabbitMq:password", "guest"),
                            new KeyValuePair<string, string>("rabbitMq:createTopology", "false")
                        }!);
                    })
                    .ConfigureServices(services => configureServices(services));
            });
    }

    public void Initialize(Action<IModel> provisionTopology)
    {
        var factory = new ConnectionFactory
        {
            HostName = RabbitMqContainer.Hostname,
            Port = RabbitMqContainer.GetMappedPublicPort(5672)
        };

        _rabbitConnection = factory.CreateConnection();
        _rabbitChannel = _rabbitConnection.CreateModel();

        provisionTopology(_rabbitChannel);
    }

    public void Publish<TMessage>(TMessage message, string exchange, string routingKey) where TMessage : class, IMessage
    {
        var payload = _jsonSerializer.SerializeBinary(message);
        _rabbitChannel.BasicPublish(exchange: exchange, routingKey: routingKey, basicProperties: null, body: payload);
    }
    
    public async Task<TMessage> ConsumeMessagesAsync<TMessage>(string queueName, int maxDelay = 1_000) where TMessage : IMessage
    {
        var taskCompletionSource = new TaskCompletionSource<TMessage>();
        var consumer = new EventingBasicConsumer(_rabbitChannel);

        consumer.Received += (_, ea) =>
        {
            var body = ea.Body.ToArray();
            var message = _jsonSerializer.DeserializeBinary<TMessage>(body);
            taskCompletionSource.SetResult(message);
        };

        _rabbitChannel.BasicConsume(queue: queueName, autoAck: true, consumer: consumer);

        await Task.WhenAny(taskCompletionSource.Task, Task.Delay(maxDelay).ContinueWith(_ => taskCompletionSource.SetResult(default)));
        return taskCompletionSource.Task.Result;
    }

    public async ValueTask DisposeAsync()
    {
        await Factory.DisposeAsync();
        await CastAndDispose(_rabbitConnection);
        await CastAndDispose(_rabbitChannel);
        await RabbitMqContainer.DisposeAsync();

        return;

        static async ValueTask CastAndDispose(IDisposable resource)
        {
            if (resource is IAsyncDisposable resourceAsyncDisposable)
                await resourceAsyncDisposable.DisposeAsync();
            else
                resource.Dispose();
        }
    }
}
</file>

<file path="src/Shared/TicketFlow.Shared/TicketFlow.Shared.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.Extensions.Configuration" Version="9.0.0" />
        <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="9.0.0" />
        <PackageReference Include="Microsoft.Extensions.Hosting.Abstractions" Version="9.0.0" />
        <PackageReference Include="Microsoft.Extensions.Logging" Version="9.0.0" />
        <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="9.0.0" />
        <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="9.0.2" />
        <PackageReference Include="OpenTelemetry" Version="1.10.0" />
        <PackageReference Include="OpenTelemetry.Exporter.OpenTelemetryProtocol" Version="1.10.0" />
        <PackageReference Include="OpenTelemetry.Extensions.Hosting" Version="1.10.0" />
        <PackageReference Include="OpenTelemetry.Instrumentation.AspNetCore" Version="1.10.1" />
        <PackageReference Include="OpenTelemetry.Instrumentation.Http" Version="1.10.0" />
        <PackageReference Include="Polly.Core" Version="8.5.0" />
        <PackageReference Include="RabbitMQ.Client" Version="6.8.1" /> 
        <PackageReference Include="Scrutor" Version="5.0.3" />
        <PackageReference Include="Microsoft.Extensions.AI.OpenAI" Version="9.0.1-preview.1.24570.5" />
        <PackageReference Include="Testcontainers.RabbitMq" Version="4.1.0" />
        <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
    </ItemGroup>

    <ItemGroup>
        <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.CourseUtils\TicketFlow.CourseUtils.csproj" />
    </ItemGroup>
</Project>
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:25852",
      "sslPort": 44356
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5054",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7235;http://localhost:5054",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning",
      "TicketFlow": "Warning",
      "System.Net": "Warning"
    }
  },
  "App": {
    "AppName" : "sla-service"
  },
  "Deduplication": {
    "Enabled": false
  },
  "Observability" : {
    "Enabled" : false,
    "Endpoint" : "http://localhost:4317"
  },
  "Outbox": {
    "Enabled": false,
    "PublishOnCommit" : true,
    "IntervalMilliseconds" : 3000,
    "BatchSize": 1
  },
  "Postgres": {
    "ConnectionString": "Host=localhost;Database=TicketFlow.SLA;Username=postgres;Password="
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Services": {
    "Tickets": "http://localhost:5112",
    "Communication": "http://localhost:5148"
  },
  "Metrics": {
    "Enabled": false
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 1
    },
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  },
  "OutOfOrderDetection": {
    "Enabled": false
  },
  "Partitioning": {
    "TicketChanges": {
      "NumberOfPartitions": 3
    }
  }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/get-deadlines.http">
@ticketId = e54758ed-ec86-46d3-abe3-9ea5d4c99122
@ticketType = QuestionTicket

GET http://localhost:5054/sla/{{ticketType}}/{{ticketId}}/deadline-reminders
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/Program.cs">
using Microsoft.AspNetCore.Mvc;
using TicketFlow.Services.SLA.Core;
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Services.SLA.Core.Data.Repositories;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AspNetCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddCore(builder.Configuration)
    .AddApiForFrontendConfigured();

var app = builder.Build();

app.MapGet("/sla/{serviceType}/{serviceSourceId}/deadline-reminders", async (
    [FromRoute] string serviceType,
    [FromRoute] string serviceSourceId,
    [FromServices] ISLARepository repository,
    CancellationToken cancellationToken) =>
{
    var parseSuccess = Enum.TryParse<ServiceType>(serviceType, out var serviceTypeParsed);
    if (parseSuccess is false)
    {
        return Results.BadRequest("Invalid service type");
    }
    
    var result = await repository.GetRemindersFor(serviceTypeParsed, serviceSourceId, cancellationToken);

    if (result is null)
    {
        return Results.NotFound("Service not found");
    }
    
    return Results.Ok(result);
});

app.ExposeApiForFrontend();
app.UseAnomalyEndpoints();

app.Run();
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
    
    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.SLA.Core\TicketFlow.Services.SLA.Core.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Configurations/DeadlineReminderConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data.Configurations;

public class DeadlineReminderConfiguration : IEntityTypeConfiguration<DeadlineReminders>
{

    public void Configure(EntityTypeBuilder<DeadlineReminders> builder)
    {
        builder.HasKey(x => x.Id);

        builder.Property(x => x.ServiceType).IsRequired();
        builder.Property(x => x.ServiceSourceId).IsRequired();
        builder.Property(x => x.UserIdToRemind);
        builder.Property(x => x.FirstReminderDateUtc);
        builder.Property(x => x.FirstReminderSent);
        builder.Property(x => x.SecondReminderDateUtc);
        builder.Property(x => x.SecondReminderSent);
        builder.Property(x => x.FinalReminderDateUtc);
        builder.Property(x => x.FinalReminderSent);
        builder.Property(x => x.DeadlineMet);
        builder.Property(x => x.DeadlineDateUtc).IsRequired();
        builder.Property(x => x.LastDeadlineBreachedAlertSentDateUtc);
        
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Configurations/SignedSLAConfiguration.cs">
using System.Text.Json;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data.Configurations;

internal sealed class SignedSLAConfiguration : IEntityTypeConfiguration<SignedSLA>
{
    private static readonly JsonSerializerOptions JsonOpt = new JsonSerializerOptions
        { PropertyNamingPolicy = JsonNamingPolicy.CamelCase };
    
    public void Configure(EntityTypeBuilder<SignedSLA> builder)
    {
        builder.HasKey(x => x.Id);
        builder.Property(x => x.CompanyName).IsRequired();
        builder.Property(x => x.Domain).IsRequired();
        builder.Property(x => x.ClientTier).IsRequired();
        builder.Property<Dictionary<ServiceType, SLADeadlines>>("_agreedResponseDeadlines")
            .IsRequired()
            .HasColumnType("jsonb")
            .HasConversion(x => JsonSerializer.Serialize(x, JsonOpt),
                x => JsonSerializer.Deserialize<Dictionary<ServiceType, SLADeadlines>>(x, JsonOpt));
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241217213005_Initial.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    /// <inheritdoc />
    public partial class Initial : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.EnsureSchema(
                name: "sla");

            migrationBuilder.CreateTable(
                name: "DeadlineReminders",
                schema: "sla",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    ServiceType = table.Column<byte>(type: "smallint", nullable: false),
                    ServiceSourceId = table.Column<string>(type: "text", nullable: false),
                    AgentIdToRemind = table.Column<Guid>(type: "uuid", nullable: true),
                    FirstReminderDateUtc = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true),
                    FirstReminderSent = table.Column<bool>(type: "boolean", nullable: false),
                    SecondReminderDateUtc = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true),
                    SecondReminderSent = table.Column<bool>(type: "boolean", nullable: false),
                    FinalReminderDateUtc = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true),
                    FinalReminderSent = table.Column<bool>(type: "boolean", nullable: false),
                    DeadlineMet = table.Column<bool>(type: "boolean", nullable: true),
                    DeadlineDateUtc = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false),
                    LastDeadlineBreachedAlertSentDateUtc = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_DeadlineReminders", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "SignedSLAs",
                schema: "sla",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    CompanyName = table.Column<string>(type: "text", nullable: false),
                    Domain = table.Column<string>(type: "text", nullable: false),
                    ClientTier = table.Column<int>(type: "integer", nullable: false),
                    _agreedResponseDeadlines = table.Column<string>(type: "jsonb", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_SignedSLAs", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "DeadlineReminders",
                schema: "sla");

            migrationBuilder.DropTable(
                name: "SignedSLAs",
                schema: "sla");
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241217213005_Initial.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.SLA.Core.Data;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    [DbContext(typeof(SLADbContext))]
    [Migration("20241217213005_Initial")]
    partial class Initial
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("sla")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.DeadlineReminders", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AgentIdToRemind")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("DeadlineDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool?>("DeadlineMet")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FinalReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FinalReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FirstReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FirstReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LastDeadlineBreachedAlertSentDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("SecondReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("SecondReminderSent")
                        .HasColumnType("boolean");

                    b.Property<string>("ServiceSourceId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<byte>("ServiceType")
                        .HasColumnType("smallint");

                    b.HasKey("Id");

                    b.ToTable("DeadlineReminders", "sla");
                });

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.SignedSLA", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("ClientTier")
                        .HasColumnType("integer");

                    b.Property<string>("CompanyName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Domain")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("_agreedResponseDeadlines")
                        .IsRequired()
                        .HasColumnType("jsonb");

                    b.HasKey("Id");

                    b.ToTable("SignedSLAs", "sla");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241218195823_UserId_InsteadOf_AgentId.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    /// <inheritdoc />
    public partial class UserId_InsteadOf_AgentId : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "AgentIdToRemind",
                schema: "sla",
                table: "DeadlineReminders",
                newName: "UserIdToRemind");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.RenameColumn(
                name: "UserIdToRemind",
                schema: "sla",
                table: "DeadlineReminders",
                newName: "AgentIdToRemind");
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241218195823_UserId_InsteadOf_AgentId.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.SLA.Core.Data;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    [DbContext(typeof(SLADbContext))]
    [Migration("20241218195823_UserId_InsteadOf_AgentId")]
    partial class UserId_InsteadOf_AgentId
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("sla")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.DeadlineReminders", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("DeadlineDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool?>("DeadlineMet")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FinalReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FinalReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FirstReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FirstReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LastDeadlineBreachedAlertSentDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("SecondReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("SecondReminderSent")
                        .HasColumnType("boolean");

                    b.Property<string>("ServiceSourceId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<byte>("ServiceType")
                        .HasColumnType("smallint");

                    b.Property<Guid?>("UserIdToRemind")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("DeadlineReminders", "sla");
                });

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.SignedSLA", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("ClientTier")
                        .HasColumnType("integer");

                    b.Property<string>("CompanyName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Domain")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("_agreedResponseDeadlines")
                        .IsRequired()
                        .HasColumnType("jsonb");

                    b.HasKey("Id");

                    b.ToTable("SignedSLAs", "sla");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241230221523_SourceServiceVersion_And_ServiceCompleted.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    /// <inheritdoc />
    public partial class SourceServiceVersion_And_ServiceCompleted : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<bool>(
                name: "ServiceCompleted",
                schema: "sla",
                table: "DeadlineReminders",
                type: "boolean",
                nullable: false,
                defaultValue: false);

            migrationBuilder.AddColumn<int>(
                name: "ServiceLastKnownVersion",
                schema: "sla",
                table: "DeadlineReminders",
                type: "integer",
                nullable: false,
                defaultValue: 0);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "ServiceCompleted",
                schema: "sla",
                table: "DeadlineReminders");

            migrationBuilder.DropColumn(
                name: "ServiceLastKnownVersion",
                schema: "sla",
                table: "DeadlineReminders");
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/20241230221523_SourceServiceVersion_And_ServiceCompleted.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.SLA.Core.Data;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    [DbContext(typeof(SLADbContext))]
    [Migration("20241230221523_SourceServiceVersion_And_ServiceCompleted")]
    partial class SourceServiceVersion_And_ServiceCompleted
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("sla")
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.DeadlineReminders", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("DeadlineDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool?>("DeadlineMet")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FinalReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FinalReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FirstReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FirstReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LastDeadlineBreachedAlertSentDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("SecondReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("SecondReminderSent")
                        .HasColumnType("boolean");

                    b.Property<bool>("ServiceCompleted")
                        .HasColumnType("boolean");

                    b.Property<int>("ServiceLastKnownVersion")
                        .HasColumnType("integer");

                    b.Property<string>("ServiceSourceId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<byte>("ServiceType")
                        .HasColumnType("smallint");

                    b.Property<Guid?>("UserIdToRemind")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("DeadlineReminders", "sla");
                });

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.SignedSLA", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("ClientTier")
                        .HasColumnType("integer");

                    b.Property<string>("CompanyName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Domain")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("_agreedResponseDeadlines")
                        .IsRequired()
                        .HasColumnType("jsonb");

                    b.HasKey("Id");

                    b.ToTable("SignedSLAs", "sla");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/SLA/SLADbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.SLA.Core.Data;

#nullable disable

namespace TicketFlow.Services.SLA.Core.Data.Migrations.SLA
{
    [DbContext(typeof(SLADbContext))]
    partial class SLADbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("sla")
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.DeadlineReminders", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("DeadlineDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool?>("DeadlineMet")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FinalReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FinalReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("FirstReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("FirstReminderSent")
                        .HasColumnType("boolean");

                    b.Property<DateTimeOffset?>("LastDeadlineBreachedAlertSentDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("SecondReminderDateUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<bool>("SecondReminderSent")
                        .HasColumnType("boolean");

                    b.Property<bool>("ServiceCompleted")
                        .HasColumnType("boolean");

                    b.Property<int>("ServiceLastKnownVersion")
                        .HasColumnType("integer");

                    b.Property<string>("ServiceSourceId")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<byte>("ServiceType")
                        .HasColumnType("smallint");

                    b.Property<Guid?>("UserIdToRemind")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("DeadlineReminders", "sla");
                });

            modelBuilder.Entity("TicketFlow.Services.SLA.Core.Data.Models.SignedSLA", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<int>("ClientTier")
                        .HasColumnType("integer");

                    b.Property<string>("CompanyName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Domain")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("_agreedResponseDeadlines")
                        .IsRequired()
                        .HasColumnType("jsonb");

                    b.HasKey("Id");

                    b.ToTable("SignedSLAs", "sla");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Migrations/scripts.txt">
// Create migration for SLA schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/SLA --startup-project ./../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context SLADbContext

// Apply migration for SLA schema
dotnet ef database update --startup-project ../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context SLADbContext

// Create migration for Deduplication schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Deduplication --startup-project ./../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context DeduplicationDbContext

// Apply migration for Deduplication schema
dotnet ef database update --startup-project ../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context DeduplicationDbContext

// Create migration for Outbox schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Outbox --startup-project ./../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context OutboxDbContext

// Apply migration for Outbox schema
dotnet ef database update --startup-project ../TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context OutboxDbContext
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/CalculatedDeadline.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public record CalculatedDeadline(DateTimeOffset DueDateUtc, SLATier ClientTier);
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/DeadlineReminders.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public class DeadlineReminders
{
    private DeadlineReminders(){}
    
    public DeadlineReminders(
        ServiceType serviceType,
        string serviceSourceId,
        Guid? userIdToRemind,
        DateTimeOffset serviceRequestDateUtc,
        CalculatedDeadline calculatedDeadline)
    {
        ServiceType = serviceType;
        ServiceSourceId = serviceSourceId;
        UserIdToRemind = userIdToRemind;
        CalculateReminders(serviceRequestDateUtc, calculatedDeadline);
    }

    public Guid Id { get; init; }
    public bool IsTransient => Id.Equals(Guid.Empty);
    public ServiceType ServiceType { get; init; }
    public string ServiceSourceId { get; init; }
    public int ServiceLastKnownVersion { get; set; }
    public Guid? UserIdToRemind { get; set; }
    public DateTimeOffset? FirstReminderDateUtc { get; private set; }
    public bool FirstReminderSent { get; private set; }
    public DateTimeOffset? SecondReminderDateUtc { get; private set; }
    public bool SecondReminderSent { get; private set; }
    public DateTimeOffset? FinalReminderDateUtc { get; private set; }
    public bool FinalReminderSent { get; private set; }
    public bool? DeadlineMet { get; private set; }
    public bool ServiceCompleted { get; private set; }
    public DateTimeOffset DeadlineDateUtc { get; private set; }
    public DateTimeOffset? LastDeadlineBreachedAlertSentDateUtc { get; private set; }

    private void CalculateReminders(DateTimeOffset serviceRequestDateUtc, CalculatedDeadline calculatedDeadline)
    {
        if (calculatedDeadline is null)
        {
            throw new ArgumentNullException(nameof(calculatedDeadline));
        }
        
        var dueDate = calculatedDeadline.DueDateUtc;
        DeadlineDateUtc = dueDate;
        
        if (dueDate <= DateTimeOffset.UtcNow.AddHours(1))
        {
            FirstReminderDateUtc = serviceRequestDateUtc.AddMinutes(15);
            SecondReminderDateUtc = serviceRequestDateUtc.AddMinutes(30);
            FinalReminderDateUtc = serviceRequestDateUtc.AddMinutes(45);
            return;
        }
        
        FirstReminderDateUtc = serviceRequestDateUtc.AddMinutes(15);
        var middleTime = (dueDate - serviceRequestDateUtc)/2;
        SecondReminderDateUtc = serviceRequestDateUtc.Add(middleTime);
        FinalReminderDateUtc = serviceRequestDateUtc.AddMinutes(-15);
    }
    
    public void UpdateFromServiceChange(string status)
    {
        if (IsFinishingStatus(status))
        {
            DeadlineMet = DateTimeOffset.UtcNow > DeadlineDateUtc;
            ServiceCompleted = true;
        }
        else
        {
            ServiceCompleted = false;
        }
    }

    public void DetectDeadlineBreached()
    {
        var deadlineBreached = DateTimeOffset.UtcNow > DeadlineDateUtc;
        if (deadlineBreached)
        {
            DeadlineMet = false;
        }
    }

    public void MarkFirstReminderSent()
    {
        FirstReminderSent = true;
    }

    public void MarkSecondReminderSent()
    {
        SecondReminderSent = true;
    }

    public void MarkFinalReminderSent()
    {
        FinalReminderSent = true;
    }

    public void MarkDeadlineBreachAlertSent()
    {
        if (DeadlineMet is null)
        {
            throw new InvalidOperationException("DeadlineMet is null");
        }
        
        LastDeadlineBreachedAlertSentDateUtc = DateTimeOffset.UtcNow;
    }

    private bool IsFinishingStatus(string status)
    {
        switch (ServiceType)
        {
            case ServiceType.IncidentTicket:
            case ServiceType.QuestionTicket:
                return TicketStatus.IsFinishingForTicket(status);
        }
        
        throw new NotImplementedException(ServiceType.ToString());
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/Defaults.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data.Models;

public static class Defaults
{
    public static SLADeadlines Deadlines => new(new Dictionary<SeverityLevel, TimeSpan>
    {
        { SeverityLevel.Low, TimeSpan.FromDays(7) },
        { SeverityLevel.Medium, TimeSpan.FromDays(3) },
        { SeverityLevel.High, TimeSpan.FromDays(1) },
        { SeverityLevel.Critical, TimeSpan.FromHours(1) }
    });

    public static SignedSLA SLA => new(
        default,
        default,
        SLATier.Standard,
        new Dictionary<ServiceType, SLADeadlines>
        {
            {
                ServiceType.IncidentTicket,
                Deadlines
            },
            {
                ServiceType.QuestionTicket,
                Deadlines
            }
        });
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/Email.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public record Email(string Value)
{
    public string Domain => Value.Split("@")[1];
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/ServiceType.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public enum ServiceType : byte
{
    Unknown = 0,
    IncidentTicket = 1,
    QuestionTicket = 2
}

public static class ServiceTypeExtensions
{
    public static ServiceType? ParseAsServiceType(this string ticketType)
    {
        return ticketType switch
        {
            "Incident" => ServiceType.IncidentTicket,
            "Question" => ServiceType.QuestionTicket,
            _ => default(ServiceType?)
        };
    }

    public static string ToHumanReadableString(this ServiceType serviceType)
    {
        return serviceType switch
        {
            ServiceType.IncidentTicket => "Ticket - Incydent",
            ServiceType.QuestionTicket => "Ticket - Pytanie",
            _ => throw new NotImplementedException(serviceType.ToString()),
        };
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/SeverityLevel.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum SeverityLevel
{
    Low,
    Medium,
    High,
    Critical
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/SignedSLA.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Services.SLA.Core.Data.Models;

public class SignedSLA
{
    public Guid Id { get; init; } = Guid.NewGuid();
    public string CompanyName { get; init; }
    public string Domain { get; init; }

    private Dictionary<ServiceType, SLADeadlines> _agreedResponseDeadlines;
    public IReadOnlyDictionary<ServiceType, SLADeadlines> AgreedResponseDeadlines => _agreedResponseDeadlines;
    
    public SLATier ClientTier { get; init; }
    
    private SignedSLA()
    {
        
    }
    
    public SignedSLA(string companyName, string domain, SLATier clientTier, Dictionary<ServiceType, SLADeadlines> agreedDeadlines)
    {
        CompanyName = companyName;
        Domain = domain;
        ClientTier = clientTier;
        _agreedResponseDeadlines = agreedDeadlines ?? throw new ArgumentNullException(nameof(agreedDeadlines));
    }

    public CalculatedDeadline? CalculatedDeadlineFor(DateTimeOffset requestReceiveDateUtc, ServiceType serviceType, SeverityLevel severityLevel)
    {
        AgreedResponseDeadlines.TryGetValue(serviceType, out var deadlines);
        if (deadlines is null)
        {
            return default;
        }

        deadlines.ResponseDeadlines.TryGetValue(severityLevel, out var deadline);
        if (deadline.Equals(TimeSpan.Zero))
        {
            deadline = Defaults.Deadlines.ResponseDeadlines[severityLevel];
        }

        return new CalculatedDeadline(requestReceiveDateUtc.Add(deadline), ClientTier);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/SLADeadlines.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data.Models;

public record SLADeadlines(Dictionary<SeverityLevel, TimeSpan> ResponseDeadlines);
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/SLATier.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public enum SLATier
{
    Standard,
    Premium,
    VIP
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Models/TicketStatus.cs">
namespace TicketFlow.Services.SLA.Core.Data.Models;

public static class TicketStatus
{
    public static bool IsFinishingForTicket(this string status)
    {
        return status.ToLower().Equals("resolved");
    }
    
    public const string Qualified = "Qualified";
    public const string AgentAssigned = "AgentAssigned";
    public const string Resolved = "Resolved";
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Repositories/ISLARepository.cs">
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data.Repositories;

public interface ISLARepository
{
    Task<SignedSLA?> GetSLAByRequestorDomain(string domain, CancellationToken cancellationToken);

    Task SaveReminders(DeadlineReminders reminders, CancellationToken cancellationToken);
    
    Task<DeadlineReminders?> GetRemindersFor(ServiceType serviceType, string serviceSourceId,
        CancellationToken cancellationToken);

    Task<DeadlineReminders> GetRemindersFor(ICollection<ServiceType> anyOfServiceTypes, string serviceSourceId,
        CancellationToken cancellationToken);

    Task<List<DeadlineReminders>> GetWithPendingFirstReminder(CancellationToken cancellationToken);
    Task<List<DeadlineReminders>> GetWithPendingSecondReminder(CancellationToken cancellationToken);
    Task<List<DeadlineReminders>> GetWithPendingFinalReminder(CancellationToken cancellationToken);
    Task<List<DeadlineReminders>> GetWithDeadlineDateBreached(CancellationToken cancellationToken);
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/Repositories/SLARepository.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Services.SLA.Core.Messaging.Consuming;
using TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

namespace TicketFlow.Services.SLA.Core.Data.Repositories;

internal sealed class SLARepository : ISLARepository, 
    IGetMessageRelatedEntityVersion<ITicketChange>,
    IGetMessageRelatedEntityVersion<TicketQualified>,
    IGetMessageRelatedEntityVersion<AgentAssignedToTicket>,
    IGetMessageRelatedEntityVersion<TicketResolved>
{
    private readonly SLADbContext _slaDbContext;

    public SLARepository(SLADbContext slaDbContext)
    {
        _slaDbContext = slaDbContext ?? throw new ArgumentNullException(nameof(slaDbContext));
    }
    
    public async Task<SignedSLA> GetSLAByRequestorDomain(string domain, CancellationToken cancellationToken)
    {
        return await _slaDbContext.SignedSLAs.SingleOrDefaultAsync(x => x.Domain == domain, cancellationToken);
    }

    public async Task SaveReminders(DeadlineReminders reminders, CancellationToken cancellationToken)
    {
        if (reminders.IsTransient)
        {
            await _slaDbContext.DeadlineReminders.AddAsync(reminders, cancellationToken);
        }
        else
        {
            _slaDbContext.DeadlineReminders.Update(reminders);
        }

        await _slaDbContext.SaveChangesAsync(cancellationToken);
    }

    public async Task<DeadlineReminders> GetRemindersFor(ServiceType serviceType, string serviceSourceId, CancellationToken cancellationToken)
    {
        return await _slaDbContext.DeadlineReminders.SingleOrDefaultAsync(x => 
            x.ServiceType == serviceType && x.ServiceSourceId == serviceSourceId, cancellationToken);
    }

    public async Task<DeadlineReminders> GetRemindersFor(ICollection<ServiceType> anyOfServiceTypes, string serviceSourceId, CancellationToken cancellationToken)
    {
        return await _slaDbContext.DeadlineReminders.SingleOrDefaultAsync(x => 
            anyOfServiceTypes.Contains(x.ServiceType) && x.ServiceSourceId == serviceSourceId, cancellationToken);
    }

    public async Task<List<DeadlineReminders>> GetWithPendingFirstReminder(CancellationToken cancellationToken)
    {
        return await _slaDbContext.DeadlineReminders
            .Where(x => x.ServiceCompleted == false)
            .Where(x => x.FirstReminderSent == false)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<DeadlineReminders>> GetWithPendingSecondReminder(CancellationToken cancellationToken)
    {
        return await _slaDbContext.DeadlineReminders
            .Where(x => x.ServiceCompleted == false)
            .Where(x => x.SecondReminderSent == false)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<DeadlineReminders>> GetWithPendingFinalReminder(CancellationToken cancellationToken)
    {
        return await _slaDbContext.DeadlineReminders
            .Where(x => x.ServiceCompleted == false)
            .Where(x => x.FinalReminderSent == false)
            .ToListAsync(cancellationToken);
    }

    public async Task<List<DeadlineReminders>> GetWithDeadlineDateBreached(CancellationToken cancellationToken)
    {
        var now = DateTimeOffset.UtcNow;
        return await _slaDbContext.DeadlineReminders
            .Where(x => x.DeadlineDateUtc <= now)
            .Where(x => x.ServiceCompleted == false)
            .ToListAsync(cancellationToken);
    }

    public async Task<int?> GetEntityVersionAsync(ITicketChange message, CancellationToken cancellationToken = default)
    {
        var matchingDeadline = await _slaDbContext.DeadlineReminders
            .Where(x =>
                x.ServiceType.Equals(ServiceType.QuestionTicket)
                || x.ServiceType.Equals(ServiceType.IncidentTicket))
            .Where(x => x.ServiceSourceId.Equals(message.TicketId.ToString()))
            .SingleOrDefaultAsync(cancellationToken);
        
        return matchingDeadline?.ServiceLastKnownVersion;
    }

    public Task<int?> GetEntityVersionAsync(TicketQualified message, CancellationToken cancellationToken = default)
    {
        return GetEntityVersionAsync((ITicketChange)message, cancellationToken);
    }

    public Task<int?> GetEntityVersionAsync(AgentAssignedToTicket message, CancellationToken cancellationToken = default)
    {
        return GetEntityVersionAsync((ITicketChange)message, cancellationToken);
    }

    public Task<int?> GetEntityVersionAsync(TicketResolved message, CancellationToken cancellationToken = default)
    {
        return GetEntityVersionAsync((ITicketChange)message, cancellationToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Data/SLADbContext.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Data;

public class SLADbContext(DbContextOptions options) : DbContext(options)
{
    public DbSet<SignedSLA> SignedSLAs { get; set; }
    public DbSet<DeadlineReminders> DeadlineReminders { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(GetType().Assembly);
        modelBuilder.HasDefaultSchema("sla");
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Communication/CommunicationsClient.cs">
using System.Net.Http.Json;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Http.Communication;

internal class CommunicationsClient(HttpClient httpClient, ILogger<CommunicationsClient> logger) : ICommunicationClient
{
    public async Task SendReminderMessage(Guid userId, ServiceType serviceType, string serviceSourceId, ICommunicationClient.ReminderMessageType type,
        CancellationToken cancellationToken)
    {
        logger.LogInformation($"Sending reminder message for user {userId}, service type {serviceType}, service source {serviceSourceId}, reminder type {type}");
        var message = CreateForReminder(userId, serviceType, serviceSourceId, type);
        
        await httpClient.PostAsJsonAsync("/messages/", message, cancellationToken);
    }

    private MessageDto CreateForReminder(Guid userId, ServiceType serviceType, string serviceSourceId,
        ICommunicationClient.ReminderMessageType type)
    {
        var reminderTitle = type switch
        {
            ICommunicationClient.ReminderMessageType.FirstReminder => $"Przypomnienie #1",
            ICommunicationClient.ReminderMessageType.SecondReminder => $"Przypomnienie #2",
            ICommunicationClient.ReminderMessageType.FinalReminder => $"Ostateczne przypomnienie",
            ICommunicationClient.ReminderMessageType.SLABreachedRecurring => $"SLA niespełnione",
        };
        
        var reminderContent = type switch
        {
            ICommunicationClient.ReminderMessageType.FirstReminder => $"{serviceType.ToHumanReadableString()} - ID: {serviceSourceId} jest przypisany do Ciebie i czeka na twoją akcje",
            ICommunicationClient.ReminderMessageType.SecondReminder => $"{serviceType.ToHumanReadableString()} - ID: {serviceSourceId} jest przypisany do Ciebie i czeka na twoją akcje",
            ICommunicationClient.ReminderMessageType.FinalReminder => $"{serviceType.ToHumanReadableString()} - ID: {serviceSourceId} zaraz przekroczy SLA - działaj jak najszybciej!",
            ICommunicationClient.ReminderMessageType.SLABreachedRecurring => $"{serviceType.ToHumanReadableString()} - ID: {serviceSourceId} przekroczyło ustalone SLA - działaj!",
        };

        return new MessageDto
        {
            RecipentEmail = null,
            RecipentUserId = userId,
            SenderUserId = null, // SYSTEM
            Title = reminderTitle,
            Content = reminderContent,
            Timestamp = DateTimeOffset.UtcNow
        };
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Communication/ICommunicationClient.cs">
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Http.Communication;

public interface ICommunicationClient
{
    Task SendReminderMessage(Guid userId, ServiceType serviceType, string serviceSourceId, ReminderMessageType type, CancellationToken cancellationToken);

    public enum ReminderMessageType
    {
        FirstReminder,
        SecondReminder,
        FinalReminder,
        SLABreachedRecurring
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Communication/MessageDto.cs">
namespace TicketFlow.Services.SLA.Core.Http.Communication;

public class MessageDto
{
    public string RecipentEmail { get; set; }
    public Guid? RecipentUserId { get; set; }
    public Guid? SenderUserId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }
    public DateTimeOffset Timestamp { get; set; }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Tickets/AgentDto.cs">
namespace TicketFlow.Services.SLA.Core.Http.Tickets;

public record AgentDto(
    string Id,
    string UserId,
    string FullName,
    string Position,
    string AvatarUrl);
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Tickets/ITicketsClient.cs">
namespace TicketFlow.Services.SLA.Core.Http.Tickets;

public interface ITicketsClient
{
    Task<TicketDto> GetTicketDetails(string ticketId, CancellationToken cancellationToken);
    Task<List<Guid>> GetSupervisorsUserIds(CancellationToken cancellationToken);
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Tickets/TicketDetails.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Http.Tickets;

public class TicketDto(
    string Id,
    string Email,
    string Status,
    DateTimeOffset CreatedAt,
    SeverityLevel? SeverityLevel,
    Guid? AssignedAgentUserId,
    string Type)
{
    public string Id { get; init; } = Id;
    public string Email { get; init; } = Email;
    public string Status { get; init; } = Status;
    public DateTimeOffset CreatedAt { get; init; } = CreatedAt;
    public SeverityLevel? SeverityLevel { get; init; } = SeverityLevel;
    public Guid? AssignedAgentUserId { get; init; } = AssignedAgentUserId;
    public string Type { get; init; } = Type;
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Http/Tickets/TicketsClient.cs">
using System.Net.Http.Json;
using TicketFlow.Shared.Serialization;
using JsonSerializer = System.Text.Json.JsonSerializer;

namespace TicketFlow.Services.SLA.Core.Http.Tickets;

internal class TicketsClient : ITicketsClient
{
    private readonly HttpClient _httpClient;
    
    public TicketsClient(HttpClient httpClient)
    {
        _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
    }
    
    public async Task<TicketDto> GetTicketDetails(string ticketId, CancellationToken cancellationToken)
    {
        var json = await _httpClient.GetStringAsync($"/tickets/{ticketId}", cancellationToken);
        var result = JsonSerializer.Deserialize<TicketDto>(json, SerializationOptions.Default);
        return result;
    }

    public async Task<List<Guid>> GetSupervisorsUserIds(CancellationToken cancellationToken)
    {
        var allAgents = await _httpClient.GetFromJsonAsync<AgentDto[]>("agents", cancellationToken);
        return allAgents
            .Where(x => x.Position.Equals("Supervisor"))
            .Select(x => Guid.Parse(x.UserId))
            .ToList();
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Initializers/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Services.SLA.Core.Initializers;

public static class Extensions
{
    public static IServiceCollection AddAppInitializers(this IServiceCollection services)
    {
        services.AddHostedService<SLASignedAppInitializer>();
        return services;
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Initializers/SLASignedAppInitializer.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Data;
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Initializers;

internal sealed class SLASignedAppInitializer(IServiceProvider serviceProvider) : IHostedService
{
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        var scope = serviceProvider.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<SLADbContext>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<SLASignedAppInitializer>>();
        
        await dbContext.Database.EnsureCreatedAsync(cancellationToken);

        if (await dbContext.SignedSLAs.AnyAsync(cancellationToken))
        {
            logger.LogInformation("Signed SLAs are already initialized. Skipping further initialization.");
            return;
        }

        var slas = new List<SignedSLA>
        {
            new SignedSLA("DevMentors", "devmentors.io", SLATier.VIP, 
                new Dictionary<ServiceType, SLADeadlines>
                {
                    {
                        ServiceType.IncidentTicket,
                        new SLADeadlines(new Dictionary<SeverityLevel, TimeSpan>
                            {
                                { SeverityLevel.Low, TimeSpan.FromMinutes(30) },
                                { SeverityLevel.Medium, TimeSpan.FromMinutes(15) },
                                { SeverityLevel.High, TimeSpan.FromMinutes(3) },
                                { SeverityLevel.Critical, TimeSpan.FromMinutes(1) }
                            })
                    },
                    {
                        ServiceType.QuestionTicket,
                        new SLADeadlines(new Dictionary<SeverityLevel, TimeSpan>
                        {
                            { SeverityLevel.Low, TimeSpan.FromMinutes(30) },
                            { SeverityLevel.Medium, TimeSpan.FromMinutes(15) },
                            { SeverityLevel.High, TimeSpan.FromMinutes(3) },
                            { SeverityLevel.Critical, TimeSpan.FromMinutes(1) }
                        })
                    },
                })
        };
        
        await dbContext.SignedSLAs.AddRangeAsync(slas, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
        logger.LogInformation("Signed SLAs initialized successfully.");
    }

    public Task StopAsync(CancellationToken cancellationToken)
        => Task.CompletedTask;
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/ApplicationServices/TicketService.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Services.SLA.Core.Data.Repositories;
using TicketFlow.Services.SLA.Core.Http.Tickets;
using TicketFlow.Services.SLA.Core.Messaging.Publishing;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;

public class TicketService
{
    private readonly ITicketsClient _ticketsClient;
    private readonly ISLARepository _slaRepository;
    private readonly IMessagePublisher _publisher;
    private readonly ILogger<TicketService> _logger;

    public TicketService(
        ITicketsClient ticketsClient,
        ISLARepository slaRepository,
        IMessagePublisher publisher,
        ILogger<TicketService> logger)
    {
        _ticketsClient = ticketsClient;
        _slaRepository = slaRepository;
        _publisher = publisher;
        _logger = logger;
    }
    
    public async Task HandleTicketQualifiedAsync(Guid ticketId, int version, CancellationToken cancellationToken = default)
    {
        var ticketDetails = await _ticketsClient.GetTicketDetails(ticketId.ToString(), cancellationToken);
        if (ticketDetails is null)
        {
            throw new TicketFlowException($"Could not fetch data of ticket: {ticketId}");
        }
        
        var serviceType = ticketDetails.Type.ParseAsServiceType() ?? ServiceType.Unknown;
        if (serviceType == ServiceType.Unknown)
        {
            throw new TicketFlowException("Unknown service type");
        }
        
        // Do we know this ticket based on reminders?
        var existingReminders = await _slaRepository.GetRemindersFor(
            serviceType: serviceType,
            serviceSourceId: ticketId.ToString(),
            cancellationToken);

        if (existingReminders is null) // First time qualified
        {
            var domain = new Email(ticketDetails.Email).Domain;
            var sla = await _slaRepository.GetSLAByRequestorDomain(domain, cancellationToken) ??
                      Defaults.SLA; // If no signed SLA - use defaults

            var deadline = sla.CalculatedDeadlineFor(ticketDetails.CreatedAt, serviceType,
                ticketDetails.SeverityLevel!.Value);

            if (deadline is not null)
            {
                var deadlineReminders = new DeadlineReminders(
                    serviceType,
                    ticketId.ToString(),
                    ticketDetails.AssignedAgentUserId,
                    ticketDetails.CreatedAt,
                    deadline);

                deadlineReminders.ServiceLastKnownVersion = version;
                await _slaRepository.SaveReminders(deadlineReminders, cancellationToken);

                await _publisher.PublishAsync(
                    new DeadlinesCalculated(
                        deadlineReminders.ServiceType,
                        deadlineReminders.ServiceSourceId,
                        deadlineReminders.DeadlineDateUtc),
                    cancellationToken: cancellationToken);
            }
        }
        else // We unblocked the ticket or reopened it
        {
            existingReminders.UpdateFromServiceChange(TicketStatus.Qualified);
            existingReminders.ServiceLastKnownVersion = version;
            await _slaRepository.SaveReminders(existingReminders, cancellationToken);
        }
    }

    public async Task HandleAgentAssignedAsync(Guid ticketId, int version, CancellationToken cancellationToken = default)
    {
        var ticketDetails = await _ticketsClient.GetTicketDetails(ticketId.ToString(), cancellationToken);
        if (ticketDetails is null)
        {
            throw new TicketFlowException($"Could not fetch data of ticket: {ticketId}");
        }
        
        var serviceType = ticketDetails.Type.ParseAsServiceType() ?? ServiceType.Unknown;
        if (serviceType == ServiceType.Unknown)
        {
            throw new TicketFlowException("Unknown service type");
        }
        
        var existingReminders = await _slaRepository.GetRemindersFor(
            serviceType: serviceType,
            serviceSourceId: ticketId.ToString(),
            cancellationToken);

        if (existingReminders is null)
        {
            throw new TicketFlowException($"Could not find existing reminders for ticket: {ticketId}");
        }
        
        existingReminders.UserIdToRemind = ticketDetails.AssignedAgentUserId;
        existingReminders.ServiceLastKnownVersion = version;
        await _slaRepository.SaveReminders(existingReminders, cancellationToken);
    }
    
    public async Task HandleTicketResolvedAsync(Guid ticketId, int version, CancellationToken cancellationToken = default)
    {
        var existingReminders = await _slaRepository.GetRemindersFor(
            anyOfServiceTypes: [ServiceType.QuestionTicket, ServiceType.IncidentTicket],
            serviceSourceId: ticketId.ToString(),
            cancellationToken);

        if (existingReminders is null)
        {
            throw new TicketFlowException($"Could not fetch data of ticket: {ticketId}");
        }
        
        existingReminders.UpdateFromServiceChange(TicketStatus.Resolved);
        existingReminders.ServiceLastKnownVersion = version;
        await _slaRepository.SaveReminders(existingReminders, cancellationToken);
    }

    public async Task MarkLastVersionKnownAsync(Guid ticketId, int version,
        CancellationToken cancellationToken = default)
    {
        var existingReminders = await _slaRepository.GetRemindersFor(
            anyOfServiceTypes: [ServiceType.QuestionTicket, ServiceType.IncidentTicket],
            serviceSourceId: ticketId.ToString(),
            cancellationToken);
        
        existingReminders.ServiceLastKnownVersion = version;
        await _slaRepository.SaveReminders(existingReminders, cancellationToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/Demultiplexing/FallbackTicketChangeEvent.cs">
namespace TicketFlow.Services.SLA.Core.Messaging.Consuming.Demultiplexing;

public record FallbackTicketChangeEvent(Guid TicketId, int Version) : ITicketChange
{
    public string ToHumanReadableString() => this.ToHumanReadableChange();
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/Demultiplexing/TicketChangesHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming.Demultiplexing;

public class TicketChangesHandler
{
    private readonly ISerializer _serializer;
    private readonly IMessageHandler<TicketQualified> _ticketQualifiedHandler;
    private readonly IMessageHandler<AgentAssignedToTicket> _agentAssignedToTicketHandler;
    private readonly IMessageHandler<TicketResolved> _ticketResolvedHandler;
    private readonly ILogger<TicketChangesHandler> _logger;

    public TicketChangesHandler(
        ISerializer serializer,
        IMessageHandler<TicketQualified> ticketQualifiedHandler,
        IMessageHandler<AgentAssignedToTicket> agentAssignedToTicketHandler,
        IMessageHandler<TicketResolved> ticketResolvedHandler,
        ILogger<TicketChangesHandler> logger)
    {
        _serializer = serializer;
        _ticketQualifiedHandler = ticketQualifiedHandler;
        _agentAssignedToTicketHandler = agentAssignedToTicketHandler;
        _ticketResolvedHandler = ticketResolvedHandler;
        _logger = logger;
    }

    public async Task HandleAsync(MessageData messageData, CancellationToken cancellationToken = default)
    {
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(TicketChangesHandler)} is processing:{Environment.NewLine} {messageData}");
        
        ITicketChange message = Demultiplex(messageData);
        
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(TicketChangesHandler)} demultiplexed message data to:{Environment.NewLine} " +
                           $"{message}");
        
        switch (message)
        {
            case TicketQualified qualified:
                await _ticketQualifiedHandler.HandleAsync(qualified, cancellationToken);
                break;
            case AgentAssignedToTicket assigned:
                await _agentAssignedToTicketHandler.HandleAsync(assigned, cancellationToken);
                break;
            case TicketResolved resolved:
                await _ticketResolvedHandler.HandleAsync(resolved, cancellationToken);
                break;
            default:
                break;
        }
        
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(TicketChangesHandler)} processed message:{Environment.NewLine} " +
                           $"{message}");
    }
    
    private ITicketChange Demultiplex(MessageData messageData)
    {
        switch (messageData.Type)
        {
            case "TicketQualified":
                return _serializer.DeserializeBinary<TicketQualified>(messageData.Payload);
            case "AgentAssignedToTicket":
                return _serializer.DeserializeBinary<AgentAssignedToTicket>(messageData.Payload);
            case "TicketResolved":
                return _serializer.DeserializeBinary<TicketResolved>(messageData.Payload);
            default:
                return _serializer.DeserializeBinary<FallbackTicketChangeEvent>(messageData.Payload);
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/Partitioning/TicketChangesPartitioningSetup.cs">
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming.Partitioning;

public record TicketChangesPartitioningSetup(
    List<int> PartitionNumbersToConsume,
    PartitioningOptions PartitioningOptions) : IConsumerSpecificPartitioningSetup;
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/AgentAssignedToTicket.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public record AgentAssignedToTicket(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey, ITicketChange
{
    public string PartitionKey => TicketId.ToString();
    public string ToHumanReadableString() => this.ToHumanReadableChange();
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/AgentAssignedToTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public class AgentAssignedToTicketHandler : IMessageHandler<AgentAssignedToTicket>
{
    private readonly TicketService _ticketService;
    private readonly ILogger<TicketQualifiedHandler> _logger;

    public AgentAssignedToTicketHandler(        
        TicketService ticketService,
        ILogger<TicketQualifiedHandler> logger)
    {
        _ticketService = ticketService;
        _logger = logger;
    }
    
    public async Task HandleAsync(AgentAssignedToTicket message, CancellationToken cancellationToken = default)
    {
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(AgentAssignedToTicketHandler)} is processing:{Environment.NewLine} {message}");
        await _ticketService.HandleAgentAssignedAsync(message.TicketId, message.Version, cancellationToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/ITicketChange.cs">
using TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public interface ITicketChange : IVersionedMessage
{
    Guid TicketId { get; }
}

public static class TicketChangeExtensions
{
    public static string ToHumanReadableChange(this ITicketChange change) => 
        $"[{change.GetType().Name}] ID: {change.TicketId} || VERSION: {change.Version}";
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/TicketQualified.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public record TicketQualified(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey, ITicketChange
{
    public string PartitionKey => TicketId.ToString();
    public string ToHumanReadableString() => this.ToHumanReadableChange();
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/TicketQualifiedHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public class TicketQualifiedHandler : IMessageHandler<TicketQualified>
{
    private readonly TicketService _ticketService;
    private readonly ILogger<TicketQualifiedHandler> _logger;

    public TicketQualifiedHandler(        
        TicketService ticketService,
        ILogger<TicketQualifiedHandler> logger)
    {
        _ticketService = ticketService;
        _logger = logger;
    }
    
    public async Task HandleAsync(TicketQualified message, CancellationToken cancellationToken = default)
    {
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(TicketQualifiedHandler)} is processing:{Environment.NewLine} {message}");
        await _ticketService.HandleTicketQualifiedAsync(message.TicketId, message.Version, cancellationToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/TicketResolved.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public record TicketResolved(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey, ITicketChange
{
    public string PartitionKey => TicketId.ToString();
    public string ToHumanReadableString() => this.ToHumanReadableChange();
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Consuming/TicketResolvedHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Consuming;

public class TicketResolvedHandler : IMessageHandler<TicketResolved>
{
    private readonly TicketService _ticketService;
    private readonly ILogger<TicketQualifiedHandler> _logger;

    public TicketResolvedHandler(        
        TicketService ticketService,
        ILogger<TicketQualifiedHandler> logger)
    {
        _ticketService = ticketService;
        _logger = logger;
    }
    
    public async Task HandleAsync(TicketResolved message, CancellationToken cancellationToken = default)
    {
        _logger.LogWarning($"[{DateTime.UtcNow:O}] {nameof(TicketResolvedHandler)} is processing:{Environment.NewLine} {message}");
        await _ticketService.HandleTicketResolvedAsync(message.TicketId, message.Version, cancellationToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Publishing/Conventions/SLAMessagePublisherConventionProvider.cs">
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Publishing.Conventions;

internal sealed class SLAMessagePublisherConventionProvider : IMessagePublisherConventionProvider
{
    public const string ExchangeName = "sla-exchange";
    
    public (string destination, string routingKey) Get<TMessage>() where TMessage : class, IMessage 
        => (ExchangeName, PascalToKebabCase(typeof(TMessage).Name).WithAlertingApplied<TMessage>());

    private static string PascalToKebabCase(string str)
    {
        return string.Concat(str.SelectMany(ConvertChar));

        IEnumerable<char> ConvertChar(char c, int index)
        {
            if (char.IsUpper(c) && index != 0) yield return '-';
            yield return char.ToLower(c);
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Publishing/DeadlinesCalculated.cs">
using TicketFlow.Services.SLA.Core.Data.Models;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging.Publishing;

public record DeadlinesCalculated(ServiceType ServiceType, string ServiceSourceId, DateTimeOffset DeadlineUtc) : IMessage;
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/Publishing/SLABreached.cs">
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Services.SLA.Core.Data.Models;

namespace TicketFlow.Services.SLA.Core.Messaging.Publishing;

public record SLABreached(ServiceType ServiceType, string ServiceSourceId) : IAlertMessage
{
    public string AlertMessageContent =>
        $"SLA niespełnione dla [{ServiceType.ToHumanReadableString()}]: {ServiceSourceId})";

    public string AlertType => "SLA";
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/SLAConsumerService.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TicketFlow.CourseUtils;
using TicketFlow.Services.SLA.Core.Messaging.Consuming;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.Demultiplexing;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.Partitioning;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Messaging;

public class SLAConsumerService(
    IMessageConsumer messageConsumer,
    AnomalySynchronizationConfigurator anomalyConfigurator,
    IServiceProvider serviceProvider,
    TicketChangesPartitioningSetup ticketChangesPartitioning) : BackgroundService
{
    public const string TicketChangesQueue = "sla-ticket-changes";
    public const string TicketQualifiedQueue = "sla-ticket-qualified";
    public const string AgentAssignedQueue = "sla-agent-assigned";
    public const string TicketResolvedQueue = "sla-ticket-resolved";
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        #region topic-per-type
        if (FeatureFlags.UseTopicPerTypeExample)
        {
            await messageConsumer
                .ConsumeMessage<TicketQualified>(
                    queue: TicketQualifiedQueue,
                    cancellationToken: stoppingToken);

            await messageConsumer
                .ConsumeMessage<AgentAssignedToTicket>(
                    queue: AgentAssignedQueue,
                    cancellationToken: stoppingToken);
            
            await messageConsumer
                .ConsumeMessage<TicketResolved>(
                    queue: TicketResolvedQueue,
                    cancellationToken: stoppingToken);
        }
        #endregion
        #region topic-per-stream
        else if (FeatureFlags.UsePartitioningExample is false)
        {
            await messageConsumer
                .ConsumeNonGeneric(
                    handleRawPayload: async (messageData) =>
                    {
                        var demultiplexingHandler = CreateDemultiplexingHandler();
                        var logger = serviceProvider.GetService<ILogger<SLAConsumerService>>();
                        await demultiplexingHandler.HandleAsync(messageData, stoppingToken);
                    },
                    queue: TicketChangesQueue,
                    acceptedMessageTypes: ["TicketQualified", "AgentAssignedToTicket", "TicketBlocked", "TicketResolved"],
                    cancellationToken: stoppingToken);
        }
        #endregion
        #region topic-per-stream-with-partitioning
        else
        {
            await messageConsumer
                .ConsumeNonGenericFromPartitions(
                    ticketChangesPartitioning,
                    handleRawPayload: async (messageData) =>
                    {
                        var demultiplexingHandler = CreateDemultiplexingHandler();
                        var logger = serviceProvider.GetService<ILogger<SLAConsumerService>>();
                        await demultiplexingHandler.HandleAsync(messageData, stoppingToken);
                    },
                    queue: TicketChangesQueue,
                    acceptedMessageTypes: ["TicketQualified", "AgentAssignedToTicket", "TicketBlocked", "TicketResolved"],
                    cancellationToken: stoppingToken);
        }
        #endregion

        await anomalyConfigurator.ConsumeAnomalyChanges();
    }
    
    private TicketChangesHandler CreateDemultiplexingHandler()
    {
        var iocScope = serviceProvider.CreateScope();
        return iocScope.ServiceProvider.GetService<TicketChangesHandler>();
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Messaging/SLATopologyInitializer.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Services.SLA.Core.Messaging.Consuming;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.Partitioning;
using TicketFlow.Services.SLA.Core.Messaging.Publishing.Conventions;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.SLA.Core.Messaging;

public class SLATopologyInitializer : TopologyInitializerBase
{
    public SLATopologyInitializer(IServiceProvider serviceProvider) : base(serviceProvider){}
    
    protected override async Task CreateTopologyAsync(CancellationToken stoppingToken)
    {
        await CreateAlertingTopology(stoppingToken);
        await CreateAnomalySynchronizationTopology(stoppingToken);

        var topologyBuilder = ServiceProvider.GetService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: SLAMessagePublisherConventionProvider.ExchangeName,
            consumerDestination: "", // As publisher, we are consumer-ignorant
            TopologyType.PublishSubscribe,
            cancellationToken: stoppingToken
        );

        if (FeatureFlags.UseTopicPerTypeExample)
        {
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: "tickets-exchange",
                consumerDestination: SLAConsumerService.TicketQualifiedQueue,
                TopologyType.PublishSubscribe,
                filter: "ticket-qualified",
                cancellationToken: stoppingToken
            );
            
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: "tickets-exchange",
                consumerDestination: SLAConsumerService.AgentAssignedQueue,
                TopologyType.PublishSubscribe,
                filter: "agent-assigned",
                cancellationToken: stoppingToken
            );
            
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: "tickets-exchange",
                consumerDestination: SLAConsumerService.TicketResolvedQueue,
                TopologyType.PublishSubscribe,
                filter: "ticket-resolved",
                cancellationToken: stoppingToken
            );
        }
        else if (FeatureFlags.UsePartitioningExample is false)
        {
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: "tickets-exchange",
                consumerDestination: SLAConsumerService.TicketChangesQueue,
                TopologyType.PublishSubscribe,
                cancellationToken: stoppingToken
            );
        }
        else
        {
            var ticketStatusPartitionOpts = ServiceProvider.GetService<TicketChangesPartitioningSetup>();
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: "tickets-exchange",
                consumerDestination: SLAConsumerService.TicketChangesQueue,
                TopologyType.PublishSubscribe,
                partitioningOptions: ticketStatusPartitionOpts.PartitioningOptions,
                cancellationToken: stoppingToken
            );
        }
    }

    private async Task CreateAlertingTopology(CancellationToken stoppingToken)
    {
        var alertingTopologyBuilder = new AlertingTopologyBuilder(
            ServiceProvider.GetService<ITopologyBuilder>(),
            ServiceProvider.GetService<IMessagePublisherConventionProvider>());

        await alertingTopologyBuilder.CreateTopologyAsync(stoppingToken);
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Schedulers/DeadlineBreachOptions.cs">
namespace TicketFlow.Services.SLA.Core.Schedulers;

public class DeadlineBreachOptions
{
    public int WatcherIntervalInSeconds { get; set; }
    public int SecondsBetweenBreachAlerts { get; set; }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Schedulers/DeadlineBreachWatcher.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using TicketFlow.Services.SLA.Core.Data.Repositories;
using TicketFlow.Services.SLA.Core.Http.Communication;
using TicketFlow.Services.SLA.Core.Messaging.Publishing;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SLA.Core.Schedulers;

public class DeadlineBreachWatcher(
    DeadlineBreachOptions options,
    IServiceProvider serviceProvider) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (stoppingToken.IsCancellationRequested is false)
        {
            await Task.Delay(options.WatcherIntervalInSeconds, stoppingToken);
            try
            {
                await MarkBreachedDeadlines(stoppingToken);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"{nameof(DeadlineBreachWatcher)} failed with exception: {ex}");
            }
        }
    }

    private async Task MarkBreachedDeadlines(CancellationToken stoppingToken)
    {
        using var iocScope = serviceProvider.CreateScope();
        var slaRepository = iocScope.ServiceProvider.GetRequiredService<ISLARepository>();
        var messagePublisher = iocScope.ServiceProvider.GetRequiredService<IMessagePublisher>();
        var communicationClient = iocScope.ServiceProvider.GetRequiredService<ICommunicationClient>();
        
        var overdueDeadlines = await slaRepository.GetWithDeadlineDateBreached(stoppingToken);
        foreach (var deadline in overdueDeadlines)
        {
            deadline.DetectDeadlineBreached();
            
            var lastBreachNotification = deadline.LastDeadlineBreachedAlertSentDateUtc ?? deadline.DeadlineDateUtc;
            var canAlertAgain = DateTimeOffset.UtcNow - lastBreachNotification > TimeSpan.FromSeconds(options.SecondsBetweenBreachAlerts);
            
            if (canAlertAgain)
            {
                deadline.MarkDeadlineBreachAlertSent();
                /* Explicit decision to use CancellationToken.None - email was already sent so it's better to "force save" */
                await messagePublisher.PublishAsync(new SLABreached(deadline.ServiceType, deadline.ServiceSourceId), cancellationToken: CancellationToken.None);

                if (deadline.UserIdToRemind.HasValue)
                {
                    await communicationClient.SendReminderMessage(
                        deadline.UserIdToRemind!.Value,
                        deadline.ServiceType,
                        deadline.ServiceSourceId,
                        ICommunicationClient.ReminderMessageType.SLABreachedRecurring,
                        stoppingToken);
                }
            }
            
            await slaRepository.SaveReminders(deadline, CancellationToken.None);
        }

        await Task.CompletedTask;
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Schedulers/RemindersWatcher.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SLA.Core.Data.Repositories;
using TicketFlow.Services.SLA.Core.Http;
using TicketFlow.Services.SLA.Core.Http.Communication;

namespace TicketFlow.Services.SLA.Core.Schedulers;

public class RemindersWatcher(IServiceProvider serviceProvider) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (stoppingToken.IsCancellationRequested is false)
        {
            await Task.Delay(2_000, stoppingToken);
            try
            {
                await SendFirstReminders(stoppingToken);
                await SendSecondReminders(stoppingToken);
                await SendFinalReminders(stoppingToken);
            }
            catch (Exception ex)
            {
                serviceProvider.GetRequiredService<ILogger<RemindersWatcher>>().LogError(ex, ex.Message);
            }
        }
    }

    private async Task SendFirstReminders(CancellationToken stoppingToken)
    {
        using var iocScope = serviceProvider.CreateScope();
        var slaRepository = iocScope.ServiceProvider.GetRequiredService<ISLARepository>();
        var communicationClient = iocScope.ServiceProvider.GetRequiredService<ICommunicationClient>();
        
        var pendingReminders = await slaRepository.GetWithPendingFirstReminder(stoppingToken);
        foreach (var reminders in pendingReminders.Where(x => x.UserIdToRemind is not null))
        {
            await communicationClient.SendReminderMessage(
                reminders.UserIdToRemind!.Value, 
                reminders.ServiceType,
                reminders.ServiceSourceId,
                ICommunicationClient.ReminderMessageType.FirstReminder,
                stoppingToken);
            
            reminders.MarkFirstReminderSent();
            /* Explicit decision to use CancellationToken.None - email was already sent so it's better to "force save" */
            await slaRepository.SaveReminders(reminders, CancellationToken.None);
        }
    }

    private async Task SendSecondReminders(CancellationToken stoppingToken)
    {
        using var iocScope = serviceProvider.CreateScope();
        var slaRepository = iocScope.ServiceProvider.GetRequiredService<ISLARepository>();
        var communicationClient = iocScope.ServiceProvider.GetRequiredService<ICommunicationClient>();

        var pendingReminders = await slaRepository.GetWithPendingSecondReminder(stoppingToken);
        foreach (var reminders in pendingReminders.Where(x => x.UserIdToRemind is not null))
        {
            await communicationClient.SendReminderMessage(
                reminders.UserIdToRemind!.Value, 
                reminders.ServiceType,
                reminders.ServiceSourceId,
                ICommunicationClient.ReminderMessageType.SecondReminder,
                stoppingToken);
            
            reminders.MarkSecondReminderSent();
            /* Explicit decision to use CancellationToken.None - email was already sent so it's better to "force save" */
            await slaRepository.SaveReminders(reminders, CancellationToken.None);
        }
    }

    private async Task SendFinalReminders(CancellationToken stoppingToken)
    {
        using var iocScope = serviceProvider.CreateScope();
        var slaRepository = iocScope.ServiceProvider.GetRequiredService<ISLARepository>();
        var communicationClient = iocScope.ServiceProvider.GetRequiredService<ICommunicationClient>();
        
        var pendingReminders = await slaRepository.GetWithPendingFinalReminder(stoppingToken);
        foreach (var reminders in pendingReminders.Where(x => x.UserIdToRemind is not null))
        {
            await communicationClient.SendReminderMessage(
                reminders.UserIdToRemind!.Value, 
                reminders.ServiceType,
                reminders.ServiceSourceId,
                ICommunicationClient.ReminderMessageType.FinalReminder,
                stoppingToken);
            
            reminders.MarkFinalReminderSent();
            /* Explicit decision to use CancellationToken.None - email was already sent so it's better to "force save" */
            await slaRepository.SaveReminders(reminders, CancellationToken.None);
        }
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.CourseUtils;
using TicketFlow.Services.SLA.Core.Data;
using TicketFlow.Services.SLA.Core.Data.Repositories;
using TicketFlow.Services.SLA.Core.Http;
using TicketFlow.Services.SLA.Core.Http.Communication;
using TicketFlow.Services.SLA.Core.Http.Tickets;
using TicketFlow.Services.SLA.Core.Initializers;
using TicketFlow.Services.SLA.Core.Messaging;
using TicketFlow.Services.SLA.Core.Messaging.Consuming;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.ApplicationServices;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.Demultiplexing;
using TicketFlow.Services.SLA.Core.Messaging.Consuming.Partitioning;
using TicketFlow.Services.SLA.Core.Messaging.Publishing.Conventions;
using TicketFlow.Services.SLA.Core.Schedulers;
using TicketFlow.Services.SystemMetrics.Generator;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Deduplication;
using TicketFlow.Shared.Messaging.Ordering.OutOfOrderDetection;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Messaging.Partitioning;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Messaging.Topology;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.SLA.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services
            .AddExceptions()
            .AddApp(configuration)
            .AddSerialization()
            .AddAppInitializers()
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x
                .UseRabbitMq()
                .UseMessagePublisherConvention<SLAMessagePublisherConventionProvider>()
                .UseMessageConsumerConvention<DontUseConventionalTopology>()
                .UseDeduplication()
                .UseOutbox()
                .UseResiliency()
                .UseOutOfOrderDetection()
                .UseAnomalies())
            .AddPostgres<SLADbContext>(configuration)
            .AddSystemMetrics(configuration)
            .AddObservability(configuration);

        services.AddHttpClient<ITicketsClient, TicketsClient>(builder =>
        {
            builder.BaseAddress = new Uri(configuration.GetValue<string>("Services:Tickets"));
        });
        
        services.AddHttpClient<ICommunicationClient, CommunicationsClient>(builder =>
        {
            builder.BaseAddress = new Uri(configuration.GetValue<string>("Services:Communication"));
        });
        
        services.AddHostedService<SLAConsumerService>();
        services.AddHostedService<SLATopologyInitializer>();
        services.AddTransient<ISLARepository, SLARepository>();
        services.AddHostedService<RemindersWatcher>();
        services.AddSingleton(new DeadlineBreachOptions
        {
            WatcherIntervalInSeconds = 5,
            SecondsBetweenBreachAlerts = 120
        });
        services.AddHostedService<DeadlineBreachWatcher>();
        services.AddScoped<TicketService>();
        services.AddScoped<TicketChangesHandler>();

        if (FeatureFlags.UsePartitioningExample)
        {
            // Taken from environment variables or from execution params from CLI
            // EXAMPLE: dotnet run --PartitionNums:0 1 --PartitionNums:1 3
            var partitionNumbers = configuration.GetValue<string>("PartitionNums");
            if (string.IsNullOrEmpty(partitionNumbers))
            {
                partitionNumbers = "1";
            }
            var partitionNumbersParsed = partitionNumbers.Split(',').Select(int.Parse).ToArray();
            
            PartitioningOptions partitioningOpts = PartitioningOptions.Default;

            var section = configuration.GetSection("Partitioning:TicketChanges");
            if (section.Exists())
            {
                section.Bind(partitioningOpts, opts => { opts.BindNonPublicProperties = true; });
            }

            if (FeatureFlags.ExtendPartitioningExample)
            {
                partitionNumbersParsed = Enumerable.Range(1, partitioningOpts.NumberOfPartitions).ToArray();
                partitioningOpts = partitioningOpts with { OnlyOneActiveConsumerPerPartition = false };
            }

            if (partitionNumbers is null || partitionNumbers.Length == 0)
            {
                Console.Error.WriteLine("No partition numbers specified - will choose partition '1' as fallback.");
                partitionNumbersParsed = [1];
            }

            Console.WriteLine(
                $"Partitions handled for {nameof(TicketChangesPartitioningSetup)} are: {string.Join(",", partitionNumbersParsed)}");
            
            services.AddSingleton(new TicketChangesPartitioningSetup(partitionNumbersParsed.ToList(), partitioningOpts));
        }
        else
        {
            services.AddSingleton(new TicketChangesPartitioningSetup(default, default));
        }

        return services;
    }
}
</file>

<file path="src/SLA/TicketFlow.Services.SLA.Core/TicketFlow.Services.SLA.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>disable</Nullable>
    </PropertyGroup>
    
    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.CourseUtils\TicketFlow.CourseUtils.csproj" />
      <ProjectReference Include="..\..\Communication\TicketFlow.Services.Communication.Alerting\TicketFlow.Services.Communication.Alerting.csproj" />
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\..\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
    </ItemGroup>

    <ItemGroup>
      <Folder Include="Data\Migrations\SLA\" />
    </ItemGroup>

</Project>
</file>

<file path="src/SLA/run-migrations.sh">
dotnet ef database update --startup-project ./TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context SLADbContext
dotnet ef database update --startup-project ./TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context DeduplicationDbContext
dotnet ef database update --startup-project ./TicketFlow.Services.SLA.Api/TicketFlow.Services.SLA.Api.csproj --context OutboxDbContext
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:34294",
      "sslPort": 44369
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "http://localhost:5231",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7047;http://localhost:5231",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "App": {
    "AppName" : "metrics-service"
  },
  "Deduplication": {
    "Enabled": false
  },
  "Outbox": {
    "Enabled": false,
    "PublishOnCommit" : true,
    "IntervalMilliseconds" : 3000,
    "BatchSize": 1
  },
  "Postgres": {
    "ConnectionString": "Host=localhost;Database=TicketFlow.SLA;Username=postgres;Password="
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Services": {
    "Tickets": "http://localhost:5112",
    "Communication": "http://localhost:5148"
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 10
    },    
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Api/Program.cs">
using TicketFlow.Services.SystemMetrics.Core;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AspNetCore;

var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddCore(builder.Configuration)
    .AddApiForFrontendConfigured();

var app = builder.Build();

app.ExposeApiForFrontend();
app.UseAnomalyEndpoints();
app.ExposeLiveMetrics();

app.Run();
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Api/TicketFlow.Services.SystemMetrics.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.SystemMetrics.Core\TicketFlow.Services.SystemMetrics.Core.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Core/LiveMetrics/LiveMetricsHub.cs">
using Microsoft.AspNetCore.SignalR;
using TicketFlow.Services.SystemMetrics.Generator.Data;
using TicketFlow.Services.SystemMetrics.Generator.Schedulers;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.SystemMetrics.Core.LiveMetrics;

public class LiveMetricsHub(IMessageConsumer messageConsumer, ITopologyBuilder topologyBuilder) : Hub
{
    public const string LiveMetricsQueue = "live-metrics";
    
    private object _connectLock = new object();
    private int _connectedUsersCount = 0;
    
    // ReSharper disable once InconsistentlySynchronizedField
    public bool HasActiveClients => _connectedUsersCount > 0;

    public override Task OnConnectedAsync()
    {
        lock (_connectLock)
        {
            if (_connectedUsersCount == 0)
            {
                EnsureMetricsQueue();
            }

            _connectedUsersCount++;
        }
        
        return base.OnConnectedAsync();
    }

    public override Task OnDisconnectedAsync(Exception? exception)
    {
        lock (_connectLock)
        {
            _connectedUsersCount--;
        }
        
        return base.OnDisconnectedAsync(exception);
    }

    public async Task PushOldestMetricTick(MetricTick? metricTick)
    {
        if (metricTick == null)
        {
            return;
        }
        await Clients.All.SendAsync("MetricTick", metricTick);
    }

    private void EnsureMetricsQueue()
    {
        topologyBuilder.CreateTopologyAsync(
            publisherSource: RandomMetricsPublisher.MetricsExchange,
            consumerDestination: LiveMetricsQueue,
            TopologyType.PublishSubscribe,
            consumerCustomArgs: new Dictionary<string, object>
            {
                { "x-expires", 1000 * 60 * 1 } // Delete queue if no one is listening after 1min
            }
        ).GetAwaiter().GetResult();
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Core/LiveMetrics/LiveMetricsOptions.cs">
namespace TicketFlow.Services.SystemMetrics.Core.LiveMetrics;

public class LiveMetricsOptions
{
    public int PollingIntervalInMs { get; set; }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Core/LiveMetrics/LiveMetricsPullService.cs">
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.SystemMetrics.Generator.Data;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.SystemMetrics.Core.LiveMetrics;

public class LiveMetricsPullService(IMessageConsumer messageConsumer, LiveMetricsHub hub, LiveMetricsOptions opts) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                if (!hub.HasActiveClients)
                {
                    await Task.Delay(opts.PollingIntervalInMs, stoppingToken);
                    continue;
                }

                await messageConsumer.GetMessage<MetricTick>(
                    handle: async msg => await hub.PushOldestMetricTick(msg),
                    LiveMetricsHub.LiveMetricsQueue,
                    stoppingToken);

                await Task.Delay(opts.PollingIntervalInMs, stoppingToken);
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error while pulling the message from broker: {0}", ex.Message);
            }
        }
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Core/Extensions.cs">
using System.Text.Json;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Routing;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.SystemMetrics.Core.LiveMetrics;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.SystemMetrics.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services
            .AddExceptions()
            .AddSerialization()
            .AddApp(configuration)
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x
                .UseRabbitMq()
                .UseAnomalies()
                .UseResiliency());

        services.AddSignalR()
            .AddJsonProtocol(opt => opt.PayloadSerializerOptions = new JsonSerializerOptions(SerializationOptions.Default));
        
        services.AddSingleton(new LiveMetricsOptions
        {
            PollingIntervalInMs = configuration.GetValue<int?>("LiveMetrics:PollingIntervalInMs") ?? 100
        });
        services.AddSingleton<LiveMetricsHub>();
        services.AddHostedService<LiveMetricsPullService>();
        
        return services;
    }
    
    public static void ExposeLiveMetrics(this IEndpointRouteBuilder endpoints)
    {
        endpoints.MapHub<LiveMetricsHub>("/live-metrics");
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Core/TicketFlow.Services.SystemMetrics.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
    </ItemGroup>

    <ItemGroup>
        <FrameworkReference Include="Microsoft.AspNetCore.App" />
    </ItemGroup>
    
</Project>
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Generator/Data/MetricsGenerator.cs">
using System.Collections.Immutable;

namespace TicketFlow.Services.SystemMetrics.Generator.Data;

public static class MetricsGenerator
{
    private static readonly Random Random = new();

    private const double ServiceDownProbability = 0.2;
    private const int MinRamUsage = 128;
    private const int MaxAvailableRam = 2048;
    private const int MinCpuUsage = 0;
    private const int MaxCpuUsage = 100;
    private const int UnhealthyCpuThreshold = 90;
    private static readonly int UnhealthyRamThreshold = (int)Math.Floor(MaxAvailableRam * 0.9);

    public static MetricTick? GenerateTickForService(string serviceName)
    {
        var utcNow = DateTimeOffset.UtcNow;
        
        var serviceDown = Random.NextDouble() <= ServiceDownProbability;
        if (serviceDown)
        {
            return default;
        }
            
        var cpuValue = Random.Next(MinCpuUsage, MaxCpuUsage + 1);
        var ramValue = Random.Next(MinRamUsage, MaxAvailableRam + 1);
            
        var isHealthy = cpuValue < UnhealthyCpuThreshold && ramValue < UnhealthyRamThreshold;
        var status = isHealthy ? MetricStatus.Healthy : MetricStatus.Error;

        return new MetricTick(
            serviceName,
            status,
            utcNow,
            new Metrics(
                new CpuUsage(cpuValue),
                new MemoryUsage(ramValue, MaxAvailableRam)
            )
        );
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Generator/Data/MetricTick.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Resiliency;

namespace TicketFlow.Services.SystemMetrics.Generator.Data;

public record MetricTick(
    string Name,
    MetricStatus Status,
    DateTimeOffset LastChecked,
    Metrics Metrics) : INonMandatoryMessage;

public record Metrics(CpuUsage Cpu, MemoryUsage Memory);
public record CpuUsage(int Usage);
public record MemoryUsage(int Used, int Total);

public enum MetricStatus
{
    Unknown,
    Healthy,
    Error
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Generator/Schedulers/RandomMetricsPublisher.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.Services.SystemMetrics.Generator.Data;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.SystemMetrics.Generator.Schedulers;

public class RandomMetricsPublisher : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly IOptions<AppOptions> _appOptions;
    private readonly TopologyReadinessAccessor _topologyReadinessAccessor;
    
    public RandomMetricsPublisher(IServiceProvider serviceProvider, IOptions<AppOptions> appOptions)
    {
        _serviceProvider = serviceProvider;
        _appOptions = appOptions;
        _topologyReadinessAccessor = _serviceProvider.GetService<TopologyReadinessAccessor>();
        _topologyReadinessAccessor.MarkTopologyProvisioningStart(GetType().Name);
        
    }

    public const string MetricsExchange = "metrics-exchange";
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        using var iocScope = _serviceProvider.CreateScope();
        var publishers = iocScope.ServiceProvider.GetRequiredService<IEnumerable<IMessagePublisher>>();
        // Unfortunately - we need to be "outbox" aware here to not push transient metric messages through outbox (and "pollute it")
        var publisher = publishers.FirstOrDefault(x => !x.GetType().Name.Contains("Outbox"));
        
        var topologyBuilder = iocScope.ServiceProvider.GetRequiredService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: MetricsExchange,
            consumerDestination: "", // As publisher, we are consumer-ignorant
            TopologyType.PublishSubscribe,
            cancellationToken: stoppingToken
        );
        
        _topologyReadinessAccessor.MarkTopologyProvisioningEnd(GetType().Name);
        
        while (!stoppingToken.IsCancellationRequested)
        {
            var tick = MetricsGenerator.GenerateTickForService(_appOptions.Value.AppName);
            if (tick != null)
            {
                await publisher.PublishAsync(
                    tick, 
                    destination: MetricsExchange, 
                    routingKey: "metric." + _appOptions.Value.AppName, 
                    cancellationToken: stoppingToken);
            }

            await Task.Delay(2000, cancellationToken: stoppingToken);
        }
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Generator/Extensions.cs">
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.SystemMetrics.Generator.Schedulers;

namespace TicketFlow.Services.SystemMetrics.Generator;

public static class Extensions
{
    public static IServiceCollection AddSystemMetrics(this IServiceCollection services, IConfiguration configuration)
    {
        var enabled = configuration.GetValue<bool>("Metrics:Enabled");
        if (!enabled)
        {
            return services;
        }
        
        services.AddHostedService<RandomMetricsPublisher>();
        return services;
    }
}
</file>

<file path="src/SystemMetrics/TicketFlow.Services.SystemMetrics.Generator/TicketFlow.Services.SystemMetrics.Generator.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
    </ItemGroup>
    
</Project>
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/DTO/ClientNoteDto.cs">
namespace TicketFlow.Services.Tickets.Api.DTO;

public record ClientNoteDto(string Note);
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:54538",
      "sslPort": 44346
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5112",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "https://localhost:7273;http://localhost:5212",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "Microsoft.EntityFrameworkCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "App": {
    "AppName" : "tickets-service"
  },
  "Deduplication": {
    "Enabled": false
  },
  "Observability" : {
    "Enabled": false,
    "Endpoint" : "http://localhost:4317"
  },
  "Outbox": {
    "Enabled": false,
    "PublishOnCommit" : true,
    "IntervalMilliseconds" : 3000,
    "BatchSize": 1
  },
  "Postgres": {
    "ConnectionString": "Host=localhost;Database=TicketFlow.Tickets;Username=postgres;Password="
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Metrics": {
    "Enabled": false
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 10
    },
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/Program.cs">
using Microsoft.AspNetCore.Mvc;
using TicketFlow.Services.Tickets.Api.DTO;
using TicketFlow.Services.Tickets.Core;
using TicketFlow.Services.Tickets.Core.Commands.AddClientCommentsToTicket;
using TicketFlow.Services.Tickets.Core.Commands.AssignAgentToTicket;
using TicketFlow.Services.Tickets.Core.Commands.BlockTicket;
using TicketFlow.Services.Tickets.Core.Commands.QualifyTicket;
using TicketFlow.Services.Tickets.Core.Commands.ResolveTicket;
using TicketFlow.Services.Tickets.Core.Commands.UnblockTicket;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Queries.GetClientNotesForTicket;
using TicketFlow.Services.Tickets.Core.Queries.GetTicketDetails;
using TicketFlow.Services.Tickets.Core.Queries.ListAgents;
using TicketFlow.Services.Tickets.Core.Queries.ListTickets;
using TicketFlow.Services.Tickets.Core.SynchronousIntegration;
using TicketFlow.Shared.AnomalyGeneration.HttpApi;
using TicketFlow.Shared.AspNetCore;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Queries;

var builder = WebApplication.CreateBuilder(args);
builder.Services
    .AddCore(builder.Configuration)
    .AddApiForFrontendConfigured();

var app = builder.Build();

app.ExposeApiForFrontend();
app.UseAnomalyEndpoints();

app.MapGet("/", () => "Tickets Service");

app.MapGet("/tickets/",
    async (
        [FromServices] IQueryHandler<ListTicketsQuery, TicketsListDto> handler,
        CancellationToken cancellationToken,
        [FromQuery] Guid? agentId = default,
        [FromQuery] TicketStatus? status = default,
        [FromQuery] int page = 1,
        [FromQuery] int limit = 10) =>
    {
        var query = new ListTicketsQuery(agentId, status, page, limit);
        return await handler.HandleAsync(query, cancellationToken);
    });

app.MapGet("/tickets/{ticketId}/", async (
    [FromServices] IQueryHandler<GetTicketDetailsQuery, TicketDetailsDto> handler,
    CancellationToken cancellationToken,
    [FromRoute] Guid? ticketId) =>
{
    if (ticketId is null)
    {
        return Results.BadRequest();
    }
    var query = new GetTicketDetailsQuery(ticketId.Value);
    return Results.Ok(await handler.HandleAsync(query, cancellationToken));
});

app.MapPost("/tickets/",
    async (
        [FromBody] CreateTicketSynchronously command,
        [FromServices] ICommandHandler<CreateTicketSynchronously> handler,
        CancellationToken cancellationToken) =>
    {
        await handler.HandleAsync(command, cancellationToken);
        return Results.Created();
    });

app.MapPost("/tickets/{ticketId:guid}/qualify", async ([FromRoute] Guid ticketId, [FromBody] QualifyTicket input, 
    [FromServices] ICommandHandler<QualifyTicket> handler, CancellationToken cancellationToken) =>
{
    var command = input with {TicketId = ticketId};
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.MapPost("/tickets/{ticketId:guid}/assign/{agentId:guid}", async ([FromRoute] Guid ticketId, 
    [FromRoute] Guid agentId, [FromServices] ICommandHandler<AssignAgentToTicket> handler, CancellationToken cancellationToken) =>
{
    var command = new AssignAgentToTicket(ticketId, agentId);
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.MapPost("/tickets/{ticketId:guid}/block/{reason}", async ([FromRoute] Guid ticketId, [FromRoute] string reason,
    [FromServices] ICommandHandler<BlockTicket> handler, CancellationToken cancellationToken) =>
{
    var command = new BlockTicket(ticketId, reason);
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.MapPost("/tickets/{ticketId:guid}/unblock/{reason}", async ([FromRoute] Guid ticketId,[FromRoute] string reason,
    [FromServices] ICommandHandler<UnblockTicket> handler, CancellationToken cancellationToken) =>
{
    var command = new UnblockTicket(ticketId, reason);
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.MapPost("/tickets/{ticketId:guid}/resolve/{resolution}", async ([FromRoute] Guid ticketId, [FromRoute] string resolution,
    [FromServices] ICommandHandler<ResolveTicket> handler, CancellationToken cancellationToken) =>
{
    var command = new ResolveTicket(ticketId, resolution);
    await handler.HandleAsync(command, cancellationToken);
    return Results.Ok();
});

app.MapGet("/tickets/{ticketId}/client-notes", async (
    [FromRoute] Guid ticketId, 
    [FromServices] IQueryHandler<GetClientNotesForTicket, string> handler,
    CancellationToken cancellationToken) 
    => await handler.HandleAsync(new GetClientNotesForTicket(ticketId), cancellationToken));

app.MapPost("/tickets/{ticketId}/client-notes", async (
        [FromRoute] Guid ticketId,
        [FromBody] ClientNoteDto dto,
        [FromServices] ICommandHandler<AddClientNoteToTicket> handler,
        CancellationToken cancellationToken) 
    => await handler.HandleAsync(new AddClientNoteToTicket(ticketId, dto.Note), cancellationToken));

app.MapGet("/agents", async (
        [FromServices] IQueryHandler<ListAgentsQuery, AgentDto[]> handler,
        CancellationToken cancellationToken) =>
    await handler.HandleAsync(new ListAgentsQuery(), cancellationToken));

app.MapGet("/agents/{id}", async (
    [FromRoute] string id,
    [FromServices] IQueryHandler<ListAgentsQuery, AgentDto[]> handler,
    CancellationToken cancellationToken) =>
{
    //We have only 3 agents in system, so it's cheaper to just reuse fetching them all
    var allAgents = await handler.HandleAsync(new ListAgentsQuery(), cancellationToken);
    return allAgents.SingleOrDefault(x => x.Id.Equals(id, StringComparison.InvariantCultureIgnoreCase));
});

app.MapGet("/users/{id}", async (
    [FromRoute] string id,
    [FromServices] IQueryHandler<ListAgentsQuery, AgentDto[]> handler,
    CancellationToken cancellationToken) =>
{
    //We have only 3 agents in system, so it's cheaper to just reuse fetching them all
    var allAgents = await handler.HandleAsync(new ListAgentsQuery(), cancellationToken);
    return allAgents.SingleOrDefault(x => x.UserId.Equals(id, StringComparison.InvariantCultureIgnoreCase));
});

app.UseExceptions();
app.Run();
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.Tickets.Core\TicketFlow.Services.Tickets.Core.csproj" />
    </ItemGroup>

    <ItemGroup>
        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="9.0.0">
            <PrivateAssets>all</PrivateAssets>
            <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
        </PackageReference>
    </ItemGroup>
    
</Project>
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Api/tickets-api.http">
@url = http://localhost:5112
@ticketId = 15e663da-d2e3-41db-a3ab-5760b9bbeff8
@agentId = 00000000-0000-0000-0000-000000000001

###
GET {{url}}

###
POST {{url}}/tickets/{{ticketId}}/qualify
Content-Type: application/json

{
  "TicketType": 1
}

###
POST {{url}}/tickets/{{ticketId}}/assign/{{agentId}}
Content-Type: application/json

{
}

###
PUT {{url}}/tickets/{{ticketId}}
Content-Type: application/json

{
  "Notes": "This is note",
  "InternalNotes": "This is internal note"
}

###
POST {{url}}/tickets/{{ticketId}}/resolve/resolution
Content-Type: application/json

{
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/AddClientCommentsToTicket/AddClientCommentsToTicketHandler.cs">
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Services.Tickets.Core.Commands.AddClientCommentsToTicket;

public class AddClientCommentsToTicketHandler(ITicketsRepository repository) : ICommandHandler<AddClientNoteToTicket>
{
    public async Task HandleAsync(AddClientNoteToTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }
        
        ticket.AddClientNote(command.NewNote);
        await repository.UpdateAsync(ticket, cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/AddClientCommentsToTicket/AddClientNoteToTicket.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.AddClientCommentsToTicket;

public record AddClientNoteToTicket(Guid TicketId, string NewNote) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/AssignAgentToTicket/AssignAgentToTicket.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.AssignAgentToTicket;

public sealed record AssignAgentToTicket(Guid TicketId, Guid AgentId) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/AssignAgentToTicket/AssignAgentToTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Initializers;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Commands.AssignAgentToTicket;

internal sealed class AssignAgentToTicketHandler(ITicketsRepository repository, IMessagePublisher publisher,
    ILogger<AssignAgentToTicketHandler> logger) : ICommandHandler<AssignAgentToTicket>
{
    public async Task HandleAsync(AssignAgentToTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }
        
        ticket.AssignTo(command.AgentId);
        await repository.UpdateAsync(ticket, cancellationToken);

        await PublishAgentAssigned(command, cancellationToken, ticket);
        logger.LogInformation($"Assigned agent to ticket with id {ticket.Id} to agent with id {command.AgentId}");
    }

    private async Task PublishAgentAssigned(AssignAgentToTicket command, CancellationToken cancellationToken, Ticket ticket)
    {
        var ticketStatusChanged = new AgentAssignedToTicket(command.TicketId, ticket.Version);
        await publisher.PublishAsync(
            message: ticketStatusChanged, 
            routingKey: "agent-assigned", 
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/BlockTicket/BlockTicket.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.BlockTicket;

public record BlockTicket(Guid TicketId, string Reason) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/BlockTicket/BlockTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Commands.BlockTicket;

public class BlockTicketHandler(ITicketsRepository repository, IMessagePublisher publisher, ILogger<BlockTicketHandler> logger) 
    : ICommandHandler<BlockTicket>
{
    public async Task HandleAsync(BlockTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }

        ticket.Block(command.Reason);
        await repository.UpdateAsync(ticket, cancellationToken);
        
        await PublishTicketBlocked(command, cancellationToken, ticket);
        logger.LogInformation($"Ticket with id {ticket.Id} is now blocked.");
    }

    private async Task PublishTicketBlocked(BlockTicket command, CancellationToken cancellationToken, Ticket ticket)
    {
        var ticketStatusChangedMessage = new TicketBlocked(command.TicketId, ticket.Version);
        await publisher.PublishAsync(
            message: ticketStatusChangedMessage, 
            routingKey: "ticket-blocked", 
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/QualifyTicket/QualifyTicket.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.QualifyTicket;

public sealed record QualifyTicket(Guid TicketId, TicketType TicketType, SeverityLevel SeverityLevel) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/QualifyTicket/QualifyTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Commands.QualifyTicket;

internal sealed class QualifyTicketHandler(ITicketsRepository repository, IMessagePublisher publisher,
    ILogger<QualifyTicketHandler> logger) : ICommandHandler<QualifyTicket>
{
    public async Task HandleAsync(QualifyTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }

        ticket.Qualify(command.TicketType, command.SeverityLevel);
        await repository.UpdateAsync(ticket, cancellationToken);
        
        await PublishTicketQualified(command, cancellationToken, ticket);

        if (ticket.Type is TicketType.Incident)
        {
            await PublishIncidentCreated(cancellationToken, ticket);
        }
        
        logger.LogInformation($"Ticket with id {ticket.Id} has been qualified as {command.TicketType}");
    }

    private async Task PublishIncidentCreated(CancellationToken cancellationToken, Ticket ticket)
    {
        var incidentCreatedMessage = new IncidentCreated(ticket.Id, ticket.Version);
        await publisher.PublishAsync(incidentCreatedMessage, cancellationToken: cancellationToken);
    }

    private async Task PublishTicketQualified(QualifyTicket command, CancellationToken cancellationToken, Ticket ticket)
    {
        var ticketStatusChanged = new TicketQualified(command.TicketId, ticket.Version);
        await publisher.PublishAsync(
            message: ticketStatusChanged, 
            routingKey: "ticket-qualified", 
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/ResolveTicket/ResolveTicket.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.ResolveTicket;

public sealed record ResolveTicket(Guid TicketId, string Resolution) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/ResolveTicket/ResolveTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Commands.ResolveTicket;

internal sealed class ResolveTicketHandler(ITicketsRepository repository, IMessagePublisher publisher,
    ILogger<ResolveTicketHandler> logger) : ICommandHandler<ResolveTicket>
{
    public async Task HandleAsync(ResolveTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }

        ticket.Resolve(command.Resolution);
        await repository.UpdateAsync(ticket, cancellationToken);
        
        await PublishTicketResolved(command, cancellationToken, ticket);
        logger.LogInformation($"Ticket with id {ticket.Id} has been resolved.");
    }

    private async Task PublishTicketResolved(ResolveTicket command, CancellationToken cancellationToken, Ticket ticket)
    {
        var ticketStatusChanged = new TicketResolved(command.TicketId, ticket.Version);
        await publisher.PublishAsync(
            message: ticketStatusChanged, 
            routingKey: "ticket-resolved", 
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/UnblockTicket/UnblockTicket.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.Commands.UnblockTicket;

public record UnblockTicket(Guid TicketId, string Reason) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Commands/UnblockTicket/UnblockTicketHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Commands.UnblockTicket;

public class UnblockTicketHandler(ITicketsRepository repository, IMessagePublisher publisher, ILogger<UnblockTicketHandler> logger) 
    : ICommandHandler<UnblockTicket>
{
    public async Task HandleAsync(UnblockTicket command, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(command.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {command.TicketId} was not found.");
        }

        ticket.Unblock(command.Reason);
        await repository.UpdateAsync(ticket, cancellationToken);

        await PublishTicketUnblocked(ticket, cancellationToken);
        logger.LogInformation($"Ticket with id {ticket.Id} is now unblocked.");
    }
    
    private async Task PublishTicketUnblocked(Ticket ticket, CancellationToken cancellationToken)
    {
        var ticketStatusChanged = new TicketQualified(ticket.Id, ticket.Version);
        await publisher.PublishAsync(
            message: ticketStatusChanged, 
            routingKey: "ticket-qualified", 
            cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Configurations/AgentConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data.Configurations;

internal sealed class AgentConfiguration : IEntityTypeConfiguration<Agent>
{
    public void Configure(EntityTypeBuilder<Agent> builder)
    {
        builder.HasKey(x => x.Id);
        builder
            .HasMany(x => x.Tickets)
            .WithOne(x => x.AssignedAgent)
            .HasForeignKey(x => x.AssignedTo);
        builder.Property(x => x.FullName).IsRequired();
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Configurations/TicketConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data.Configurations;

internal sealed class TicketConfiguration : IEntityTypeConfiguration<Ticket>
{
    public void Configure(EntityTypeBuilder<Ticket> builder)
    {
        builder.HasKey(x => x.Id);
        builder.Property(x => x.Name).IsRequired();
        builder.Property(x => x.Email).IsRequired();
        builder.Property(x => x.Description).IsRequired();
        builder.Property(x => x.LanguageCode).IsRequired();
        builder.Property(x => x.CreatedAt).IsRequired();
        builder.Property(x => x.Version).IsRequired();
        builder.Property(x => x.Type).HasConversion(x => x.ToString(), x => Enum.Parse<TicketType>(x));
        builder.Property(x => x.Status).HasConversion(x => x.ToString(), x => Enum.Parse<TicketStatus>(x));
        builder.Property(x => x.Resolution).IsRequired(false);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Configurations/TicketScheduledActionConfiguration.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data.Configurations;

public class TicketScheduledActionConfiguration : IEntityTypeConfiguration<TicketScheduledAction>
{
    public void Configure(EntityTypeBuilder<TicketScheduledAction> builder)
    {
        builder.HasKey(x => x.Id);
        builder.Property(x => x.TranslatedText).IsRequired();
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241110130614_Init.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Init : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.EnsureSchema(
                name: "tickets");

            migrationBuilder.CreateTable(
                name: "Agents",
                schema: "tickets",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    FullName = table.Column<string>(type: "text", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Agents", x => x.Id);
                });

            migrationBuilder.CreateTable(
                name: "Tickets",
                schema: "tickets",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    Name = table.Column<string>(type: "text", nullable: false),
                    Email = table.Column<string>(type: "text", nullable: false),
                    Description = table.Column<string>(type: "text", nullable: false),
                    LanguageCode = table.Column<string>(type: "text", nullable: false),
                    CreatedAt = table.Column<DateTimeOffset>(type: "timestamp with time zone", nullable: false),
                    Type = table.Column<string>(type: "text", nullable: false),
                    Status = table.Column<string>(type: "text", nullable: false),
                    TranslatedDescription = table.Column<string>(type: "text", nullable: true),
                    Notes = table.Column<string>(type: "text", nullable: true),
                    InternalNotes = table.Column<string>(type: "text", nullable: true),
                    AssignedTo = table.Column<Guid>(type: "uuid", nullable: true)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Tickets", x => x.Id);
                    table.ForeignKey(
                        name: "FK_Tickets_Agents_AssignedTo",
                        column: x => x.AssignedTo,
                        principalSchema: "tickets",
                        principalTable: "Agents",
                        principalColumn: "Id");
                });

            migrationBuilder.CreateIndex(
                name: "IX_Tickets_AssignedTo",
                schema: "tickets",
                table: "Tickets",
                column: "AssignedTo");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Tickets",
                schema: "tickets");

            migrationBuilder.DropTable(
                name: "Agents",
                schema: "tickets");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241110130614_Init.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241110130614_Init")]
    partial class Init
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241117173901_Agent_Details.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Agent_Details : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "AvatarUrl",
                schema: "tickets",
                table: "Agents",
                type: "text",
                nullable: false,
                defaultValue: "");

            migrationBuilder.AddColumn<int>(
                name: "JobPosition",
                schema: "tickets",
                table: "Agents",
                type: "integer",
                nullable: false,
                defaultValue: 0);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "AvatarUrl",
                schema: "tickets",
                table: "Agents");

            migrationBuilder.DropColumn(
                name: "JobPosition",
                schema: "tickets",
                table: "Agents");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241117173901_Agent_Details.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241117173901_Agent_Details")]
    partial class Agent_Details
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241117203736_Tickets_FE_Listing.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Tickets_FE_Listing : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "Type",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: true,
                oldClrType: typeof(string),
                oldType: "text");

            migrationBuilder.AddColumn<int>(
                name: "Category",
                schema: "tickets",
                table: "Tickets",
                type: "integer",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.AddColumn<int>(
                name: "Severity",
                schema: "tickets",
                table: "Tickets",
                type: "integer",
                nullable: true);

            migrationBuilder.AddColumn<string>(
                name: "Title",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: false,
                defaultValue: "");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Category",
                schema: "tickets",
                table: "Tickets");

            migrationBuilder.DropColumn(
                name: "Severity",
                schema: "tickets",
                table: "Tickets");

            migrationBuilder.DropColumn(
                name: "Title",
                schema: "tickets",
                table: "Tickets");

            migrationBuilder.AlterColumn<string>(
                name: "Type",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "text",
                oldNullable: true);
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241117203736_Tickets_FE_Listing.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241117203736_Tickets_FE_Listing")]
    partial class Tickets_FE_Listing
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241207153411_Added_Scheduled_Actions.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Added_Scheduled_Actions : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "TicketScheduledActions",
                schema: "tickets",
                columns: table => new
                {
                    Id = table.Column<Guid>(type: "uuid", nullable: false),
                    TranslatedText = table.Column<string>(type: "text", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_TicketScheduledActions", x => x.Id);
                });
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "TicketScheduledActions",
                schema: "tickets");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241207153411_Added_Scheduled_Actions.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241207153411_Added_Scheduled_Actions")]
    partial class Added_Scheduled_Actions
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241207160214_Added_Ticket_Version.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Added_Ticket_Version : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<int>(
                name: "Version",
                schema: "tickets",
                table: "Tickets",
                type: "integer",
                nullable: false,
                defaultValue: 0);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Version",
                schema: "tickets",
                table: "Tickets");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241207160214_Added_Ticket_Version.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241207160214_Added_Ticket_Version")]
    partial class Added_Ticket_Version
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241218194154_Agent_UserId.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Agent_UserId : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<Guid>(
                name: "UserId",
                schema: "tickets",
                table: "Agents",
                type: "uuid",
                nullable: false,
                defaultValue: new Guid("00000000-0000-0000-0000-000000000000"));
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "UserId",
                schema: "tickets",
                table: "Agents");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241218194154_Agent_UserId.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241218194154_Agent_UserId")]
    partial class Agent_UserId
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241221215746_DeadlineUtc.cs">
using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class DeadlineUtc : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<DateTimeOffset>(
                name: "DeadlineUtc",
                schema: "tickets",
                table: "Tickets",
                type: "timestamp with time zone",
                nullable: true);
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "DeadlineUtc",
                schema: "tickets",
                table: "Tickets");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241221215746_DeadlineUtc.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241221215746_DeadlineUtc")]
    partial class DeadlineUtc
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("DeadlineUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241223124917_Ticket_Resolution.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Ticket_Resolution : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AddColumn<string>(
                name: "Resolution",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: false,
                defaultValue: "");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropColumn(
                name: "Resolution",
                schema: "tickets",
                table: "Tickets");
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241223124917_Ticket_Resolution.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241223124917_Ticket_Resolution")]
    partial class Ticket_Resolution
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "8.0.10")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("DeadlineUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<string>("Resolution")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241227171939_Nullable_Resolution.cs">
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    /// <inheritdoc />
    public partial class Nullable_Resolution : Migration
    {
        /// <inheritdoc />
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "Resolution",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: true,
                oldClrType: typeof(string),
                oldType: "text");
        }

        /// <inheritdoc />
        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.AlterColumn<string>(
                name: "Resolution",
                schema: "tickets",
                table: "Tickets",
                type: "text",
                nullable: false,
                defaultValue: "",
                oldClrType: typeof(string),
                oldType: "text",
                oldNullable: true);
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/20241227171939_Nullable_Resolution.Designer.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Migrations;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    [Migration("20241227171939_Nullable_Resolution")]
    partial class Nullable_Resolution
    {
        /// <inheritdoc />
        protected override void BuildTargetModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("DeadlineUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<string>("Resolution")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/Tickets/TicketsDbContextModelSnapshot.cs">
// <auto-generated />
using System;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using TicketFlow.Services.Tickets.Core.Data;

#nullable disable

namespace TicketFlow.Services.Tickets.Core.Data.Migrations.Tickets
{
    [DbContext(typeof(TicketsDbContext))]
    partial class TicketsDbContextModelSnapshot : ModelSnapshot
    {
        protected override void BuildModel(ModelBuilder modelBuilder)
        {
#pragma warning disable 612, 618
            modelBuilder
                .HasDefaultSchema("tickets")
                .HasAnnotation("ProductVersion", "9.0.0")
                .HasAnnotation("Relational:MaxIdentifierLength", 63);

            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("AvatarUrl")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("FullName")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<int>("JobPosition")
                        .HasColumnType("integer");

                    b.Property<Guid>("UserId")
                        .HasColumnType("uuid");

                    b.HasKey("Id");

                    b.ToTable("Agents", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<Guid?>("AssignedTo")
                        .HasColumnType("uuid");

                    b.Property<int>("Category")
                        .HasColumnType("integer");

                    b.Property<DateTimeOffset>("CreatedAt")
                        .HasColumnType("timestamp with time zone");

                    b.Property<DateTimeOffset?>("DeadlineUtc")
                        .HasColumnType("timestamp with time zone");

                    b.Property<string>("Description")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Email")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("InternalNotes")
                        .HasColumnType("text");

                    b.Property<string>("LanguageCode")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Name")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Notes")
                        .HasColumnType("text");

                    b.Property<string>("Resolution")
                        .HasColumnType("text");

                    b.Property<int?>("Severity")
                        .HasColumnType("integer");

                    b.Property<string>("Status")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("Title")
                        .IsRequired()
                        .HasColumnType("text");

                    b.Property<string>("TranslatedDescription")
                        .HasColumnType("text");

                    b.Property<string>("Type")
                        .HasColumnType("text");

                    b.Property<int>("Version")
                        .HasColumnType("integer");

                    b.HasKey("Id");

                    b.HasIndex("AssignedTo");

                    b.ToTable("Tickets", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.TicketScheduledAction", b =>
                {
                    b.Property<Guid>("Id")
                        .ValueGeneratedOnAdd()
                        .HasColumnType("uuid");

                    b.Property<string>("TranslatedText")
                        .IsRequired()
                        .HasColumnType("text");

                    b.HasKey("Id");

                    b.ToTable("TicketScheduledActions", "tickets");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Ticket", b =>
                {
                    b.HasOne("TicketFlow.Services.Tickets.Core.Data.Models.Agent", "AssignedAgent")
                        .WithMany("Tickets")
                        .HasForeignKey("AssignedTo");

                    b.Navigation("AssignedAgent");
                });

            modelBuilder.Entity("TicketFlow.Services.Tickets.Core.Data.Models.Agent", b =>
                {
                    b.Navigation("Tickets");
                });
#pragma warning restore 612, 618
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Migrations/scripts.txt">
// Create migration for Tickets schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Tickets --startup-project ./../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context TicketsDbContext

// Apply migration for Tickets schema
dotnet ef database update --startup-project ../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context TicketsDbContext

// Create migration for Deduplication schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Deduplication --startup-project ./../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context DeduplicationDbContext

// Apply migration for Deduplication schema
dotnet ef database update --startup-project ../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context DeduplicationDbContext

// Create migration for Outbox schema
dotnet ef migrations add <name_of_migration> -o ./Data/Migrations/Outbox --startup-project ./../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context OutboxDbContext

// Apply migration for Outbox schema
dotnet ef database update --startup-project ../TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context OutboxDbContext
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/Agent.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public class Agent
{
    public Guid Id { get; private set; }
    public Guid UserId { get; private set; }
    public string FullName { get; private set; }
    public AgentPosition JobPosition { get; private set; }
    public string AvatarUrl { get; private set; }
    public ICollection<Ticket> Tickets { get; }

    private Agent()
    {
    }

    public Agent(Guid id, Guid userId, string fullName, AgentPosition jobPosition, string avatarUrl)
    {
        Id = id;
        UserId = userId;
        FullName = fullName;
        JobPosition = jobPosition;
        AvatarUrl = avatarUrl;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/AgentPosition.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum AgentPosition
{
    Agent,
    Supervisor
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/SeverityLevel.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum SeverityLevel
{
    Low,
    Medium,
    High,
    Critical
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/Ticket.cs">
using TicketFlow.Shared.Exceptions;

namespace TicketFlow.Services.Tickets.Core.Data.Models;

public sealed class Ticket
{
    public Guid Id { get; }
    public string Name { get; }
    public string Email { get; }
    public string Title { get; private set; }
    public string Description { get; }
    public string LanguageCode { get; }
    public DateTimeOffset CreatedAt { get; }

    public TicketType? Type { get; private set; }
    public TicketStatus Status { get; private set; }
    public SeverityLevel? Severity { get; private set; }
    public TicketCategory Category { get; private set; } = TicketCategory.Other;
    public string? TranslatedDescription { get; private set; }
    public string? Notes { get; private set; }
    public string? InternalNotes { get; private set; }
    public Guid? AssignedTo { get; private set; }
    public int Version { get; private set; }
    public DateTimeOffset? DeadlineUtc { get; private set; }
    public string? Resolution { get; private set; }

    private bool _versionAlreadyChanged;
    
    public Agent? AssignedAgent { get; private set; }
    
    public bool IsEnglish => LanguageCode is "en";

    private Ticket()
    {
    }

    public Ticket(Guid id, string name, string email, string title, string description, TicketCategory category, string languageCode)
    {
        Id = id;
        Name = name;
        Email = email;
        Title = title;
        Description = description;
        LanguageCode = languageCode;
        Status = TicketStatus.BeforeQualification;
        Category = category;
        CreatedAt = DateTimeOffset.UtcNow;
        Version = 1;
        _versionAlreadyChanged = true;
    }

    public void SetTranslation(string translatedDescription)
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot set translation after the ticket is resolved.");
        }
        
        TranslatedDescription = translatedDescription;
        IncreaseVersion();
    }

    public void SetInternalNotes(string internalNotes)
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot set notes after the ticket is resolved.");
        }
        
        InternalNotes = internalNotes;
        IncreaseVersion();
    }

    public void AddInternalNote(string newNote)
    {
        SetInternalNotes(InternalNotes + Environment.NewLine + $"[{DateTimeOffset.UtcNow.ToString("s")}] {newNote}");
    }

    public void AddClientNote(string newNote)
    {
        if (string.IsNullOrEmpty(Notes))
        {
            Notes = $"[{DateTimeOffset.UtcNow.ToString("O")}] {newNote}";
            return;
        }
        
        Notes += Environment.NewLine + $"[{DateTimeOffset.UtcNow.ToString("s")}] {newNote}";
    }

    public void AssignTo(Guid agentId)
    {
        if (Status is TicketStatus.BeforeQualification or TicketStatus.WaitingForScheduledAction or TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot assign agent before qualification or after the ticket is resolved.");
        }
        
        if (AssignedTo is not null)
        {
            throw new TicketFlowException("Cannot reassign agent.");
        }
        
        AssignedTo = agentId;
        IncreaseVersion();
    }

    public void WaitForScheduledActions()
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot set ticket for scheduled action after is resolved.");
        }
        
        Status = TicketStatus.WaitingForScheduledAction;
        IncreaseVersion();
    }
    
    public void SetBeforeQualification()
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot set ticket as before qualification after is resolved.");
        }
        
        Status = TicketStatus.BeforeQualification;
        IncreaseVersion();
    }

    public void Resolve(string resolution)
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot change ticket after is resolved.");
        }
        
        AddInternalNote($"RESOLVED BY: {AssignedAgent?.FullName}");
        Resolution = resolution;
        Status = TicketStatus.Resolved;
        IncreaseVersion();
    }

    public void Block(string? reason = null)
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot change ticket after is resolved.");
        }
        
        Status = TicketStatus.Blocked;
        if (reason is not null)
        {
            AddInternalNote("BLOCKED: " + reason);
        }
        IncreaseVersion();
    }
    
    public void Unblock(string? reason = null)
    {
        if (Status is TicketStatus.Resolved)
        {
            throw new TicketFlowException("Cannot change ticket after is resolved.");
        }
        
        Status = TicketStatus.Qualified;
        if (reason is not null)
        {
            AddInternalNote("UNBLOCKED: " + reason);
        }
        IncreaseVersion();
    }
    
    public void Qualify(TicketType ticketType, SeverityLevel severityLevel)
    {
        if (Status is not TicketStatus.BeforeQualification)
        {
            throw new TicketFlowException("Ticket type must be before before qualification.");
        }
        
        Type = ticketType;
        Severity = severityLevel;
        Status = TicketStatus.Qualified;
        IncreaseVersion();
    }

    public void SetCalculatedDeadline(DateTimeOffset deadline)
    {
        DeadlineUtc = deadline;
        IncreaseVersion();
    }

    private void IncreaseVersion()
    {
        if (_versionAlreadyChanged)
        {
            return;
        }
        
        _versionAlreadyChanged = true;
        Version++;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/TicketCategory.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum TicketCategory
{
    General,
    Technical,
    Billing,
    Other
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/TicketStatus.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum TicketStatus : byte
{
    Unknown = 0,
    WaitingForScheduledAction = 1,
    BeforeQualification = 2,
    Qualified = 3,
    Resolved = 4,
    Blocked = 5
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/TicketTranslation.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public class TicketScheduledAction
{
    public Guid Id { get; }
    public string TranslatedText { get; }

    private TicketScheduledAction()
    {
    }

    public TicketScheduledAction(Guid id, string translatedText)
    {
        Id = id;
        TranslatedText = translatedText;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Models/TicketType.cs">
namespace TicketFlow.Services.Tickets.Core.Data.Models;

public enum TicketType : byte
{
    Unknown = 0,
    Incident = 1,
    Question = 2
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Repositories/ITicketsRepository.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data.Repositories;

public interface ITicketsRepository
{
    Task<Ticket?> GetAsync(Guid id, CancellationToken cancellationToken = default);
    Task<bool> ExistsAsync(Guid id, CancellationToken cancellationToken = default);
    Task AddAsync(Ticket ticket, CancellationToken cancellationToken = default);
    Task UpdateAsync(Ticket ticket, CancellationToken cancellationToken = default);
    Task AddScheduledAction(TicketScheduledAction ticketScheduledAction, CancellationToken cancellationToken = default);
    Task<TicketScheduledAction?> GetScheduledAction(Guid id, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/Repositories/TicketsRepository.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data.Repositories;

internal sealed class TicketsRepository(TicketsDbContext dbContext) : ITicketsRepository
{
    public async Task<Ticket?> GetAsync(Guid id, CancellationToken cancellationToken = default)
        => await dbContext.Tickets.SingleOrDefaultAsync(x => x.Id == id, cancellationToken);

    public async Task<bool> ExistsAsync(Guid id, CancellationToken cancellationToken = default)
        => await dbContext.Tickets.AnyAsync(x => x.Id == id, cancellationToken);

    public async Task AddAsync(Ticket ticket, CancellationToken cancellationToken = default)
    {
        await dbContext.Tickets.AddAsync(ticket, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
    }

    public async Task UpdateAsync(Ticket ticket, CancellationToken cancellationToken = default)
    {
        dbContext.Tickets.Update(ticket);
        await dbContext.SaveChangesAsync(cancellationToken);
    }

    public async Task AddScheduledAction(TicketScheduledAction ticketScheduledAction, CancellationToken cancellationToken = default)
    {
        await dbContext.TicketScheduledActions.AddAsync(ticketScheduledAction, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
    }

    public async Task<TicketScheduledAction?> GetScheduledAction(Guid id, CancellationToken cancellationToken = default)
        => await dbContext.TicketScheduledActions.SingleOrDefaultAsync(x => x.Id == id, cancellationToken);
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Data/TicketsDbContext.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Data;

public sealed class TicketsDbContext(DbContextOptions<TicketsDbContext> options) : DbContext(options)
{
    public DbSet<Ticket> Tickets { get; set; }
    public DbSet<TicketScheduledAction> TicketScheduledActions { get; set; }
    public DbSet<Agent> Agents { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(GetType().Assembly);
        modelBuilder.HasDefaultSchema("tickets");
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Initializers/AgentsAppInitializer.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Tickets.Core.Data;
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Initializers;

internal sealed class AgentsAppInitializer(IServiceProvider serviceProvider) : IHostedService
{
    public async Task StartAsync(CancellationToken cancellationToken)
    {
        var scope = serviceProvider.CreateScope();
        var dbContext = scope.ServiceProvider.GetRequiredService<TicketsDbContext>();
        var logger = scope.ServiceProvider.GetRequiredService<ILogger<AgentsAppInitializer>>();
        
        await dbContext.Database.EnsureCreatedAsync(cancellationToken);

        if (await dbContext.Agents.AnyAsync(cancellationToken))
        {
            logger.LogInformation("Agents are already initialized. Skipping further initialization.");
            return;
        }

        var agents = new List<Agent>
        {
            new(
                new Guid("00000000-0000-0000-0000-000000000001"),
                new Guid("00000000-0000-0000-0000-000000000001"),
                "Bogusław Złotówa",
                AgentPosition.Supervisor,
                "https://api.dicebear.com/9.x/notionists/svg?seed=Boguslaw&radius=50"),
            new(
                new Guid("00000000-0000-0000-0000-000000000002"), 
                new Guid("00000000-0000-0000-0000-000000000002"), 
                "Ziemowit Pędziwiatr",
                AgentPosition.Agent,
                "https://api.dicebear.com/9.x/notionists/svg?seed=Ziemowit&radius=50"),
            new (
                new Guid("00000000-0000-0000-0000-000000000003"), 
                new Guid("00000000-0000-0000-0000-000000000003"), 
                "Kunegunda Śmieszek",
                AgentPosition.Agent,
                "https://api.dicebear.com/9.x/notionists/svg?seed=Kunegunda&radius=50"),
        };
        
        await dbContext.AddRangeAsync(agents, cancellationToken);
        await dbContext.SaveChangesAsync(cancellationToken);
        logger.LogInformation("Agents initialized successfully.");
    }

    public Task StopAsync(CancellationToken cancellationToken)
        => Task.CompletedTask;
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Initializers/Extensions.cs">
using Microsoft.Extensions.DependencyInjection;

namespace TicketFlow.Services.Tickets.Core.Initializers;

public static class Extensions
{
    public static IServiceCollection AddAppInitializers(this IServiceCollection services)
    {
        services.AddHostedService<AgentsAppInitializer>();
        return services;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/DeadlinesCalculated/DeadlinesCalculated.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.DeadlinesCalculated;

public record DeadlinesCalculated(string ServiceType, string ServiceSourceId, DateTimeOffset DeadlineUtc) : IMessage;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/DeadlinesCalculated/DeadlinesCalculatedHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.DeadlinesCalculated;

public class DeadlinesCalculatedHandler(ITicketsRepository repository, ILogger<DeadlinesCalculatedHandler> logger) : IMessageHandler<DeadlinesCalculated>
{
    public async Task HandleAsync(DeadlinesCalculated message, CancellationToken cancellationToken = default)
    {
        if (!message.ServiceType.Contains("Ticket"))
        {
            logger.LogInformation("Ignored deadline for service type that is not ticket: {type}", message.ServiceType);
            return;
        }

        var matchingTicket = await repository.GetAsync(Guid.Parse(message.ServiceSourceId), cancellationToken);

        if (matchingTicket is null)
        {
            throw new TicketFlowException($"Ticket not found for id: {message.ServiceSourceId}");
        }
        
        matchingTicket.SetCalculatedDeadline(message.DeadlineUtc);
        
        await repository.UpdateAsync(matchingTicket, cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/InquirySubmitted/InquirySubmitted.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.InquirySubmitted;

public sealed record InquirySubmitted(Guid Id, string Name, string Email, string Title, string Description, string Category, string LanguageCode, DateTimeOffset CreatedAt) : IMessage;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/InquirySubmitted/InquirySubmittedHandler.cs">
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.InquirySubmitted;

public sealed class InquirySubmittedHandler(ITicketsRepository repository, IMessagePublisher messagePublisher) : IMessageHandler<InquirySubmitted>
{
    public async Task HandleAsync(InquirySubmitted message, CancellationToken cancellationToken = default)
    {
        if (!FeatureFlags.UseListenToYourselfExample)
        {
            await HandleDefault(message, cancellationToken);
        }
        else
        {
            await HandleWithListenToYourself(message, cancellationToken);
        }
    }

    private async Task HandleDefault(InquirySubmitted message, CancellationToken cancellationToken)
    {
        var (id, name, email, title, description, category, languageCode, _) = message;

        if (await repository.ExistsAsync(id, cancellationToken))
        {
            return;
        }

        var categoryValid = Enum.TryParse<TicketCategory>(category, out var categoryParsed);
        if (categoryValid is false)
        {
            categoryParsed = TicketCategory.Other;
        }
        
        var ticket = new Ticket(id, name, email, title, description, categoryParsed, languageCode);
        
        var scheduledAction = await repository.GetScheduledAction(message.Id, cancellationToken);

        if (scheduledAction is not null)
        {
            ticket.SetTranslation(scheduledAction.TranslatedText);
        }
        else if (ticket.IsEnglish is false)
        {
            ticket.WaitForScheduledActions();
        }
        
        await repository.AddAsync(ticket, cancellationToken);

        var ticketCreatedMessage = new Publishing.TicketCreated(
            Id: ticket.Id, 
            InquiryId: message.Id, 
            Name: ticket.Name,
            Email: ticket.Email,
            Title: ticket.Title,
            Description: ticket.Description,
            Category: ticket.Category.ToString(),
            LanguageCode: ticket.LanguageCode);
        
        await messagePublisher.PublishAsync(ticketCreatedMessage, cancellationToken: cancellationToken);
    }
    
    private async Task HandleWithListenToYourself(InquirySubmitted message, CancellationToken cancellationToken)
    {
        var (id, name, email, title, description, category, languageCode, _) = message;

        if (await repository.ExistsAsync(id, cancellationToken))
        {
            return;
        }

        var categoryValid = Enum.TryParse<TicketCategory>(category, out var categoryParsed);
        if (categoryValid is false)
        {
            categoryParsed = TicketCategory.Other;
        }
        
        var ticket = new Ticket(Guid.NewGuid(), name, email, title, description, categoryParsed, languageCode);
        
        var scheduledAction = await repository.GetScheduledAction(message.Id, cancellationToken);

        if (scheduledAction is not null)
        {
            ticket.SetTranslation(scheduledAction.TranslatedText);
        }
        else if (ticket.IsEnglish is false)
        {
            ticket.WaitForScheduledActions();
        }

        var ticketCreatedMessage = new Publishing.TicketCreated(
            Id: ticket.Id, 
            InquiryId: message.Id, 
            Name: ticket.Name,
            Email: ticket.Email,
            Title: ticket.Title,
            Description: ticket.Description,
            Category: ticket.Category.ToString(),
            LanguageCode: ticket.LanguageCode);
        
        await messagePublisher.PublishAsync(ticketCreatedMessage, cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/TicketCreated/TicketCreatedHandler.cs">
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.TicketCreated;

public class TicketCreatedHandler(ITicketsRepository repository) : IMessageHandler<Publishing.TicketCreated>
{
    public async Task HandleAsync(Publishing.TicketCreated message, CancellationToken cancellationToken = default)
    {
        if (!FeatureFlags.UseListenToYourselfExample)
        {
            return;
        }
        
        var categoryValid = Enum.TryParse<TicketCategory>(message.Category, out var categoryParsed);
        if (categoryValid is false)
        {
            categoryParsed = TicketCategory.Other;
        }
        
        var ticket = new Ticket(message.Id, message.Name, message.Email, message.Title, message.Description, categoryParsed, message.LanguageCode);
        
        var scheduledAction = await repository.GetScheduledAction(message.Id, cancellationToken);

        if (scheduledAction is not null)
        {
            ticket.SetTranslation(scheduledAction.TranslatedText);
        }
        else if (ticket.IsEnglish is false)
        {
            ticket.WaitForScheduledActions();
        }
        
        await repository.AddAsync(ticket, cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/TranslationCompleted/TranslationCompleted.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.TranslationCompleted;

public record TranslationCompleted(string OriginalText, string TranslatedText, Guid ReferenceId) : IMessage;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Consuming/TranslationCompleted/TranslationCompletedHandler.cs">
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Consuming.TranslationCompleted;

internal sealed class TranslationCompletedHandler(ITicketsRepository repository, ILogger<TranslationCompletedHandler> logger) 
    : IMessageHandler<TranslationCompleted>
{
    public async Task HandleAsync(TranslationCompleted message, CancellationToken cancellationToken = default)
    {
        logger.LogInformation($"Translation completed for ticket {message.ReferenceId}");

        var ticket = await repository.GetAsync(message.ReferenceId, cancellationToken);

        if (ticket is null)
        {
            var scheduledAction = new TicketScheduledAction(message.ReferenceId, message.TranslatedText);
            
            await repository.AddScheduledAction(scheduledAction, cancellationToken);
            logger.LogInformation($"Ticket {message.ReferenceId} was not found. Creating a scheduled action snapshot.");

            return;
        }
        
        ticket.SetTranslation(message.TranslatedText);
        ticket.SetBeforeQualification();
        
        await repository.UpdateAsync(ticket, cancellationToken);
        logger.LogInformation($"Ticket {message.ReferenceId} was found. Updated with translation.");
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/Conventions/TicketsMessagePublisherConventionProvider.cs">
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing.Conventions;

internal sealed class TicketsMessagePublisherConventionProvider : IMessagePublisherConventionProvider
{
    public const string ExchangeName = "tickets-exchange";
    
    public (string destination, string routingKey) Get<TMessage>() where TMessage : class, IMessage 
        => (ExchangeName, PascalToKebabCase(typeof(TMessage).Name).WithAlertingApplied<TMessage>());

    private static string PascalToKebabCase(string str)
    {
        return string.Concat(str.SelectMany(ConvertChar));

        IEnumerable<char> ConvertChar(char c, int index)
        {
            if (char.IsUpper(c) && index != 0) yield return '-';
            yield return char.ToLower(c);
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/AgentAssignedToTicket.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record AgentAssignedToTicket(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/IncidentCreated.cs">
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record IncidentCreated(Guid TicketId, int Version) : IAlertMessage, IMessageWithPartitionKey
{
    public string AlertMessageContent => $"Utworzono incydent - identyfikator ticketa: {TicketId}";
    public string AlertType => "Incydent";
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/TicketBlocked.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record TicketBlocked(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/TicketCreated.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record TicketCreated(
    Guid Id, 
    Guid InquiryId,
    string Name,
    string Email,
    string Title,
    string Description,
    string Category,
    string LanguageCode,
    int Version = 1) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => Id.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/TicketQualified.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record TicketQualified(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/Publishing/TicketResolved.cs">
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Partitioning;

namespace TicketFlow.Services.Tickets.Core.Messaging.Publishing;

public record TicketResolved(Guid TicketId, int Version) : IMessage, IMessageWithPartitionKey
{
    public string PartitionKey => TicketId.ToString();
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/TicketsConsumerService.cs">
using Microsoft.Extensions.Hosting;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Tickets.Core.Messaging.Consuming.DeadlinesCalculated;
using TicketFlow.Services.Tickets.Core.Messaging.Consuming.InquirySubmitted;
using TicketFlow.Services.Tickets.Core.Messaging.Consuming.TranslationCompleted;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Tickets.Core.Messaging;

internal sealed class TicketsConsumerService(IMessageConsumer messageConsumer, AnomalySynchronizationConfigurator anomalyConfigurator) : BackgroundService
{
    public const string SLAChangesQueue = "tickets-sla-changes";
    public const string TicketCreatedQueue = "tickets-ticket-created";
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        await messageConsumer.ConsumeMessage<InquirySubmitted>();
        await messageConsumer.ConsumeMessage<TranslationCompleted>();
        await messageConsumer.ConsumeMessage<DeadlinesCalculated>(queue: SLAChangesQueue, acceptedMessageTypes: ["DeadlinesCalculated"]);
        if (FeatureFlags.UseListenToYourselfExample)
        {
            await messageConsumer.ConsumeMessage<TicketCreated>(queue: TicketCreatedQueue, acceptedMessageTypes: ["TicketCreated"]);
        }
        await anomalyConfigurator.ConsumeAnomalyChanges();
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Messaging/TicketsTopologyInitializer.cs">
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using TicketFlow.CourseUtils;
using TicketFlow.Services.Communication.Alerting;
using TicketFlow.Services.Tickets.Core.Messaging.Consuming.TicketCreated;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing.Conventions;
using TicketFlow.Shared.AnomalyGeneration.MessagingApi;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.Tickets.Core.Messaging;

public class TicketsTopologyInitializer : TopologyInitializerBase
{
    public TicketsTopologyInitializer(IServiceProvider serviceProvider) : base(serviceProvider){}

    protected override async Task CreateTopologyAsync(CancellationToken stoppingToken)
    {
        await CreateAlertingTopology(stoppingToken);
        await CreateAnomalySynchronizationTopology(stoppingToken);

        var topologyBuilder = ServiceProvider.GetService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: TicketsMessagePublisherConventionProvider.ExchangeName,
            consumerDestination: "", // As publisher, we are consumer-ignorant
            TopologyType.PublishSubscribe,
            cancellationToken: stoppingToken
        );

        await topologyBuilder.CreateTopologyAsync(
            publisherSource: "sla-exchange",
            consumerDestination: TicketsConsumerService.SLAChangesQueue,
            TopologyType.PublishSubscribe,
            cancellationToken: stoppingToken);

        if (FeatureFlags.UseListenToYourselfExample)
        {
            await topologyBuilder.CreateTopologyAsync(
                publisherSource: TicketsMessagePublisherConventionProvider.ExchangeName,
                consumerDestination: TicketsConsumerService.TicketCreatedQueue,
                TopologyType.PublishSubscribe,
                cancellationToken: stoppingToken);
        }
    }
    
    private async Task CreateAlertingTopology(CancellationToken stoppingToken)
    {
        var alertingTopologyBuilder = new AlertingTopologyBuilder(
            ServiceProvider.GetService<ITopologyBuilder>(),
            ServiceProvider.GetService<IMessagePublisherConventionProvider>());

        await alertingTopologyBuilder.CreateTopologyAsync(stoppingToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/GetClientNotesForTicket/GetClientNotesForTicket.cs">
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.GetClientNotesForTicket;

public record GetClientNotesForTicket(Guid TicketId) : IQuery<string>;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/GetClientNotesForTicket/GetClientNotesForTicketHandler.cs">
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.GetClientNotesForTicket;

public class GetClientNotesForTicketHandler(ITicketsRepository repository) : IQueryHandler<GetClientNotesForTicket, string>
{
    public async Task<string> HandleAsync(GetClientNotesForTicket query, CancellationToken cancellationToken = default)
    {
        var ticket = await repository.GetAsync(query.TicketId, cancellationToken);

        if (ticket is null)
        {
            throw new TicketFlowException($"Ticket with id {query.TicketId} was not found.");
        }

        return ticket.Notes ?? string.Empty;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/GetTicketDetails/GetTicketDetailsQuery.cs">
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.GetTicketDetails;

public record GetTicketDetailsQuery(Guid TicketId) : IQuery<TicketDetailsDto>;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/GetTicketDetails/GetTicketDetailsQueryHandler.cs">
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using TicketFlow.Services.Tickets.Core.Data;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.GetTicketDetails;

public class GetTicketDetailsQueryHandler(TicketsDbContext dbContext, ILogger<GetTicketDetailsQueryHandler> logger) : IQueryHandler<GetTicketDetailsQuery, TicketDetailsDto>
{
    public async Task<TicketDetailsDto> HandleAsync(GetTicketDetailsQuery query, CancellationToken cancellationToken = default)
    {
        try
        {
            var result = (await dbContext.Tickets
                .Include(x => x.AssignedAgent)
                .SingleOrDefaultAsync(x => x.Id == query.TicketId, cancellationToken))!;

            return new TicketDetailsDto(
                result.Id.ToString(),
                result.Email,
                result.Status.ToString(),
                result.CreatedAt,
                result.Severity,
                result.AssignedAgent?.UserId,
                result.Type?.ToString(),
                result.Resolution);
        }
        catch (Exception ex)
        {
            logger.LogError(ex, ex.Message);
            throw;
        }
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/GetTicketDetails/TicketDetailsDto.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Queries.GetTicketDetails;

public record TicketDetailsDto(
    string Id,
    string Email,
    string Status,
    DateTimeOffset CreatedAt,
    SeverityLevel? SeverityLevel,
    Guid? AssignedAgentUserId,
    string? Type,
    string? Resolution = default);
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListAgents/AgentDto.cs">
namespace TicketFlow.Services.Tickets.Core.Queries.ListAgents;

public record AgentDto(
    string Id,
    string UserId,
    string FullName,
    string Position,
    string AvatarUrl);
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListAgents/ListAgentsHandler.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Tickets.Core.Data;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.ListAgents;

internal class ListAgentsHandler : IQueryHandler<ListAgentsQuery, AgentDto[]>
{
    private readonly TicketsDbContext _dbContext;

    public ListAgentsHandler(TicketsDbContext dbContext)
    {
        _dbContext = dbContext;
    }
    
    public async Task<AgentDto[]> HandleAsync(ListAgentsQuery query, CancellationToken cancellationToken = default)
    {
        return await _dbContext.Agents
            .Select(x =>
                new AgentDto(x.Id.ToString(), x.UserId.ToString(), x.FullName, x.JobPosition.ToString(), x.AvatarUrl))
            .ToArrayAsync(cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListAgents/ListAgentsQuery.cs">
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.ListAgents;

public record ListAgentsQuery() : IQuery<AgentDto[]>;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListTickets/ListTicketsHandler.cs">
using Microsoft.EntityFrameworkCore;
using TicketFlow.Services.Tickets.Core.Data;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.ListTickets;

public class ListTicketsHandler : IQueryHandler<ListTicketsQuery, TicketsListDto>
{
    private readonly TicketsDbContext _dbContext;

    public ListTicketsHandler(TicketsDbContext dbContext)
    {
        _dbContext = dbContext;
    }
    
    public async Task<TicketsListDto> HandleAsync(ListTicketsQuery query, CancellationToken cancellationToken = default)
    {
        var (agentId, status, page, limit) = query;

        var dbQuery = _dbContext.Tickets.AsQueryable();

        if (query.AgentId is not null)
        {
            dbQuery = dbQuery.Where(x => x.AssignedTo.Equals(query.AgentId));
        }

        dbQuery = dbQuery.OrderByDescending(x => x.CreatedAt);

        var total = await dbQuery.CountAsync(cancellationToken);
        var data = await dbQuery
            .Select(x => new TicketsListEntryDto(
                x.Id.ToString(),
                x.Name,
                x.Email,
                x.Title,
                x.Description,
                x.TranslatedDescription,
                x.Category,
                x.Status,
                x.CreatedAt,
                x.Severity,
                x.AssignedTo,
                x.LanguageCode,
                x.Type,
                x.DeadlineUtc,
                x.Resolution))
            .Skip((page - 1) * limit)
            .Take(limit)
            .ToListAsync(cancellationToken);

        return new(data, total);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListTickets/ListTicketsQuery.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Tickets.Core.Queries.ListTickets;

public record ListTicketsQuery(Guid? AgentId, TicketStatus? Status, int Page, int Limit) : IQuery<TicketsListDto>;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Queries/ListTickets/TicketsListDto.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;

namespace TicketFlow.Services.Tickets.Core.Queries.ListTickets;

public record TicketsListDto(List<TicketsListEntryDto> Data, int TotalCount);

public record TicketsListEntryDto(
    string Id,
    string Name,
    string Email,
    string Title,
    string Description,
    string? DescriptionTranslated,
    TicketCategory Category,
    TicketStatus Status,
    DateTimeOffset CreatedAt,
    SeverityLevel? SeverityLevel,
    Guid? AgentId,
    string LanguageCode,
    TicketType? Type,
    DateTimeOffset? Deadline,
    string? Resolution = null);
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/SynchronousIntegration/CreateTicketSynchronously.cs">
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.SynchronousIntegration;

public sealed record CreateTicketSynchronously(
    Guid Id,
    string Name,
    string Email,
    string Title,
    string Description,
    string TranslatedDescription,
    string Category,
    string LanguageCode,
    DateTimeOffset CreatedAt) : ICommand;
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/SynchronousIntegration/CreateTicketSynchronouslyHandler.cs">
using TicketFlow.Services.Tickets.Core.Data.Models;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Shared.Commands;

namespace TicketFlow.Services.Tickets.Core.SynchronousIntegration;

internal sealed class CreateTicketSynchronouslyHandler(ITicketsRepository repository) : ICommandHandler<CreateTicketSynchronously>
{
    public async Task HandleAsync(CreateTicketSynchronously command, CancellationToken cancellationToken = default)
    {
        var (id, name, email, title, description, translatedDescription, category, languageCode, _) = command;
        
        var categoryValid = Enum.TryParse<TicketCategory>(category, out var categoryParsed);
        if (categoryValid is false)
        {
            categoryParsed = TicketCategory.Other;
        }
        
        var ticket = new Ticket(id, name, email, title, description, categoryParsed, languageCode);
        ticket.SetTranslation(translatedDescription);
        
        await repository.AddAsync(ticket, cancellationToken);
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.SystemMetrics.Generator;
using TicketFlow.Services.Tickets.Core.Data;
using TicketFlow.Services.Tickets.Core.Data.Repositories;
using TicketFlow.Services.Tickets.Core.Initializers;
using TicketFlow.Services.Tickets.Core.Messaging;
using TicketFlow.Services.Tickets.Core.Messaging.Publishing.Conventions;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Data;
using TicketFlow.Shared.Exceptions;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.Deduplication;
using TicketFlow.Shared.Messaging.Outbox;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.Tickets.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services
            .AddExceptions()
            .AddApp(configuration)
            .AddSerialization()
            .AddAppInitializers()
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x
                .UseRabbitMq()
                .UseMessagePublisherConvention<TicketsMessagePublisherConventionProvider>()
                .UseDeduplication()
                .UseOutbox()
                .UseAnomalies()
                .UseResiliency())
            .AddPostgres<TicketsDbContext>(configuration)
            .AddSystemMetrics(configuration)
            .AddObservability(configuration);
        
        services.AddHostedService<TicketsConsumerService>();
        services.AddHostedService<TicketsTopologyInitializer>();
        services.AddTransient<ITicketsRepository, TicketsRepository>();
        
        return services;
    }
}
</file>

<file path="src/Tickets/TicketFlow.Services.Tickets.Core/TicketFlow.Services.Tickets.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.CourseUtils\TicketFlow.CourseUtils.csproj" />
      <ProjectReference Include="..\..\Communication\TicketFlow.Services.Communication.Alerting\TicketFlow.Services.Communication.Alerting.csproj" />
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\..\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/Tickets/run-migrations.sh">
dotnet ef database update --startup-project ./TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context TicketsDbContext
dotnet ef database update --startup-project ./TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context DeduplicationDbContext
dotnet ef database update --startup-project ./TicketFlow.Services.Tickets.Api/TicketFlow.Services.Tickets.Api.csproj --context OutboxDbContext
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/Properties/launchSettings.json">
{
  "$schema": "http://json.schemastore.org/launchsettings.json",
  "iisSettings": {
    "windowsAuthentication": false,
    "anonymousAuthentication": true,
    "iisExpress": {
      "applicationUrl": "http://localhost:21858",
      "sslPort": 44394
    }
  },
  "profiles": {
    "http": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": false,
      "applicationUrl": "http://localhost:5274",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "https": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:7126;http://localhost:5274",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/appsettings.Development.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/appsettings.json">
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "App": {
    "AppName" : "translations-service"
  },
  "Observability" : {
    "Enabled" : false,
    "Endpoint" : "http://localhost:4317"
  },
  "OpenAi" : {
    "Enabled": false,
    "ApiKey" : ""
  },
  "rabbitMq": {
    "hostName": "localhost",
    "port": 5672,
    "username": "guest",
    "password": "guest",
    "virtualHost": "/",
    "createTopology": true
  },
  "Metrics": {
    "Enabled": false
  },
  "Resiliency": {
    "Consumer": {
      "BrokerRetriesEnabled": false,
      "BrokerRetriesLimit": 3,
      "ConsumerRetriesEnabled": false,
      "UseDeadletter": false,
      "PublishFaultOnFailure": false,
      "MaxMessagesFetchedPerConsumer": 10
    },
    "Producer": {
      "PublisherConfirmsEnabled":  false,
      "PublishMandatoryEnabled": false
    }
  }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/Program.cs">
using Microsoft.AspNetCore.Mvc;
using TicketFlow.Services.Translations.Core;
using TicketFlow.Services.Translations.Core.SynchronousIntegration;
using TicketFlow.Shared.Queries;

var builder = WebApplication.CreateBuilder(args);
builder.Services.AddCore(builder.Configuration);

var app = builder.Build();

app.MapGet("/", () => "Translations Service");

app.MapPost("/translations", async (
    [FromServices] IQueryHandler<GetTranslatedTextSynchronously, string> handler,
    [FromBody] GetTranslatedTextSynchronously query,
    CancellationToken cancellationToken) =>
{
    var translatedText = await handler.HandleAsync(query, cancellationToken);
    return Results.Ok(translatedText);
});

app.Run();

public partial class Program { }
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/TicketFlow.Services.Translations.Api.csproj">
<Project Sdk="Microsoft.NET.Sdk.Web">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <Nullable>enable</Nullable>
        <ImplicitUsings>enable</ImplicitUsings>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\TicketFlow.Services.Translations.Core\TicketFlow.Services.Translations.Core.csproj" />
    </ItemGroup>

</Project>
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Api/translations-api.http">
@url = http://localhost:5274


###
POST {{url}}/translations/
Content-Type: application/json

{
  "Text": "Text description"
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/Consuming/RequestTranslation/RequestTranslationHandler.cs">
using TicketFlow.Services.Translations.Core.Messaging.Publishing;
using TicketFlow.Services.Translations.Core.Translations;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging.Consuming.RequestTranslation;

internal sealed class RequestTranslationHandler(ITranslationsService translationsService, IMessagePublisher messagePublisher) 
    : IMessageHandler<RequestTranslationV1>, IMessageHandler<RequestTranslationV2>
{
    public Task HandleAsync(RequestTranslationV1 message, CancellationToken cancellationToken = default)
        => HandleAsync(message.Text, default, TranslationLanguage.English, message.TicketId, cancellationToken);

    public Task HandleAsync(RequestTranslationV2 message, CancellationToken cancellationToken = default)
        => HandleAsync(message.Text, message.LanguageCode, TranslationLanguage.English, message.ReferenceId, cancellationToken);
    
    private async Task HandleAsync(string text, string translateFrom, string languageCode, Guid referenceId, CancellationToken cancellationToken = default)
    {
        var translatedText = await translationsService.TranslateAsync(text, translateFrom, languageCode, cancellationToken);

        if (string.IsNullOrWhiteSpace(translatedText))
        {
            var translationSkippedMessage = new TranslationSkipped(text, referenceId);
            await messagePublisher.PublishAsync(translationSkippedMessage, destination: "translation-completed-exchange", cancellationToken: cancellationToken);
            return;
        }
        
        var translationCompletedMessage = new TranslationCompleted(text, translatedText, referenceId);
        await messagePublisher.PublishAsync(translationCompletedMessage, destination: "translation-completed-exchange", cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/Consuming/RequestTranslation/RequestTranslationV1.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging.Consuming.RequestTranslation;

public sealed record RequestTranslationV1(string Text, Guid TicketId) : IMessage;
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/Consuming/RequestTranslation/RequestTranslationV2.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging.Consuming.RequestTranslation;

public sealed record RequestTranslationV2(string Text, string LanguageCode, Guid ReferenceId) : IMessage;
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/Publishing/TranslationCompleted.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging.Publishing;

public record TranslationCompleted(string OriginalText, string TranslatedText, Guid ReferenceId) : IMessage;
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/Publishing/TranslationSkipped.cs">
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging.Publishing;

public record TranslationSkipped(string OriginalText, Guid ReferenceId) : IMessage;
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/TranslationsConsumerService.cs">
using Microsoft.Extensions.Hosting;
using TicketFlow.Services.Translations.Core.Messaging.Consuming.RequestTranslation;
using TicketFlow.Shared.Messaging;

namespace TicketFlow.Services.Translations.Core.Messaging;

internal sealed class TranslationsConsumerService(IMessageConsumer messageConsumer) : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        //messageConsumer.ConsumeMessage<RequestTranslationV1>(queue: "request-translation-v1-queue", cancellationToken: cancellationToken);
        await messageConsumer.ConsumeMessage<RequestTranslationV2>(queue: "request-translation-v2-queue", cancellationToken: cancellationToken);
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Messaging/TranslationTopologyInitializer.cs">
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Shared.Messaging.Topology;

namespace TicketFlow.Services.Translations.Core.Messaging;

public class TranslationTopologyInitializer : TopologyInitializerBase
{
    public TranslationTopologyInitializer(IServiceProvider serviceProvider) : base(serviceProvider)
    {
    }

    protected override async Task CreateTopologyAsync(CancellationToken stoppingToken)
    {
        var topologyBuilder = ServiceProvider.GetService<ITopologyBuilder>();
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: "",
            consumerDestination: "request-translation-v1-queue",
            TopologyType.Direct,
            cancellationToken: stoppingToken
        );
        
        await topologyBuilder.CreateTopologyAsync(
            publisherSource: "",
            consumerDestination: "request-translation-v2-queue",
            TopologyType.Direct,
            cancellationToken: stoppingToken
        );
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/SynchronousIntegration/GetTranslatedTextSynchronously.cs">
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Translations.Core.SynchronousIntegration;

public class GetTranslatedTextSynchronously : IQuery<string>
{
    public string Text { get; set; }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/SynchronousIntegration/GetTranslatedTextSynchronouslyHandler.cs">
using TicketFlow.Services.Translations.Core.Translations;
using TicketFlow.Shared.Queries;

namespace TicketFlow.Services.Translations.Core.SynchronousIntegration;

internal sealed class GetTranslatedTextSynchronouslyHandler(ITranslationsService translationsService) : IQueryHandler<GetTranslatedTextSynchronously, string>
{
    public async Task<string> HandleAsync(GetTranslatedTextSynchronously query, CancellationToken cancellationToken = default)
    {
        var translatedText = await translationsService.TranslateAsync(query.Text, default, "en", cancellationToken);
        return translatedText;
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Translations/Extensions.cs">
using Microsoft.Extensions.AI;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Options;
using TicketFlow.Shared.OpenAI;

namespace TicketFlow.Services.Translations.Core.Translations;

internal static class Extensions
{
    public static IServiceCollection AddTranslations(this IServiceCollection services, IConfiguration configuration)
    {
        services.AddOpenAi(configuration);
        services.AddSingleton<ITranslationsService>(sp =>
        {
            var options = sp.GetRequiredService<IOptions<OpenAIOptions>>();

            return options.Value.Enabled
                ? new OpenAiTranslationsService(sp.GetRequiredService<IChatClient>())
                : new NoopTranslationsService();
        });
        return services;
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Translations/ITranslationsService.cs">
namespace TicketFlow.Services.Translations.Core.Translations;

public interface ITranslationsService
{
    Task<string> TranslateAsync(string text, string? translateFrom, string translateTo, CancellationToken cancellationToken = default);
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Translations/NoopTranslationsService.cs">
namespace TicketFlow.Services.Translations.Core.Translations;

internal sealed class NoopTranslationsService : ITranslationsService
{
    public Task<string> TranslateAsync(string text, string translateFrom, string translateTo, CancellationToken cancellationToken = default)
        => Task.FromResult("This is Noop translation");
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Translations/OpenAiTranslationsService.cs">
using Microsoft.Extensions.AI;

namespace TicketFlow.Services.Translations.Core.Translations;

internal sealed class OpenAiTranslationsService(IChatClient chatClient) : ITranslationsService
{
    public async Task<string> TranslateAsync(string text, string? translateFrom, string translateTo, CancellationToken cancellationToken = default)
    {
        var prompt = $@"Translate {(translateFrom is null ? "" : $"from {translateFrom}")} to {translateTo}: '{text}'";
        var response = await chatClient.CompleteAsync(prompt, cancellationToken: cancellationToken);

        return response.Message.Text!;
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Translations/TranslationLanguage.cs">
namespace TicketFlow.Services.Translations.Core.Translations;

public static class TranslationLanguage
{
    public static string English = "english";
    public static string Polish = "polish";
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/Extensions.cs">
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.SystemMetrics.Generator;
using TicketFlow.Services.Translations.Core.Messaging;
using TicketFlow.Services.Translations.Core.Translations;
using TicketFlow.Shared.AnomalyGeneration;
using TicketFlow.Shared.App;
using TicketFlow.Shared.Commands;
using TicketFlow.Shared.Messaging;
using TicketFlow.Shared.Messaging.RabbitMQ;
using TicketFlow.Shared.Messaging.Resiliency;
using TicketFlow.Shared.Observability;
using TicketFlow.Shared.Queries;
using TicketFlow.Shared.Serialization;

namespace TicketFlow.Services.Translations.Core;

public static class Extensions
{
    public static IServiceCollection AddCore(this IServiceCollection services, IConfiguration configuration)
    {
        services
            .AddSerialization()
            .AddApp(configuration)
            .AddCommands()
            .AddQueries()
            .AddLogging()
            .AddMessaging(configuration, x => x.UseRabbitMq().UseAnomalies().UseResiliency())
            .AddTranslations(configuration)
            .AddSystemMetrics(configuration)
            .AddObservability(configuration);
        
        services.AddHostedService<TranslationsConsumerService>();
        services.AddHostedService<TranslationTopologyInitializer>();
        return services;
    }
}
</file>

<file path="src/Translations/TicketFlow.Services.Translations.Core/TicketFlow.Services.Translations.Core.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
      <ProjectReference Include="..\..\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj" />
    </ItemGroup>
</Project>
</file>

<file path="src/run_all_be.sh">
#!/bin/bash

# Run all services in parallel
echo "Starting all API services..."
for dir in */*.Api/; do
    if [ -d "$dir" ]; then
        echo "Starting service in $dir"
        (cd "$dir" && dotnet run) &
    fi
done

# Wait for all background processes
wait
</file>

<file path="src/run_all_migrations.sh">
#!/bin/bash

# Run all migrations
echo "Running all migrations..."
for dir in */*.Api/; do
    if [ -d "$dir" ]; then
        parent_dir=$(dirname "$dir")
        migration_script="$parent_dir/run-migrations.sh"
        if [ -f "$migration_script" ]; then
            echo "Found migration script in $parent_dir"
            echo "Running migrations using $migration_script"
            (cd "$parent_dir" && bash run-migrations.sh) || { echo "Migration failed in $parent_dir"; exit 1; }
        else
            echo "No migration script found in $parent_dir"
        fi
    fi
done
</file>

<file path="src_frontend/inquiries/app/components/client-layout.tsx">
"use client"
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faBug } from "@fortawesome/free-solid-svg-icons";
import { Toaster } from "sonner";
import { CustomNavigationMenu } from '@/components/custom/custom-nav';
import { Footer } from "@/components/custom/footer";

export function ClientLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="mx-auto w-full h-full flex flex-col bg-background border-border/40 dark:border-border min-[1800px]:max-w-[1536px] min-[1800px]:border-x">
      <header className="border-b">
        <div className="container flex h-14 items-center px-8">
          <CustomNavigationMenu />
        </div>
      </header>
      <div className="container flex-1 py-8 px-8 w-full mx-auto">
        <main className="flex flex-col gap-8 items-center sm:items-start w-full h-full mx-auto">
          <Card className="w-full h-full mx-auto border-none">
            <CardHeader>
              <CardTitle>
                <h3 className="scroll-m-20 pb-2 text-3xl font-semibold tracking-tight first:mt-0">
                  <FontAwesomeIcon className="pr-4" icon={faBug} /> 
                  Zgłoszenia
                </h3>
              </CardTitle>
              <CardDescription>
                Tu użytkownicy końcowi zgłaszają swoje problemy i pytania dotyczące platformy
              </CardDescription>
            </CardHeader>
            <CardContent>
              {children}
            </CardContent>
          </Card>
        </main>
      </div>
      <div className="w-full mx-auto">
        <Footer />
      </div>
      <Toaster />
    </div>
  );
}
</file>

<file path="src_frontend/inquiries/app/inquiries-list/inquiry.tsx">
"use client"

import { faCheckCircle, faSpinner, faPlusCircle, faCircle, faCircleExclamation, faTriangleExclamation, faFire, faRotateRight } from "@fortawesome/free-solid-svg-icons"
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { ColumnDef, Row } from "@tanstack/react-table"
import { MoreHorizontal } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu"

import { InquiryCategory, InquiryStatus } from '@/app/types/enums'
import { inquiryCategoryTranslations, inquiryStatusTranslations } from "@/app/lib/translations";
import { Inquiry } from "@/app/types/inquiry";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { useState, useEffect } from "react"
import { Input } from "@/components/ui/input"
import { Textarea } from "@/components/ui/textarea"
import { DialogFooter } from "@/components/ui/dialog"
import { Form, FormControl, FormField, FormItem, FormLabel } from "@/components/ui/form"
import { zodResolver } from "@hookform/resolvers/zod"
import { useForm } from "react-hook-form"
import * as z from "zod"
import { Separator } from "@/components/ui/separator"
import { toast } from "sonner"
import { getTicketComments, addTicketComment } from "@/app/services/ticketService"

type InquiryWithDialogState = Inquiry & {
  showDetails?: boolean;
};

const commentFormSchema = z.object({
  comment: z.string().min(1, "Komentarz nie może być pusty"),
})

export const columns = (
  onRefresh: () => void
): ColumnDef<InquiryWithDialogState>[] => [
  {
    accessorKey: "title",
    header: "Tytuł",
    cell: ({ row }) => {
      const title = row.getValue("title") as string;
      const category = row.original.category;
     
      const categoryLabel = inquiryCategoryTranslations[category?.toLowerCase() as InquiryCategory];
      
      return (
        <div className="flex items-center">
          <span className="font-medium text-muted-foreground mr-2">[{categoryLabel || category}]</span>
          <span>{title}</span>
        </div>
      );
    }
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as InquiryStatus;
      
      const statusConfig = {
        [InquiryStatus.NEW]: { 
          label: inquiryStatusTranslations[InquiryStatus.NEW], 
          variant: "outline",
          icon: faPlusCircle
        },
        [InquiryStatus.IN_PROGRESS]: { 
          label: inquiryStatusTranslations[InquiryStatus.IN_PROGRESS], 
          variant: "outline",
          icon: faSpinner
        },
        [InquiryStatus.RESOLVED]: { 
          label: inquiryStatusTranslations[InquiryStatus.RESOLVED], 
          variant: "secondary",
          icon: faCheckCircle
        },
        [InquiryStatus.CLOSED]: { 
          label: inquiryStatusTranslations[InquiryStatus.CLOSED], 
          variant: "secondary",
          icon: faCheckCircle
        },
      } as const;

      const config = statusConfig[status] || statusConfig[InquiryStatus.NEW];

      return (
        <div className="flex justify-start items-center">
          <Badge variant={config.variant}>
            <FontAwesomeIcon icon={config.icon} className="mr-2" />
            {config.label}
          </Badge>
        </div>
      )
    }
  },
  {
    accessorKey: "createdAt",
    header: "Data utworzenia",
    cell: ({ row }) => {
      const date = new Date(row.getValue("createdAt"));
      return date.toLocaleString('pl-PL', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });
    }
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const inquiry = row.original
      const [showCommentForm, setShowCommentForm] = useState(false)
 
      return (
        <>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <span className="sr-only">Otwórz menu</span>
                <MoreHorizontal className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Akcje</DropdownMenuLabel>
              <DropdownMenuItem
                onClick={() => navigator.clipboard.writeText(inquiry.id.toString())}
              >
                Skopiuj ID zgłoszenia
              </DropdownMenuItem>
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={() => setShowCommentForm(true)}>
                Zobacz szczegóły
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          
          <AddCommentDialog 
            inquiry={inquiry}
            open={showCommentForm}
            onOpenChange={setShowCommentForm}
            onCommentAdded={onRefresh}
          />
        </>
      )
    },
  },
]

function AddCommentDialog({ 
  inquiry, 
  open, 
  onOpenChange,
  onCommentAdded
}: { 
  inquiry: Inquiry; 
  open: boolean; 
  onOpenChange: (open: boolean) => void;
  onCommentAdded?: () => void;
}) {
  const form = useForm<z.infer<typeof commentFormSchema>>({
    resolver: zodResolver(commentFormSchema),
    defaultValues: {
      comment: "",
    },
  })

  const [ticketComments, setTicketComments] = useState<string>("");
  const comments = ticketComments?.split('\n').filter(comment => comment.trim()) || [];

  // Add useEffect to fetch ticket comments when dialog opens
  useEffect(() => {
    async function fetchTicketComments() {
      if (inquiry.ticketId && open) {
        try {
          const comments = await getTicketComments(inquiry.ticketId);
          setTicketComments(comments);
        } catch (error) {
          console.error('Failed to fetch ticket comments:', error);
          toast.error("Nie udało się pobrać komentarzy");
        }
      }
    }

    fetchTicketComments();
  }, [inquiry.ticketId, open]);

  async function onSubmit(values: z.infer<typeof commentFormSchema>) {
    try {
      if (!inquiry.ticketId) return;
      
      await addTicketComment(inquiry.ticketId, values.comment);
      const updatedComments = await getTicketComments(inquiry.ticketId);
      setTicketComments(updatedComments);
      toast.success("Komentarz został dodany");
      form.reset();
    } catch (error) {
      toast.error("Nie udało się dodać komentarza");
      console.error(error);
    }
  }

  // Add useEffect for cleanup
  useEffect(() => {
    if (!open) {
      document.body.style.pointerEvents = '';
      document.body.style.overflow = '';
    }
    return () => {
      document.body.style.pointerEvents = '';
      document.body.style.overflow = '';
    };
  }, [open]);

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle className="text-2xl font-bold">{inquiry.title}</DialogTitle>
        </DialogHeader>
        <Separator className="my-4" />
        
        {/* Basic inquiry info */}
        <div className="grid gap-4">
          <div className="grid grid-cols-3 gap-4">
            <div>
              <h3 className="font-semibold mb-2">Kategoria</h3>
              <p className="text-muted-foreground">
                {inquiryCategoryTranslations[inquiry.category?.toLowerCase() as InquiryCategory] || inquiry.category}
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">Status</h3>
              <p className="text-muted-foreground">
                {inquiryStatusTranslations[inquiry.status]}
              </p>
            </div>
            <div>
              <h3 className="font-semibold mb-2">Data utworzenia</h3>
              <p className="text-muted-foreground">
                {new Date(inquiry.createdAt).toLocaleString('pl-PL')}
              </p>
            </div>
          </div>
          
          {inquiry.description && (
            <div>
              <h3 className="font-semibold mb-2">Opis</h3>
              <p className="text-muted-foreground whitespace-pre-wrap">{inquiry.description}</p>
            </div>
          )}
        </div>

        <Separator className="my-4" />
        
        {/* Comments and ticket section */}
        <div className="space-y-4">
          <div>
            <h3 className="font-semibold mb-2">Powiązany ticket</h3>
            <p className="text-muted-foreground">
              {inquiry.ticketId ? inquiry.ticketId : 'Brak powiązanego ticketu'}
            </p>
          </div>
          
          <div>
            <h3 className="font-semibold mb-2">Komentarze</h3>
            {inquiry.ticketId ? (
              comments.length > 0 ? (
                <div className="space-y-2">
                  {comments.map((comment, index) => (
                    <div key={index} className="p-2 bg-muted rounded-md">
                      <p className="text-sm text-muted-foreground">{comment}</p>
                    </div>
                  ))}
                </div>
              ) : (
                <p className="text-sm text-muted-foreground">Brak komentarzy</p>
              )
            ) : (
              <p className="text-sm text-muted-foreground">Brak powiązanego ticketu</p>
            )}
          </div>
          
          {inquiry.ticketId ? (
            <Form {...form}>
              <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
                <FormField
                  control={form.control}
                  name="comment"
                  render={({ field }) => (
                    <FormItem>
                      <FormLabel>Nowy komentarz</FormLabel>
                      <FormControl>
                        <Textarea 
                          placeholder="Wpisz swój komentarz..." 
                          {...field} 
                        />
                      </FormControl>
                    </FormItem>
                  )}
                />
                <DialogFooter>
                  <Button type="submit">Dodaj komentarz</Button>
                </DialogFooter>
              </form>
            </Form>
          ) : (
            <div className="rounded-md bg-muted p-4">
              <p className="text-sm text-muted-foreground">
                Aby dodać komentarz, zgłoszenie musi być powiązane z ticketem.
              </p>
            </div>
          )}
        </div>
      </DialogContent>
    </Dialog>
  )
}

export function DataTableToolbar({ onRefresh }: { onRefresh: () => void }) {
  return (
    <div className="flex items-center justify-between">
      <div className="flex flex-1 items-center space-x-2">
        {/* Your existing toolbar content */}
      </div>
      <div className="flex items-center space-x-2">
        <Button
          variant="outline"
          size="sm"
          onClick={onRefresh}
          className="h-8"
        >
          <FontAwesomeIcon icon={faRotateRight} className="mr-2 h-4 w-4" />
          Odśwież
        </Button>
        {/* Your existing "Dodaj zgłoszenie" button */}
      </div>
    </div>
  )
}
</file>

<file path="src_frontend/inquiries/app/inquiries-list/page.tsx">
"use client"

import React, { useState, useEffect, useRef, useCallback } from "react"
import * as inquiryService from "@/app/services/inquiryService";
import { columns, DataTableToolbar } from "./inquiry";
import { Inquiry } from "@/app/types/inquiry";
import { DataTable } from "@/components/custom/data-table";
import { Button } from "@/components/ui/button";
import { useRouter } from "next/navigation";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { faRotateRight, faPlus } from "@fortawesome/free-solid-svg-icons"

export default function InquiriesPage() {
  const router = useRouter();
  const [data, setData] = useState<Inquiry[]>([]);
  const [pageCount, setPageCount] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const loadingTimeoutRef = useRef<NodeJS.Timeout>();
  
  const fetchData = useCallback(async (pageIndex: number, pageSize: number) => {
    if (loadingTimeoutRef.current) {
      clearTimeout(loadingTimeoutRef.current);
    }

    loadingTimeoutRef.current = setTimeout(() => {
      setIsLoading(true);
    }, 500);

    try {
      const result = await inquiryService.getPaginatedInquiries(pageIndex, pageSize);
      setData(result.data);
      setPageCount(Math.ceil(result.total / pageSize));
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      if (loadingTimeoutRef.current) {
        clearTimeout(loadingTimeoutRef.current);
      }
      setIsLoading(false);
    }
  }, []);

  const handlePaginationChange = useCallback(({ pageIndex, pageSize }: { pageIndex: number; pageSize: number }) => {
    fetchData(pageIndex, pageSize);
  }, [fetchData]);

  useEffect(() => {
    fetchData(0, 10);
    return () => {
      if (loadingTimeoutRef.current) {
        clearTimeout(loadingTimeoutRef.current);
      }
    };
  }, [fetchData]);

  const handleRefresh = useCallback(() => {
    fetchData(0, 10);
  }, [fetchData]);

  return (
    <div className="container mx-auto py-4">
      <div className="flex justify-between items-end mb-6 w-full" style={{ marginTop: '-76px' }}>
        <div>&nbsp;</div>
        <div className="flex items-center space-x-2">
          <Button
            variant="outline"
            onClick={handleRefresh}
          >
            <FontAwesomeIcon icon={faRotateRight} className="mr-2 h-4 w-4" />
            Odśwież
          </Button>
          <Button 
            onClick={() => router.push('/submit-inquiry')}
          >
            <FontAwesomeIcon icon={faPlus} className="mr-2 h-4 w-4" />
            Dodaj zgłoszenie
          </Button>
        </div>
      </div>
      <DataTable<Inquiry, Inquiry>
        columns={columns(handleRefresh)}
        data={data}
        pageCount={pageCount}
        isLoading={isLoading}
        onPaginationChange={handlePaginationChange}
      />
    </div>
  );
}
</file>

<file path="src_frontend/inquiries/app/lib/translations.ts">
import { InquiryCategory, InquiryStatus } from "@/app/types/enums";

export const inquiryCategoryTranslations = {
  [InquiryCategory.GENERAL]: "Ogólne",
  [InquiryCategory.TECHNICAL]: "Techniczne",
  [InquiryCategory.BILLING]: "Płatności",
  [InquiryCategory.OTHER]: "Inne",
} as const;

export const inquiryStatusTranslations = {
  [InquiryStatus.NEW]: "Nowe",
  [InquiryStatus.IN_PROGRESS]: "W trakcie",
  [InquiryStatus.RESOLVED]: "Rozwiązane",
  [InquiryStatus.CLOSED]: "Zamknięte",
} as const;
</file>

<file path="src_frontend/inquiries/app/services/agents.ts">
const API_URL = 'http://localhost:5112';

export async function getAgent(id: string): Promise<Agent> {
  const response = await fetch(`${API_URL}/agents/${id}`)
  if (!response.ok) {
    throw new Error('Nie udało się pobrać agenta')
  }
  return response.json()
}
</file>

<file path="src_frontend/inquiries/app/services/inquiryService.ts">
import { Inquiry } from '@/app/types/inquiry';

const API_URL = 'http://localhost:5011';

interface PaginatedResponse {
  data: Inquiry[];
  total: number;
}

export async function createInquiry(inquiryData: Partial<Inquiry>): Promise<void> {
  const response = await fetch(`${API_URL}/inquiries/submit`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify(inquiryData),
  });

  if (!response.ok) {
    throw new Error('Failed to create inquiry');
  }

  return;
}

export const getPaginatedInquiries = async (pageIndex: number, pageSize: number): Promise<PaginatedResponse> => {
  const response = await fetch(
    `${API_URL}/inquiries?page=${pageIndex + 1}&limit=${pageSize}`
  );
  
  if (!response.ok) {
    throw new Error('Failed to fetch inquiries');
  }

  return await response.json();
}

export async function addInquiryComment(inquiryId: string, comment: string): Promise<void> {
  const response = await fetch(`${API_URL}/inquiries/${inquiryId}/comments`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ comment }),
  });

  if (!response.ok) {
    throw new Error('Failed to add comment');
  }

  return;
}
</file>

<file path="src_frontend/inquiries/app/services/messages.ts">
import { Message } from "@/app/types/message";

const API_URL = 'http://localhost:5148';

interface GetMessagesParams {
  page: number;
  limit: number;
  onlyUnread?: boolean;
}

interface MessagesResponse {
  data: Message[];
  total: number;
}

export async function getMessages({ page, limit, onlyUnread }: GetMessagesParams): Promise<MessagesResponse> {
  const url = new URL(`${API_URL}/anonymous-users/messages`);
  url.searchParams.set('page', page.toString());
  url.searchParams.set('limit', limit.toString());
  if (onlyUnread) {
    url.searchParams.set('onlyUnread', 'true');
  }

  const response = await fetch(url, {
    method: 'GET',
    cache: 'no-store'
  });

  if (!response.ok) {
    throw new Error('Failed to fetch messages');
  }
  return response.json();
}

export async function toggleMessageReadStatus(id: string, isRead: boolean): Promise<void> {  
  const response = await fetch(
    `${API_URL}/messages/${id}?isRead=${isRead}`,
    {
      method: 'PUT',
      cache: 'no-store'
    }
  );

  if (!response.ok) {
    throw new Error('Failed to update message status');
  }
}
</file>

<file path="src_frontend/inquiries/app/services/ticketService.ts">
export async function getTicketComments(ticketId: string): Promise<string> {
  const response = await fetch(`http://localhost:5112/tickets/${ticketId}/client-notes`);
  
  if (!response.ok) {
    throw new Error('Failed to fetch ticket comments');
  }

  return response.text();
}

export async function addTicketComment(ticketId: string, note: string): Promise<void> {
  const response = await fetch(`http://localhost:5112/tickets/${ticketId}/client-notes`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ note: note }),
  });

  if (!response.ok) {
    throw new Error('Failed to add comment');
  }
}
</file>

<file path="src_frontend/inquiries/app/submit-inquiry/page.tsx">
"use client"

import React, { useState } from 'react'
import { useForm, ControllerRenderProps, Control } from 'react-hook-form'
import { z } from 'zod'
import { zodResolver } from '@hookform/resolvers/zod'
import { useRouter } from 'next/navigation'
import { toast } from "sonner"

import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card'
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Button } from '@/components/ui/button'
import { Select, SelectTrigger, SelectValue, SelectItem, SelectContent } from '@/components/ui/select'
import { InquiryCategory, InquiryStatus } from '@/app/types/enums'
import { inquiryCategoryTranslations } from '@/app/lib/translations'
import { createInquiry } from '@/app/services/inquiryService';

const categoryOptions = [
  { value: InquiryCategory.TECHNICAL, label: inquiryCategoryTranslations[InquiryCategory.TECHNICAL] },
  { value: InquiryCategory.BILLING, label: inquiryCategoryTranslations[InquiryCategory.BILLING] },
  { value: InquiryCategory.OTHER, label: inquiryCategoryTranslations[InquiryCategory.OTHER] },
  { value: InquiryCategory.GENERAL, label: inquiryCategoryTranslations[InquiryCategory.GENERAL] },
] as const

const formSchema = z.object({
  title: z.string().min(3, "Tytuł musi mieć co najmniej 3 znaki"),
  name: z.string().min(2, "Imię musi mieć co najmniej 2 znaki"),
  email: z.string().email("Nieprawidłowy adres email"),
  description: z.string().min(10, "Opis musi mieć co najmniej 10 znaków"),
  category: z.nativeEnum(InquiryCategory),
})

type FormValues = z.infer<typeof formSchema>

const InquiryForm: React.FC = () => {
  const router = useRouter()
  const form = useForm<FormValues>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      title: '',
      name: '',
      email: '',
      description: '',
      category: InquiryCategory.TECHNICAL,
    }
  });

  const { handleSubmit } = form;

  const onSubmit = async (data: FormValues) => {
    try {
      await createInquiry({
        ...data
      });

      toast.success('Zgłoszenie zostało wysłane');
      router.push('/inquiries-list');
    } catch (error) {
      toast.error('Nie udało się wysłać zgłoszenia');
      console.error(error);
    }
  }

  return (
    <Card className="w-full max-w-2xl mx-auto">
      <CardHeader>
        <CardTitle>Nowe Zgłoszenie</CardTitle>
      </CardHeader>
      <CardContent>
        <Form {...form}>
          <form onSubmit={handleSubmit(onSubmit)} className="space-y-6">
            <FormField
              control={form.control}
              name="title"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Tytuł</FormLabel>
                  <FormControl>
                    <Input placeholder="Wprowadź tytuł zgłoszenia" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="name"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Imię</FormLabel>
                  <FormControl>
                    <Input placeholder="Wprowadź swoje imię" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="email"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Email</FormLabel>
                  <FormControl>
                    <Input type="email" placeholder="twoj@email.com" {...field} />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="description"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Opis</FormLabel>
                  <FormControl>
                    <Textarea 
                      placeholder="Opisz szczegółowo swoje zgłoszenie"
                      className="min-h-[100px]"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            <FormField
              control={form.control}
              name="category"
              render={({ field }) => (
                <FormItem>
                  <FormLabel>Kategoria</FormLabel>
                  <Select onValueChange={field.onChange} defaultValue={field.value}>
                    <FormControl>
                      <SelectTrigger>
                        <SelectValue placeholder="Wybierz kategorię" />
                      </SelectTrigger>
                    </FormControl>
                    <SelectContent>
                      {categoryOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <FormMessage />
                </FormItem>
              )}
            />

            <Button type="submit" className="w-full">
              Wyślij Zgłoszenie
            </Button>
          </form>
        </Form>
      </CardContent>
    </Card>
  )
}

export default InquiryForm
</file>

<file path="src_frontend/inquiries/app/types/employee.ts">
interface Agent {
  id: string
  userId: string
  fullName: string
  avatarUrl: string
}
</file>

<file path="src_frontend/inquiries/app/types/enums.ts">
export enum InquiryCategory {
  GENERAL = "general",
  TECHNICAL = "technical",
  BILLING = "billing",
  OTHER = "other",
}

export enum InquiryStatus {
  NEW = "new",
  IN_PROGRESS = "in_progress",
  RESOLVED = "resolved",
  CLOSED = "closed",
}
</file>

<file path="src_frontend/inquiries/app/types/inquiry.ts">
import { InquiryCategory, InquiryStatus } from "./enums";

export interface Inquiry {
  id: string;
  name: string;
  title: string;
  email: string;
  description: string;
  category: InquiryCategory;
  status: InquiryStatus;
  createdAt: string;
  ticketId: string;
  comments: string;
}
</file>

<file path="src_frontend/inquiries/app/types/message.ts">
export interface Message {
  id: string;
  title: string;
  preview: string;
  content: string;
  timestamp: string;
  isRead: boolean;
  senderDisplayName?: string;
  senderEmployeeId?: string;
}
</file>

<file path="src_frontend/inquiries/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}


@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24.6 95% 53.1%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24.6 95% 53.1%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 20.5 90.2% 48.2%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 20.5 90.2% 48.2%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src_frontend/inquiries/app/layout.tsx">
import { GeistSans } from 'geist/font/sans';
import "./globals.css";
import { Providers } from "./providers";
import { config } from '@fortawesome/fontawesome-svg-core';
import '@fortawesome/fontawesome-svg-core/styles.css';
import { Metadata } from 'next';
import { ClientLayout } from '@/app/components/client-layout';

config.autoAddCss = false;

export const metadata: Metadata = {
  title: "TicketFlow - Zgłoszenia",
}; 

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" className="h-full">
      <body className={`${GeistSans.className} h-full dark:bg-background`}>
        <Providers>
          <ClientLayout>{children}</ClientLayout>
        </Providers>
      </body>
    </html>
  );
}
</file>

<file path="src_frontend/inquiries/app/page.tsx">
'use client'

import { redirect } from 'next/navigation'

export default function Page() {
  redirect('/inquiries-list')
}
</file>

<file path="src_frontend/inquiries/app/providers.tsx">
"use client"

import { ThemeProvider } from "next-themes"
import { QueryClient, QueryClientProvider } from "@tanstack/react-query"
import { useState } from "react"

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <ThemeProvider
        attribute="class" defaultTheme="dark"
        enableSystem
      >
        {children}
      </ThemeProvider>
    </QueryClientProvider>
  )
}
</file>

<file path="src_frontend/inquiries/components/custom/custom-nav.tsx">
"use client";

import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from "@/components/ui/sheet";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faEnvelope } from "@fortawesome/free-solid-svg-icons";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import {
    NavigationMenu,
    NavigationMenuItem,
    NavigationMenuLink,
    NavigationMenuList,
    navigationMenuTriggerStyle,
  } from "@/components/ui/navigation-menu";
import { MessageList, useUnreadMessages } from "../messages/message-list";

const menuItemStyle = "group inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50";

export function CustomNavigationMenu() {
 
  const { data: unreadCount } = useUnreadMessages();

  return (
    <div className="flex items-center justify-between w-full">
      <div className="flex items-center gap-4">
        <div className="flex items-center pr-4">
            <img 
                src="/img/ticketflow_logo.png" 
                alt="TicketFlow Logo"
                width="124"
                height="auto"
            />
        </div>
      
      
      <NavigationMenu>
        <NavigationMenuList>
          <NavigationMenuItem className="pr-2">
            <Link href="/inquiries-list" legacyBehavior passHref>
              <NavigationMenuLink 
                className={menuItemStyle}
                active={true}
              >
                Zgłoszenia
              </NavigationMenuLink>
            </Link>
          </NavigationMenuItem>
          <NavigationMenuItem className="pr-2">
            <Link href="http://localhost:21001" legacyBehavior passHref>
              <NavigationMenuLink className={menuItemStyle}>
                Tickety
              </NavigationMenuLink>
            </Link>
          </NavigationMenuItem>
          <NavigationMenuItem className="pr-2">
            <Link href="http://localhost:21002" legacyBehavior passHref>
              <NavigationMenuLink className={menuItemStyle}>
                Panel admina
              </NavigationMenuLink>
            </Link>
          </NavigationMenuItem>
        </NavigationMenuList>
      </NavigationMenu>
      </div>

      <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="h-9 w-9 relative">
              <FontAwesomeIcon icon={faEnvelope} className="h-5 w-5" />
              {unreadCount && unreadCount > 0 && (
                <span className="absolute -top-1 -right-1 bg-primary text-primary-foreground text-xs rounded-full w-5 h-5 flex items-center justify-center">
                  {unreadCount}
                </span>
              )}
            </Button>
          </SheetTrigger>
          <SheetContent className="w-[95vw] sm:w-[600px] overflow-y-auto max-w-[95vw] sm:max-w-[600px]">
            <SheetHeader>
              <SheetTitle>Wiadomości</SheetTitle>
            </SheetHeader>
            <MessageList />
          </SheetContent>
        </Sheet>
    </div>
  );
}
</file>

<file path="src_frontend/inquiries/components/custom/data-table.tsx">
"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  OnChangeFn,
  PaginationState,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Button } from "../ui/button"
import { useState, useMemo, useEffect, SetStateAction } from "react"
import { Loader2 } from "lucide-react"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
  pageCount: number
  isLoading?: boolean
  onPaginationChange?: (pagination: { pageIndex: number; pageSize: number }) => void
}

export function DataTable<TData, TValue>({
  columns,
  data,
  pageCount,
  isLoading = false,
  onPaginationChange,
}: DataTableProps<TData, TValue>) {
  const [pagination, setPagination] = useState<PaginationState>({
    pageIndex: 0,
    pageSize: 10,
  })

  const table = useReactTable({
    data,
    columns,
    pageCount,
    getCoreRowModel: getCoreRowModel(),
    manualPagination: true,
    state: {
      pagination,
    },
    onPaginationChange: setPagination,
  })

  useEffect(() => {
    if (onPaginationChange) {
      onPaginationChange({ pageIndex: pagination.pageIndex, pageSize: pagination.pageSize })
    }
  }, [pagination.pageIndex, pagination.pageSize])

  return (
    <div className="relative">
      {isLoading && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 mt-8">
          <Loader2 className="h-6 w-6 animate-spin" />
        </div>
      )}
      <Table>
        <TableHeader>
          {table.getHeaderGroups().map((headerGroup) => (
            <TableRow key={headerGroup.id}>
              {headerGroup.headers.map((header) => {
                return (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                )
              })}
            </TableRow>
          ))}
        </TableHeader>
        <TableBody>
          {table.getRowModel().rows?.length ? (
            table.getRowModel().rows.map((row) => (
              <TableRow
                key={row.id}
                data-state={row.getIsSelected() && "selected"}
              >
                {row.getVisibleCells().map((cell) => (
                  <TableCell key={cell.id}>
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </TableCell>
                ))}
              </TableRow>
            ))
          ) : !isLoading ? (
            <TableRow>
              <TableCell colSpan={columns.length} className="h-24 text-center">
                No results.
              </TableCell>
            </TableRow>
          ) : null}
        </TableBody>
      </Table>
      <div className="flex items-center justify-end space-x-2 py-4">
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.previousPage()}
          disabled={!table.getCanPreviousPage() || isLoading}
        >
          Poprzednia
        </Button>
        <Button
          variant="outline"
          size="sm"
          onClick={() => table.nextPage()}
          disabled={!table.getCanNextPage() || isLoading}
        >
          Następna
        </Button>
      </div>
    </div>
  )
}
</file>

<file path="src_frontend/inquiries/components/custom/footer.tsx">
import Image from "next/image";
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { 
  faGithub, 
  faYoutube, 
  faDiscord, 
  faInstagram, 
  faTwitter, 
  faLinkedinIn 
} from '@fortawesome/free-brands-svg-icons';

export function Footer() {
  return (
    <footer className="border-t py-4 bg-black">
      <div className="container flex flex-col items-center gap-3 mx-auto">
        <div className="flex items-center gap-4">
          <a href="https://devmentors.io">
            <Image 
              src="/img/devmentors-logo.png" 
              alt="DevMentors Logo" 
              width={80}
              height={19}
              className="h-auto w-auto"
            />
          </a>
          <a href="https://github.com/devmentors" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faGithub} />
          </a>
          <a href="https://www.youtube.com/@DevMentorsPL" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faYoutube} />
          </a>
          <a href="https://devmentors.io/discordpl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faDiscord} />
          </a>
          <a href="https://www.instagram.com/devmentors_pl/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faInstagram} />
          </a>
          <a href="https://twitter.com/dev_mentors_pl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faTwitter} />
          </a>
          <a href="https://www.linkedin.com/company/devmentors-io/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faLinkedinIn} />
          </a>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src_frontend/inquiries/components/messages/message-item.tsx">
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { faEnvelope, faEnvelopeOpen } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { toggleMessageReadStatus } from "@/app/services/messages";
import { Message } from "@/app/types/message";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { User } from "lucide-react";
import { getAgent } from "@/app/services/agents";

interface MessageItemProps extends Message {
  onReadStatusChange: () => void;
}

export function MessageItem({ onReadStatusChange, ...props }: MessageItemProps) {
  const queryClient = useQueryClient();
  
  const toggleReadStatus = useMutation({
    mutationFn: () => toggleMessageReadStatus(props.id, !props.isRead),
    onSuccess: () => {
      onReadStatusChange();
      queryClient.invalidateQueries({ 
        queryKey: ['messages', 'unreadCount'] 
      });
    },
  });

  const formattedDate = new Date(props.timestamp).toLocaleString('pl-PL', {
    day: 'numeric',
    month: 'short',
    hour: '2-digit',
    minute: '2-digit'
  });

  let displayName;
  let agent;

  if (props.senderEmployeeId) {
    const { data: agentData } = useQuery({
      queryKey: ['agent', props.senderEmployeeId],
      queryFn: () => getAgent(props.senderEmployeeId!)
    });
    agent = agentData;
    displayName = agent 
      ? `${agent.fullName}`
      : props.senderDisplayName || 'Loading...';
  } else {
    displayName = 'SYSTEM';
  }

  return (
    <div className="relative border rounded-lg p-4 hover:bg-accent transition-colors">
      <div className="flex justify-between items-start mb-1">
        <div className="flex items-center gap-2">
          <h4 className="font-medium truncate max-w-[400px]">{props.title}</h4>
          {!props.isRead && <Badge variant="secondary">Nowa</Badge>}
        </div>
        <time className="text-sm text-muted-foreground">
          {formattedDate}
        </time>
      </div>
      <p className="text-sm text-muted-foreground mb-2">{props.preview}</p>
      <p className="text-sm mb-4">{props.content}</p>
      
      <div className="border-t pt-3 mt-3">
        <div className="flex justify-between items-center">
          <div>
            <div className="text-xs text-muted-foreground mb-1 flex items-center gap-1">
              <User className="h-3 w-3" />
              Nadawca
            </div>
            <div className="flex items-center gap-2">
              {props.senderEmployeeId && agent && (
                <Avatar className="h-8 w-8">
                  <AvatarImage src={agent.avatarUrl} alt={displayName} />
                  <AvatarFallback>{displayName.split(' ').map((n: string) => n[0]).join('')}</AvatarFallback>
                </Avatar>
              )}
              <span className="text-sm font-medium">{displayName}</span>
            </div>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => toggleReadStatus.mutate()}
            disabled={toggleReadStatus.isPending}
          >
            <FontAwesomeIcon 
              icon={props.isRead ? faEnvelopeOpen : faEnvelope} 
              className={`h-4 w-4 ${props.isRead ? 'text-muted-foreground' : 'text-primary'}`}
            />
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src_frontend/inquiries/components/messages/message-list.tsx">
"use client"

import { useEffect, useState } from "react"
import { useQuery } from "@tanstack/react-query";
import { Message } from "@/app/types/message";
import { MessageItem } from "./message-item";
import { getMessages } from "@/app/services/messages";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

const MESSAGES_PER_PAGE = 5;

export function MessageList() {
  const [showOnlyUnread, setShowOnlyUnread] = useState(() => {
    const stored = localStorage.getItem('showOnlyUnread')
    return stored ? JSON.parse(stored) : false
  })

  const { 
    data, 
    isLoading, 
    error,
    refetch 
  } = useQuery({
    queryKey: ['messages', showOnlyUnread ? 'unread' : 'all'],
    queryFn: async () => {
      const response = await getMessages({ 
        page: 1, 
        limit: MESSAGES_PER_PAGE,
        onlyUnread: showOnlyUnread
      });
      return response;
    },
  });

  const handleToggleChange = (checked: boolean) => {
    setShowOnlyUnread(checked);
    localStorage.setItem('showOnlyUnread', JSON.stringify(checked));
    refetch();
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center space-x-2">
        <Switch
          checked={showOnlyUnread}
          onCheckedChange={handleToggleChange}
        />
        <Label>Pokaż tylko nieprzeczytane</Label>
      </div>
      
      {isLoading ? (
        <p className="text-muted-foreground">Ładowanie wiadomości...</p>
      ) : error ? (
        <p className="text-destructive">Błąd podczas ładowania wiadomości</p>
      ) : !data?.data || data.data.length === 0 ? (
        <p className="text-muted-foreground">Brak wiadomości</p>
      ) : (
        <>
          {data.data.map((message: Message) => (
            <MessageItem 
              key={message.id}
              {...message}
              onReadStatusChange={() => refetch()}
            />
          ))}
        </>
      )}
    </div>
  )
}

export function useUnreadMessages() {
    
  return useQuery({
    queryKey: ['messages', 'unreadCount'],
    queryFn: async () => {
      const response = await getMessages({ 
        page: 1, 
        limit: 100
      });
      return response.data.filter(msg => !msg.isRead).length;
    },
  });
}
</file>

<file path="src_frontend/inquiries/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src_frontend/inquiries/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src_frontend/inquiries/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src_frontend/inquiries/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src_frontend/inquiries/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src_frontend/inquiries/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src_frontend/inquiries/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src_frontend/inquiries/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src_frontend/inquiries/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src_frontend/inquiries/components/ui/navigation-menu.tsx">
import * as React from "react"
import { ChevronDownIcon } from "@radix-ui/react-icons"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDownIcon
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src_frontend/inquiries/components/ui/select.tsx">
"use client"

import * as React from "react"
import {
  CaretSortIcon,
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons"
import * as SelectPrimitive from "@radix-ui/react-select"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src_frontend/inquiries/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src_frontend/inquiries/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src_frontend/inquiries/components/ui/sonner.tsx">
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }
</file>

<file path="src_frontend/inquiries/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src_frontend/inquiries/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src_frontend/inquiries/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="src_frontend/inquiries/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src_frontend/inquiries/.eslintrc.json">
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}
</file>

<file path="src_frontend/inquiries/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="src_frontend/inquiries/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="src_frontend/inquiries/db.json">
{
  "inquiries": [
    {
      "id": "1",
      "title": "Problem z logowaniem do panelu administracyjnego",
      "email": "admin@techfirm.pl",
      "description": "Po aktualizacji systemu nie mogę uzyskać dostępu do panelu administratora",
      "category": "technical",
      "status": "new",
      "createdAt": "2024-03-20T10:30:00.000Z"
    },
    {
      "id": "2",
      "title": "Błąd w generowaniu raportów PDF",
      "email": "maria.wojcik@company.pl",
      "description": "Raporty PDF zawierają nieprawidłowe dane w sekcji podsumowania",
      "category": "technical",
      "status": "in_progress",
      "createdAt": "2024-03-19T15:45:00.000Z"
    },
    {
      "id": "3",
      "title": "Prośba o dodanie integracji z API",
      "email": "dev.team@startup.com",
      "description": "Potrzebujemy dodać integrację z zewnętrznym systemem płatności",
      "category": "technical",
      "status": "new",
      "createdAt": "2024-03-18T09:15:00.000Z"
    },
    {
      "id": "4",
      "title": "Optymalizacja czasu ładowania strony",
      "email": "performance.lead@corp.pl",
      "description": "Strona główna ładuje się ponad 5 sekund na urządzeniach mobilnych",
      "category": "technical",
      "status": "in_progress",
      "createdAt": "2024-03-17T14:20:00.000Z"
    },
    {
      "id": "5",
      "title": "Aktualizacja danych firmowych",
      "email": "office@smallbusiness.pl",
      "description": "Prosimy o zmianę adresu siedziby w profilu firmy",
      "category": "general",
      "status": "closed",
      "createdAt": "2024-03-16T11:30:00.000Z"
    }
  ],
  "tickets": [
    {
      "id": "1",
      "title": "Problem z logowaniem do panelu administracyjnego",
      "email": "admin@techfirm.pl",
      "description": "Po aktualizacji systemu nie mogę uzyskać dostępu do panelu administratora",
      "descriptionTranslated": "After the system update, I cannot access the administrator panel",
      "category": "technical",
      "status": "new",
      "createdAt": "2024-03-20T10:30:00.000Z",
      "deadline": "2024-03-20T22:00:00.000Z",
      "severity": "high",
      "employeeId": "2"
    },
    {
      "id": "2",
      "title": "Błąd w generowaniu raportów PDF",
      "email": "maria.wojcik@company.pl",
      "description": "Raporty PDF zawierają nieprawidłowe dane w sekcji podsumowania",
      "descriptionTranslated": "PDF reports contain incorrect data in the summary section",
      "category": "technical",
      "status": "in_progress",
      "createdAt": "2024-03-19T15:45:00.000Z",
      "severity": "medium",
      "employeeId": null
    },
    {
      "id": "3",
      "title": "Prośba o dodanie integracji z API",
      "email": "dev.team@startup.com",
      "description": "Potrzebujemy dodać integrację z zewnętrznym systemem płatności",
      "descriptionTranslated": "We need to add integration with an external payment system",
      "category": "technical",
      "status": "new",
      "createdAt": "2024-03-18T09:15:00.000Z",
      "severity": "medium",
      "employeeId": null,
      "agentId": "00000000-0000-0000-0000-000000000002"
    },
    {
      "id": "4",
      "title": "Optymalizacja czasu ładowania strony",
      "email": "performance.lead@corp.pl",
      "description": "Strona główna ładuje się ponad 5 sekund na urządzeniach mobilnych",
      "descriptionTranslated": "The homepage takes over 5 seconds to load on mobile devices",
      "category": "technical",
      "status": "in_progress",
      "createdAt": "2024-03-17T14:20:00.000Z",
      "deadline": "2024-03-19T14:20:00.000Z",
      "severity": "medium",
      "employeeId": "2"
    },
    {
      "id": "5",
      "title": "Aktualizacja danych firmowych",
      "email": "office@smallbusiness.pl",
      "description": "Prosimy o zmianę adresu siedziby w profilu firmy",
      "descriptionTranslated": null,
      "category": "general",
      "status": "in_progress",
      "createdAt": "2024-03-16T11:30:00.000Z",
      "severity": "low",
      "employeeId": "1"
    }
  ],
  "employees": [
    {
      "id": "1",
      "name": "Bogusław",
      "surname": "Złotówa",
      "position": "Supervisor",
      "avatarUrl": "https://api.dicebear.com/9.x/notionists/svg?seed=Boguslaw&radius=50"
    },
    {
      "id": "2",
      "name": "Ziemowit",
      "surname": "Pędziwiatr",
      "position": "Agent",
      "avatarUrl": "https://api.dicebear.com/9.x/notionists/svg?seed=Ziemowit&radius=50"
    },
    {
      "id": "3",
      "name": "Kunegunda",
      "surname": "Śmieszek",
      "position": "Agent",
      "avatarUrl": "https://api.dicebear.com/9.x/notionists/svg?seed=Kunegunda&radius=50"
    }
  ],
  "notifications": [
    {
      "id": "1",
      "message": "Nowy ticket #123 został przypisany do Ciebie",
      "createdAt": "2024-03-20T14:30:00.000Z",
      "isRead": false,
      "type": "assignment"
    },
    {
      "id": "2",
      "message": "Deadline dla ticketu #456 za 2 godziny",
      "createdAt": "2024-03-20T13:15:00.000Z",
      "isRead": false,
      "type": "deadline"
    },
    {
      "id": "3",
      "message": "Nowy ticket #789 został utworzony",
      "createdAt": "2024-03-20T12:00:00.000Z",
      "isRead": true,
      "type": "new_ticket"
    }
  ],
  "metrics": {
    "services": [
      {
        "name": "Zgłoszenia",
        "status": "healthy",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": {
          "cpu": {
            "usage": 45,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 45
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 42
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 47
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 44
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 46
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 43
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 45
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 48
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 44
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 46
              }
            ]
          },
          "memory": {
            "used": 2048,
            "total": 4096,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 2048
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 2156
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 2012
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 1986
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 2245
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 2167
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 2089
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 1956
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 2134
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 2078
              }
            ]
          }
        }
      },
      {
        "name": "Tickety",
        "status": "healthy",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": {
          "cpu": {
            "usage": 38,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 38
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 35
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 39
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 36
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 37
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 40
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 38
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 35
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 37
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 39
              }
            ]
          },
          "memory": {
            "used": 1536,
            "total": 4096,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 1536
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 1498
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 1567
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 1523
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 1489
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 1545
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 1578
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 1534
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 1512
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 1490
              }
            ]
          }
        }
      },
      {
        "name": "Tłumaczenia",
        "status": "error",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": {
          "cpu": {
            "usage": 92,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 92
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 88
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 85
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 90
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 87
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 89
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 86
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 91
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 88
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 86
              }
            ]
          },
          "memory": {
            "used": 3584,
            "total": 4096,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 3584
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 3498
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 3612
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 3567
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 3489
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 3523
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 3478
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 3534
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 3589
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 3512
              }
            ]
          }
        }
      },
      {
        "name": "SLA",
        "status": "healthy",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": {
          "cpu": {
            "usage": 25,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 25
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 23
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 26
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 24
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 27
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 25
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 22
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 24
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 26
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 23
              }
            ]
          },
          "memory": {
            "used": 1024,
            "total": 4096,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 1024
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 1056
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 1012
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 1078
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 1045
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 1034
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 1067
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 1023
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 1089
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 1045
              }
            ]
          }
        }
      },
      {
        "name": "Komunikacja",
        "status": "unknown",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": null
      },
      {
        "name": "Metryki systemowe",
        "status": "healthy",
        "lastChecked": "2024-03-20T10:00:00.000Z",
        "metrics": {
          "cpu": {
            "usage": 32,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 32
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 30
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 33
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 31
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 34
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 32
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 29
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 31
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 33
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 30
              }
            ]
          },
          "memory": {
            "used": 1280,
            "total": 4096,
            "history": [
              {
                "timestamp": "2024-03-20T10:00:00.000Z",
                "value": 1280
              },
              {
                "timestamp": "2024-03-20T09:50:00.000Z",
                "value": 1312
              },
              {
                "timestamp": "2024-03-20T09:40:00.000Z",
                "value": 1289
              },
              {
                "timestamp": "2024-03-20T09:30:00.000Z",
                "value": 1267
              },
              {
                "timestamp": "2024-03-20T09:20:00.000Z",
                "value": 1298
              },
              {
                "timestamp": "2024-03-20T09:10:00.000Z",
                "value": 1278
              },
              {
                "timestamp": "2024-03-20T09:00:00.000Z",
                "value": 1256
              },
              {
                "timestamp": "2024-03-20T08:50:00.000Z",
                "value": 1287
              },
              {
                "timestamp": "2024-03-20T08:40:00.000Z",
                "value": 1301
              },
              {
                "timestamp": "2024-03-20T08:30:00.000Z",
                "value": 1276
              }
            ]
          }
        }
      }
    ]
  },
  "messages": [
    {
      "id": "1",
      "title": "Problem z logowaniem",
      "preview": "Dzień dobry, mam problem z zalogowaniem się do systemu...",
      "content": "Dzień dobry, mam problem z zalogowaniem się do systemu. Po wpisaniu poprawnych danych system wyświetla błąd 'Nieprawidłowe dane'. Proszę o pomoc w rozwiązaniu problemu.",
      "senderDisplayName": "Bogusław Złotówa",
      "senderEmployeeId": "00000000-0000-0000-0000-000000000001",
      "timestamp": "2024-03-21T10:30:00.000Z",
      "isUnread": true
    },
    {
      "id": "2",
      "title": "Aktualizacja statusu zgłoszenia #123",
      "preview": "Twoje zgłoszenie zostało zaktualizowane. Nasz zespół techniczny...",
      "content": "Twoje zgłoszenie zostało zaktualizowane. Nasz zespół techniczny rozpoczął pracę nad rozwiązaniem zgłoszonego problemu. Będziemy informować o postępach.",
      "senderDisplayName": "System",
      "timestamp": "2024-03-21T09:15:00.000Z",
      "isUnread": true
    },
    {
      "id": "3",
      "title": "RE: Pytanie o fakturę",
      "preview": "Dziękujemy za kontakt. Faktura została wysłana ponownie na wskazany adres email...",
      "content": "Dziękujemy za kontakt. Faktura została wysłana ponownie na wskazany adres email. Proszę sprawdzić również folder SPAM. W razie dalszych problemów prosimy o kontakt.",
      "senderDisplayName": "Ziemowit Pędziwiatr",
      "senderEmployeeId": "00000000-0000-0000-0000-000000000002",
      "timestamp": "2024-03-20T15:45:00.000Z",
      "isUnread": true
    }
  ]
}
</file>

<file path="src_frontend/inquiries/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  basePath: '',
  async redirects() {
    return [
      {
        source: '/',
        destination: '/inquiries-list',
        permanent: true,
      },
    ]
  },
}

export default nextConfig
</file>

<file path="src_frontend/inquiries/package.json">
{
  "name": "inquiries",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 21000",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "mock-api": "json-server --watch db.json --port 21370"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.6.0",
    "@fortawesome/free-brands-svg-icons": "^6.6.0",
    "@fortawesome/free-solid-svg-icons": "^6.6.0",
    "@fortawesome/react-fontawesome": "^0.2.2",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-icons": "^1.3.1",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.2",
    "@shadcn/ui": "^0.0.4",
    "@tanstack/react-query": "^5.59.20",
    "@tanstack/react-query-devtools": "^5.59.20",
    "@tanstack/react-table": "^8.20.5",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "geist": "^1.3.1",
    "lucide-react": "^0.454.0",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.53.1",
    "shadcn-ui": "^0.2.3",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/next": "^9.0.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "@types/react-query": "^1.2.9",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "json-server": "^1.0.0-beta.3",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="src_frontend/inquiries/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="src_frontend/inquiries/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="src_frontend/inquiries/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src_frontend/technical/app/applications-list/page.tsx">
"use client"

import { ApplicationTile } from "@/components/application-tile";
import { faServer, faDatabase, faTicket, faBug, faStopwatch, faComments } from "@fortawesome/free-solid-svg-icons";

export default function ApplicationsList() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
      <ApplicationTile 
        applicationName="Inquiries.Service"
        applicationBaseAddress="http://localhost:5011"
        icon={faBug}
      />
      <ApplicationTile 
        applicationName="Tickets.Service"
        applicationBaseAddress="http://localhost:5112"
        icon={faTicket}
      />
      <ApplicationTile 
        applicationName="SLA"
        applicationBaseAddress="http://localhost:5054"
        icon={faStopwatch}
      />
      <ApplicationTile 
        applicationName="Communication"
        applicationBaseAddress="http://localhost:5148"
        icon={faComments}
      />
    </div>
  );
}
</file>

<file path="src_frontend/technical/app/lib/translations.ts">
import { TicketCategory, TicketStatus, SeverityLevel, TicketType } from "@/app/types/enums";

export const ticketCategoryTranslations = {
  [TicketCategory.General]: "Ogólne",
  [TicketCategory.Technical]: "Techniczne",
  [TicketCategory.Billing]: "Płatności",
  [TicketCategory.Other]: "Inne",
} as const;

export const ticketStatusTranslations = {
  [TicketStatus.Unknown]: "Nieznany",
  [TicketStatus.WaitingForScheduledAction]: "Oczekujące na akcję systemu",
  [TicketStatus.BeforeQualification]: "Przed kwalifikacją",
  [TicketStatus.Qualified]: "Zakwalifikowane",
  [TicketStatus.Resolved]: "Rozwiązane",
  [TicketStatus.Blocked]: "Zablokowane",
} as const;

export const ticketSeverityTranslations = {
  [SeverityLevel.Low]: "Niski",
  [SeverityLevel.Medium]: "Średni",
  [SeverityLevel.High]: "Wysoki",
  [SeverityLevel.Critical]: "Krytyczny",
} as const; 

export const ticketTypeTranslations = {
  [TicketType.Unknown]: "Nieznany",
  [TicketType.Incident]: "Incydent",
  [TicketType.Question]: "Pytanie",
} as const;
</file>

<file path="src_frontend/technical/app/providers/tanstack-provider.tsx">

</file>

<file path="src_frontend/technical/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}


@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24.6 95% 53.1%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24.6 95% 53.1%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 20.5 90.2% 48.2%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 20.5 90.2% 48.2%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src_frontend/technical/app/layout.tsx">
import type { Metadata } from "next";
import { GeistSans } from 'geist/font/sans';
import "./globals.css";
import { Providers } from "./providers";
import { config } from '@fortawesome/fontawesome-svg-core'
import '@fortawesome/fontawesome-svg-core/styles.css'
import { CustomNavigationMenu } from '@/components/custom/custom-nav';
import { Footer } from "@/components/custom/footer";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faScrewdriverWrench } from "@fortawesome/free-solid-svg-icons";
import { Toaster } from "sonner"

config.autoAddCss = false

export const metadata: Metadata = {
  title: "TicketFlow - Panel admina"
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className="h-full">
      <body className={`${GeistSans.className} h-full dark:bg-background`}>
        <Providers>
          <div className="mx-auto w-full h-full flex flex-col bg-background border-border/40 dark:border-border min-[1800px]:max-w-[1536px] min-[1800px]:border-x">
            <header className="border-b">
              <div className="container flex h-14 items-center px-8 w-full">
                <CustomNavigationMenu />
              </div>
            </header>

            <div className="container flex-1 py-8 px-8 w-full mx-auto">
              <main className="flex flex-col gap-8 items-center sm:items-start w-full h-full mx-auto">
                <Card className="w-full h-full mx-auto border-none">
                  <CardHeader>
                    <CardTitle><h3 className="scroll-m-20 pb-2 text-3xl font-semibold tracking-tight first:mt-0">
                        <FontAwesomeIcon className="pr-4" icon={faScrewdriverWrench} /> 
                      Dashboard techniczny - aplikacje
                    </h3>
                  </CardTitle>
                  <CardDescription>
                    Tu możesz sterować zachowaniem systemu by zrozumieć potencjalne anomalie
                  </CardDescription>
                </CardHeader>
                <CardContent>
                    {children}
                </CardContent>
              </Card>
            </main>
          </div>
            <div className="w-full mx-auto">
              <Footer />
            </div>
          </div>
          <Toaster />
        </Providers>
      </body>
    </html>
  )
}
</file>

<file path="src_frontend/technical/app/page.tsx">
'use client'

import { redirect } from 'next/navigation'

export default function Page() {
  redirect('/applications-list')
}
</file>

<file path="src_frontend/technical/app/providers.tsx">
"use client"

import { ThemeProvider } from "next-themes"
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'
import { TooltipProvider } from "@/components/ui/tooltip"

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
      <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
        {children}
      </ThemeProvider>
      </TooltipProvider>
    </QueryClientProvider>
  )
}
</file>

<file path="src_frontend/technical/components/custom/custom-nav.tsx">
"use client"

import {
    NavigationMenu,
    NavigationMenuItem,
    NavigationMenuLink,
    NavigationMenuList,
    navigationMenuTriggerStyle,
  } from "@/components/ui/navigation-menu";
import Link from "next/link";
import React from "react";

export function CustomNavigationMenu() {

  const menuItemStyle = "group inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50";

  return (
    <div className="flex items-center justify-between w-full gap-4 px-8">
      <div className="flex items-center gap-4">
        <div className="flex items-center pr-4">
            <img 
                src="/img/ticketflow_logo.png" 
                alt="TicketFlow Logo"
                width="124"
                height="auto"
            />
        </div>
        
        <NavigationMenu>
          <NavigationMenuList>
            <NavigationMenuItem className="pr-2">
              <Link href="http://localhost:21000" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle}>
                  Zgłoszenia
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
            <NavigationMenuItem className="pr-2">
              <Link href="http://localhost:21001" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle}>
                  Tickety
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
            <NavigationMenuItem className="pr-2">
              <Link href="/applications-list" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle} active={true}>
                  Panel admina
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
          </NavigationMenuList>
        </NavigationMenu>
      </div>

      <div className="flex items-center gap-2">
      </div>
    </div>
  );
}
</file>

<file path="src_frontend/technical/components/custom/data-table.tsx">
"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Button } from "../ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
  pagination: {
    page: number
    pageSize: number
    totalPages: number
    onPageChange: (page: number) => void
  }
}

export function DataTable<TData, TValue>({
  columns,
  data,
  pagination,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    manualPagination: true,
    pageCount: pagination.totalPages,
  })

  return (
    <div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  )
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      {pagination.totalPages > 1 && (
        <div className="flex items-center justify-end space-x-2 py-4">
          <Button
            variant="outline"
            size="sm"
            onClick={() => pagination.onPageChange(pagination.page - 1)}
            disabled={pagination.page <= 1}
          >
            Poprzednia
          </Button>
          <div className="flex-1 text-sm text-muted-foreground text-center">
            Strona {pagination.page} z {pagination.totalPages}
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={() => pagination.onPageChange(pagination.page + 1)}
            disabled={pagination.page >= pagination.totalPages}
          >
            Następna
          </Button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src_frontend/technical/components/custom/footer.tsx">
import Image from "next/image";
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { 
  faGithub, 
  faYoutube, 
  faDiscord, 
  faInstagram, 
  faTwitter, 
  faLinkedinIn 
} from '@fortawesome/free-brands-svg-icons';

export function Footer() {
  return (
    <footer className="border-t py-4 bg-black">
      <div className="container flex flex-col items-center gap-3 mx-auto">
        <div className="flex items-center gap-4">
          <a href="https://devmentors.io">
            <Image 
              src="/img/devmentors-logo.png" 
              alt="DevMentors Logo" 
              width={80}
              height={19}
              className="h-auto w-auto"
            />
          </a>
          <a href="https://github.com/devmentors" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faGithub} />
          </a>
          <a href="https://www.youtube.com/@DevMentorsPL" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faYoutube} />
          </a>
          <a href="https://devmentors.io/discordpl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faDiscord} />
          </a>
          <a href="https://www.instagram.com/devmentors_pl/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faInstagram} />
          </a>
          <a href="https://twitter.com/dev_mentors_pl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faTwitter} />
          </a>
          <a href="https://www.linkedin.com/company/devmentors-io/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faLinkedinIn} />
          </a>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src_frontend/technical/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src_frontend/technical/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src_frontend/technical/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src_frontend/technical/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src_frontend/technical/components/ui/command.tsx">
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"
import { MagnifyingGlassIcon } from "@radix-ui/react-icons"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <MagnifyingGlassIcon className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src_frontend/technical/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src_frontend/technical/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src_frontend/technical/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src_frontend/technical/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src_frontend/technical/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src_frontend/technical/components/ui/navigation-menu.tsx">
import * as React from "react"
import { ChevronDownIcon } from "@radix-ui/react-icons"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDownIcon
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src_frontend/technical/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src_frontend/technical/components/ui/select.tsx">
"use client"

import * as React from "react"
import {
  CaretSortIcon,
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons"
import * as SelectPrimitive from "@radix-ui/react-select"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src_frontend/technical/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src_frontend/technical/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src_frontend/technical/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src_frontend/technical/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src_frontend/technical/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="src_frontend/technical/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src_frontend/technical/components/application-tile.tsx">
"use client";

import { useState, useEffect } from "react";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { toast } from "sonner";
import { AnomalyType, EnableAnomalyRequest, AnomalyDescription } from "@/types/anomaly";
import { IconDefinition } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { anomalyTypeLabels } from "@/types/anomaly";
import { Separator } from "@/components/ui/separator";
import { MESSAGE_TYPES } from "@/types/message";
import { faEnvelope } from "@fortawesome/free-solid-svg-icons";

interface ApplicationTileProps {
    applicationName: string;
    applicationBaseAddress: string;
    icon?: IconDefinition;
}

export function ApplicationTile({ applicationName, applicationBaseAddress, icon }: ApplicationTileProps) {
    const [enabledAnomalies, setEnabledAnomalies] = useState<AnomalyDescription[]>([]);
    const [newAnomaly, setNewAnomaly] = useState<Partial<EnableAnomalyRequest>>({
        anomalyType: undefined,
        messageType: "",
        additionalParams: new Map()
    });
    const [paramKey, setParamKey] = useState<string>('StatusFilter');
    const [paramValue, setParamValue] = useState<string>('');

    const fetchAnomalies = async () => {
        try {
            const response = await fetch(`${applicationBaseAddress}/anomalies`);
            if (!response.ok) throw new Error('Failed to fetch anomalies');
            const data = await response.json();
            setEnabledAnomalies(data);
        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            toast.error(`Failed to fetch anomalies: ${errorMessage}`);
        }
    };

    useEffect(() => {
        fetchAnomalies();
    }, [applicationBaseAddress]);

    const enableAnomaly = async () => {
        if (!newAnomaly.anomalyType || !newAnomaly.messageType) {
            toast.error("Please fill in all required fields");
            return;
        }

        try {
            const requestBody = {
                ...newAnomaly,
                additionalParams: newAnomaly.additionalParams ? Object.fromEntries(newAnomaly.additionalParams) : {}
            };

            const response = await fetch(`${applicationBaseAddress}/anomalies`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody),
            });

            if (!response.ok) throw new Error('Failed to enable anomaly');
            
            toast.success("Anomaly enabled successfully");
            fetchAnomalies();
            
            // Reset all form states
            setNewAnomaly({
                anomalyType: undefined,
                messageType: "",
                additionalParams: new Map()
            });
            setParamKey('StatusFilter');
            setParamValue('');
            
        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            toast.error(`Failed to enable anomaly: ${errorMessage}`);
        }
    };

    const disableAnomaly = async (anomalyType: string, messageType: string) => {
        try {
            const response = await fetch(
                `${applicationBaseAddress}/anomalies/${anomalyType}/messages/${messageType}`,
                { method: 'DELETE' }
            );

            if (!response.ok) throw new Error('Failed to disable anomaly');
            
            toast.success("Anomaly disabled successfully");
            fetchAnomalies();
        } catch (error: unknown) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
            toast.error(`Failed to disable anomaly: ${errorMessage}`);
        }
    };

    return (
        <Card className="w-full">
            <CardHeader className="pb-2">
                <CardTitle className="flex items-center gap-2 text-2xl pb-2">
                    {icon && <FontAwesomeIcon icon={icon} className="h-6 w-6" />}
                    {applicationName}
                </CardTitle>
                <Separator className="mt-2" />
            </CardHeader>
            <div className="mt-2">
                <CardContent>
                    <div className="space-y-2">
                        <h4 className="text-sm font-semibold">Włącz nową anomalię</h4>
                        
                        <div className="flex gap-4 mb-2">
                            <Select
                                value={newAnomaly.anomalyType}
                                onValueChange={(value) => 
                                    setNewAnomaly(prev => ({ ...prev, anomalyType: value as AnomalyType }))
                                }
                            >
                                <SelectTrigger>
                                    <SelectValue placeholder="Wybierz typ anomalii" />
                                </SelectTrigger>
                                <SelectContent>
                                    {Object.values(AnomalyType).map((type) => (
                                        <SelectItem key={type} value={type}>
                                            {anomalyTypeLabels[type]}
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>

                            <Select
                                value={newAnomaly.messageType}
                                onValueChange={(value) => 
                                    setNewAnomaly(prev => ({ ...prev, messageType: value }))
                                }
                            >
                                <SelectTrigger>
                                    <SelectValue placeholder="Wybierz typ wiadomości" />
                                </SelectTrigger>
                                <SelectContent>
                                    {MESSAGE_TYPES.map((type) => (
                                        <SelectItem key={type} value={type}>
                                            {type}
                                        </SelectItem>
                                    ))}
                                </SelectContent>
                            </Select>
                        </div>

                        <div className="flex-1 border rounded-lg p-4">
                            <div className="grid grid-cols-2 gap-4">
                                <div className="space-y-2">
                                    <label className="text-sm font-medium">Parameter</label>
                                    <Select
                                        value={paramKey}
                                        onValueChange={setParamKey}
                                    >
                                        <SelectTrigger>
                                            <SelectValue placeholder="Wybierz parametr" />
                                        </SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="StatusFilter">Filtrowanie po statusie</SelectItem>
                                            <SelectItem 
                                                value="DelayInMs" 
                                                disabled={!(newAnomaly.anomalyType === AnomalyType.ConsumerDelayBeforeHandler || 
                                                           newAnomaly.anomalyType === AnomalyType.ConsumerDelayAfterHandler)}
                                                title={!(newAnomaly.anomalyType === AnomalyType.ConsumerDelayBeforeHandler || 
                                                        newAnomaly.anomalyType === AnomalyType.ConsumerDelayAfterHandler) 
                                                    ? "Dostępne tylko dla anomalii opóźniających" 
                                                    : undefined}
                                            >
                                                Opóźnienie (ms)
                                            </SelectItem>
                                        </SelectContent>
                                    </Select>
                                </div>

                                <div className="space-y-2">
                                    <label className="text-sm font-medium">Wartość</label>
                                    <div className="flex gap-2">
                                        <Input
                                            type="text"
                                            placeholder="Wartość parametru"
                                            value={paramValue}
                                            onChange={(e) => setParamValue(e.target.value)}
                                        />
                                        <Button 
                                            variant="secondary"
                                            onClick={() => {
                                                if (paramKey && paramValue) {
                                                    setNewAnomaly(prev => {
                                                        const newParams = new Map(prev.additionalParams);
                                                        newParams.set(paramKey, paramValue);
                                                        return { ...prev, additionalParams: newParams };
                                                    });
                                                    setParamValue('');
                                                }
                                            }}
                                        >
                                            Dodaj
                                        </Button>
                                    </div>
                                </div>
                            </div>

                            {/* Display added parameters */}
                            {newAnomaly.additionalParams && newAnomaly.additionalParams.size > 0 && (
                                <div className="mt-4">
                                    <label className="text-sm font-medium">Dodane parametry:</label>
                                    <div className="mt-2 space-y-2">
                                        {Array.from(newAnomaly.additionalParams).map(([key, value]) => (
                                            <div key={key} className="flex items-center justify-between bg-secondary/20 p-2 rounded-md">
                                                <span className="text-sm">
                                                    {key}: {value}
                                                </span>
                                                <Button
                                                    variant="ghost"
                                                    size="sm"
                                                    onClick={() => {
                                                        setNewAnomaly(prev => {
                                                            const newParams = new Map(prev.additionalParams);
                                                            newParams.delete(key);
                                                            return { ...prev, additionalParams: newParams };
                                                        });
                                                    }}
                                                >
                                                    Usuń
                                                </Button>
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            )}
                        </div>

                        <Button 
                            className="w-full mt-4"
                            onClick={enableAnomaly}
                        >
                            Włącz anomalię
                        </Button>
                    </div>

                    <Separator className="my-6" />

                    <div className="space-y-2">
                        <h4 className="text-sm font-semibold">Włączone anomalie</h4>
                        {enabledAnomalies.length === 0 ? (
                            <p className="text-sm text-muted-foreground">Brak włączonych anomalii</p>
                        ) : (
                            <div className="space-y-2">
                                {enabledAnomalies.map((anomaly, index) => (
                                    <div key={index} className="flex items-center justify-between p-2 border rounded-lg">
                                        <div>
                                            <p className="font-medium">{anomalyTypeLabels[anomaly.anomalyType as AnomalyType] || anomaly.anomalyType}</p>
                                            <p className="text-sm text-muted-foreground">
                                                <FontAwesomeIcon icon={faEnvelope} className="mr-2" />
                                                {anomaly.messageType}
                                            </p>
                                            {Object.entries(anomaly.params).map(([key, value]) => (
                                                <p key={key} className="text-sm text-muted-foreground">
                                                    {key}: {value}
                                                </p>
                                            ))}
                                        </div>
                                        <Button
                                            variant="destructive"
                                            size="sm"
                                            onClick={() => disableAnomaly(anomaly.anomalyType, anomaly.messageType)}
                                        >
                                            Wyłącz
                                        </Button>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </CardContent>
            </div>
        </Card>
    );
}
</file>

<file path="src_frontend/technical/lib/axios.ts">
import axios from 'axios';

// Create axios instance with default config
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5002',
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;
</file>

<file path="src_frontend/technical/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src_frontend/technical/types/anomaly.ts">
export enum AnomalyType {
    ConsumerErrorBeforeHandler = "ConsumerErrorBeforeHandler",
    ConsumerErrorAfterHandler = "ConsumerErrorAfterHandler",
    ConsumerDelayBeforeHandler = "ConsumerDelayBeforeHandler",
    ConsumerDelayAfterHandler = "ConsumerDelayAfterHandler",
    ProducerErrorBeforeTransaction = "ProducerErrorBeforeTransaction",
    ProducerErrorWithinTransaction = "ProducerErrorWithinTransaction",
    ProducerErrorAfterTransaction = "ProducerErrorAfterTransaction",
    OutboxErrorOnSave = "OutboxErrorOnSave",
    OutboxErrorOnPublish = "OutboxErrorOnPublish"
}

export interface EnableAnomalyRequest {
    anomalyType: AnomalyType;
    messageType: string;
    additionalParams: Map<string, string>;
}

export interface AnomalyDescription {
    anomalyType: string;
    messageType: string;
    params: Record<string, string>;
}

// Add translations
export const anomalyTypeLabels: Record<AnomalyType, string> = {
    ConsumerErrorBeforeHandler: "Błąd konsumenta przed handlerem",
    ConsumerErrorAfterHandler: "Błąd konsumenta po handlerze",
    ConsumerDelayBeforeHandler: "Opóźnienie konsumenta przed handlerem",
    ConsumerDelayAfterHandler: "Opóźnienie konsumenta po handlerze",
    ProducerErrorBeforeTransaction: "Błąd producenta przed transakcją",
    ProducerErrorWithinTransaction: "Błąd producenta w trakcie transakcji",
    ProducerErrorAfterTransaction: "Błąd producenta po transakcji",
    OutboxErrorOnSave: "Błąd outboxa podczas zapisu",
    OutboxErrorOnPublish: "Błąd outboxa podczas publikacji"
};
</file>

<file path="src_frontend/technical/types/message.ts">
export const MESSAGE_TYPES = [
    "InquirySubmitted",
    "TicketCreated",
    "TicketQualified",
    "AgentAssignedToTicket",
    "TicketBlocked",
    "TicketResolved",
    "RequestTranslationV1",
    "RequestTranslationV2",
    "TranslationCompleted",
    "TranslationSkipped",
    "DeadlinesCalculated",
] as const;

export type MessageType = typeof MESSAGE_TYPES[number];
</file>

<file path="src_frontend/technical/.eslintrc.json">
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}
</file>

<file path="src_frontend/technical/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="src_frontend/technical/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="src_frontend/technical/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  basePath: '',
  async redirects() {
    return [
      {
        source: '/',
        destination: '/applications-list',
        permanent: true,
      },
    ]
  },
}

export default nextConfig
</file>

<file path="src_frontend/technical/package.json">
{
  "name": "technical",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 21002",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.6.0",
    "@fortawesome/free-brands-svg-icons": "^6.6.0",
    "@fortawesome/free-solid-svg-icons": "^6.6.0",
    "@fortawesome/react-fontawesome": "^0.2.2",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-icons": "^1.3.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-separator": "^1.1.0",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@shadcn/ui": "^0.0.4",
    "@tanstack/react-query": "^5.59.20",
    "@tanstack/react-table": "^8.20.5",
    "@types/recharts": "^1.8.29",
    "axios": "^1.7.8",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "geist": "^1.3.1",
    "lucide-react": "^0.454.0",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.53.1",
    "recharts": "^2.13.3",
    "shadcn-ui": "^0.2.3",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.23.8",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@types/next": "^9.0.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="src_frontend/technical/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="src_frontend/technical/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="src_frontend/technical/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src_frontend/tickets/app/lib/translations.ts">
import { TicketCategory, TicketStatus, SeverityLevel, TicketType } from "@/app/types/enums";

export const ticketCategoryTranslations = {
  [TicketCategory.General]: "Ogólne",
  [TicketCategory.Technical]: "Techniczne",
  [TicketCategory.Billing]: "Płatności",
  [TicketCategory.Other]: "Inne",
} as const;

export const ticketStatusTranslations = {
  [TicketStatus.Unknown]: "Nieznany",
  [TicketStatus.WaitingForScheduledAction]: "Oczekujące na akcję systemu",
  [TicketStatus.BeforeQualification]: "Przed kwalifikacją",
  [TicketStatus.Qualified]: "Zakwalifikowane",
  [TicketStatus.Resolved]: "Rozwiązane",
  [TicketStatus.Blocked]: "Zablokowane",
} as const;

export const ticketSeverityTranslations = {
  [SeverityLevel.Low]: "Niski",
  [SeverityLevel.Medium]: "Średni",
  [SeverityLevel.High]: "Wysoki",
  [SeverityLevel.Critical]: "Krytyczny",
} as const; 

export const ticketTypeTranslations = {
  [TicketType.Unknown]: "Nieznany",
  [TicketType.Incident]: "Incydent",
  [TicketType.Question]: "Pytanie",
} as const;
</file>

<file path="src_frontend/tickets/app/providers/tanstack-provider.tsx">

</file>

<file path="src_frontend/tickets/app/tickets-list/page.tsx">
"use client"

import React from "react"
import { DataTable } from "@/components/custom/data-table"
import { columns } from "./ticket"
import { useTickets } from "@/hooks/use-tickets"
import { Button } from "@/components/ui/button"
import { RotateCw, Loader2 } from "lucide-react"

export default function TicketsList() {
  const [page, setPage] = React.useState(1);
  const limit = 10;
  
  const { data, isLoading, isFetching, refetch } = useTickets({
    page,
    limit
  });
  const totalPages = data ? Math.ceil(data.totalCount / limit) : 1;

  return (
    <div className="container mx-auto py-4">
      <div className="mb-4 flex justify-between items-center">
        <h1 className="text-2xl font-bold">Lista ticketów</h1>
        <Button
          variant="outline"
          size="sm"
          onClick={() => refetch()}
          disabled={isFetching}
        >
          <RotateCw className={`h-4 w-4 mr-2 ${isFetching ? 'animate-spin' : ''}`} />
          Odśwież
        </Button>
      </div>
      {isFetching ? (
        <div className="flex justify-center items-center h-[400px]">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      ) : (
        <DataTable 
          columns={columns} 
          data={data?.data || []}
          pagination={{
            page,
            pageSize: limit,
            totalPages,
            onPageChange: setPage
          }}
        />
      )}
    </div>
  )
}
</file>

<file path="src_frontend/tickets/app/tickets-list/ticket.tsx">
"use client"

import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { ColumnDef } from "@tanstack/react-table"
import { MoreHorizontal, Loader2 } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"

import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuTrigger,
  DropdownMenuGroup,
} from "@/components/ui/dropdown-menu"

import { TicketCategory, SeverityLevel, TicketStatus } from '@/app/types/enums'
import { ticketCategoryTranslations, ticketStatusTranslations, ticketSeverityTranslations } from "@/app/lib/translations";
import { useAgent, useAgents, Agent } from "@/hooks/use-agents"
import { useAssignAgent, useBlockTicket, useUnblockTicket, useResolveTicket } from "@/hooks/use-tickets"
import { toast } from "sonner"
import { Ticket } from "@/types/ticket";
import { severityConfig, statusConfig } from "@/lib/ticket-styling"
import { TicketDetails } from "@/components/ticket-details"
import { useAgentStore } from "@/store/use-agent-store"
import { TicketSettingsDialog } from "@/components/ticket-settings-dialog"
import { 
  faUserPlus, 
  faUserMinus,
  faClipboardCheck,
  faEye,
  faQuestion,
  faLock,
  faUnlock,
  faCheck
} from "@fortawesome/free-solid-svg-icons"
import { Tooltip, TooltipContent, TooltipTrigger, TooltipProvider } from "@/components/ui/tooltip"
import { useState } from "react"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"

function groupAgentsByPosition(agents: Agent[]) {
  return agents?.reduce((groups, agent) => {
    const position = agent.position || 'Other';
    return {
      ...groups,
      [position]: [...(groups[position] || []), agent]
    };
  }, {} as Record<string, Agent[]>);
}

export const columns: ColumnDef<Ticket>[] = [
  {
    accessorKey: "title",
    header: "Tytuł",
    cell: ({ row }) => {
      const title = row.getValue("title") as string;
      const category = row.original.category as TicketCategory;
      
      const categoryLabel = ticketCategoryTranslations[category];
      
      return (
        <div className="flex items-center">
          <span className="font-medium text-muted-foreground mr-2">[{categoryLabel || category}]</span>
          <span>{title}</span>
        </div>
      );
    }
  },
  {
    accessorKey: "status",
    header: "Status",
    cell: ({ row }) => {
      const status = row.getValue("status") as TicketStatus;
      
      if (!statusConfig) {
        console.error('statusConfig is undefined');
        return <div>Loading...</div>;
      }

      const config = statusConfig[status] || {
        variant: "secondary",
        icon: faQuestion,
        label: ticketStatusTranslations[status] || "Unknown"
      };

      return (
        <div className="flex justify-start items-center">
          <Badge variant={config.variant}>
            <FontAwesomeIcon icon={config.icon} className="mr-2" />
            {config.label}
          </Badge>
        </div>
      )
    }
  },
  {
    accessorKey: "createdAt",
    header: "Data przesłania",
    cell: ({ row }) => {
      return <div>
        {(row.getValue("createdAt") as Date).toLocaleString('pl-PL', {
          dateStyle: 'short',
          timeStyle: 'short'
        })}
      </div>
    },
  },
  {
    accessorKey: "severityLevel",
    header: "Priorytet",
    cell: ({ row }) => {
      const severity = row.getValue("severityLevel") as SeverityLevel | null;
      
      if (!severity) {
        return (
          <div className="flex justify-start items-center h-full min-h-[2rem]">
            <span className="text-muted-foreground text-sm">Nie określono</span>
          </div>
        );
      }

      const config = severityConfig[severity];
      if (!config) {
        console.error(`No config found for severity: ${severity}`);
        return (
          <div className="flex justify-start items-center h-full min-h-[2rem]">
            <span className="text-muted-foreground text-sm">Błąd konfiguracji</span>
          </div>
        );
      }

      return (
        <div className="flex justify-start items-center h-full min-h-[2rem]">
          <Badge variant={config.variant}>
            <FontAwesomeIcon icon={config.icon} className="mr-2" />
            {config.label}
          </Badge>
        </div>
      );
    }
  },
  {
    accessorKey: "agentId",
    header: "Przypisany do",
    cell: ({ row }) => {
      const agentId = row.getValue("agentId") as string | undefined
      const { data: agent, isLoading } = useAgent(agentId || "")

      if (!agentId) return <span className="text-muted-foreground text-sm">Nieprzypisany</span>
      if (isLoading) return <span className="text-muted-foreground text-sm">Wczytuje...</span>
      if (!agent) return <span className="text-muted-foreground text-sm">Agent nieznaleziony</span>

      return (
        <div className="flex items-center gap-2">
          <Avatar className="h-6 w-6">
            <AvatarImage src={agent.avatarUrl} alt={`${agent.fullName}`} />
            <AvatarFallback className="text-xs">{agent.fullName[0] + agent.fullName.split(' ')?.[0]}</AvatarFallback>
          </Avatar>
          <span>{agent.fullName}</span>
          <span className="text-xs text-muted-foreground">{agent.position}</span>
        </div>
      )
    }
  },
  {
    id: "actions",
    cell: ({ row }) => {
      const ticket = row.original;
      const [dropdownOpen, setDropdownOpen] = useState(false);
      const [settingsOpen, setSettingsOpen] = useState(false);
      const [detailsOpen, setDetailsOpen] = useState(false);
      const { data: agents } = useAgents();
      const { data: currentAgent } = useAgent(ticket.agentId || "");
      const assignAgent = useAssignAgent();
      const { selectedAgent } = useAgentStore();
      const isSupervisor = selectedAgent?.position === 'Supervisor';
      const isCurrentUserAssigned = ticket.agentId === selectedAgent?.id;

      const [blockDialogOpen, setBlockDialogOpen] = useState(false);
      const [unblockDialogOpen, setUnblockDialogOpen] = useState(false);
      const [blockReason, setBlockReason] = useState("");
      const [unblockReason, setUnblockReason] = useState("");

      const blockTicket = useBlockTicket();
      const unblockTicket = useUnblockTicket();
      const resolveTicket = useResolveTicket();

      const [resolveDialogOpen, setResolveDialogOpen] = useState(false);
      const [resolution, setResolution] = useState("");

      const handleAssignAgent = async (agentId: string) => {
        try {
          if (!isSupervisor && agentId !== selectedAgent?.id) {
            toast.error('Możesz przypisać ticket tylko do siebie');
            return;
          }

          await assignAgent.mutateAsync({
            ticketId: ticket.id,
            agentId: agentId,
          })
          
          toast.success(
            `Ticket przypisany do ${agents?.find(e => e.id === agentId)?.fullName}`
          )
        } catch (error) {
          toast.error('Nie udało się przypisać ticketa')
          console.error('Error assigning ticket:', error)
        }
      }

      const canModifyTicket = () => {
        if (ticket.status === TicketStatus.BeforeQualification) return isSupervisor;
        if (!ticket.agentId) return false;
        return isSupervisor || ticket.agentId === selectedAgent?.id;
      };

      const canAssignAgent = () => {
        return ticket.status === TicketStatus.Qualified || ticket.status === TicketStatus.Blocked;
      };

      return (
        <>
          <DropdownMenu open={dropdownOpen} onOpenChange={setDropdownOpen}>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" className="h-8 w-8 p-0">
                <span className="sr-only">Open menu</span>
                <MoreHorizontal className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuLabel>Akcje</DropdownMenuLabel>
              <TooltipProvider>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="relative">
                      <DropdownMenuItem 
                        onClick={(e) => {
                          e.preventDefault();
                          setSettingsOpen(true);
                          setDropdownOpen(false);
                        }}
                        className="h-9"
                        disabled={ticket.status !== TicketStatus.BeforeQualification || !isSupervisor}
                      >
                        <FontAwesomeIcon icon={faClipboardCheck} className="mr-2 h-4 w-4" />
                        <span>Kwalifikuj ticket</span>
                      </DropdownMenuItem>
                    </div>
                  </TooltipTrigger>
                  {ticket.status !== TicketStatus.BeforeQualification && (
                    <TooltipContent>
                      <p>Ticket został już zakwalifikowany</p>
                    </TooltipContent>
                  )}
                  {!isSupervisor && (
                    <TooltipContent>
                      <p>Tylko supervisor może kwalifikować tickety</p>
                    </TooltipContent>
                  )}
                </Tooltip>

                <DropdownMenuItem 
                  onClick={(e) => {
                    e.preventDefault();
                    setDetailsOpen(true);
                    setDropdownOpen(false);
                  }}
                  className="h-9"
                >
                  <FontAwesomeIcon icon={faEye} className="mr-2 h-4 w-4" />
                  <span>Zobacz szczegóły</span>
                </DropdownMenuItem>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="relative">
                      {isSupervisor ? (
                        <DropdownMenuSub>
                          <DropdownMenuSubTrigger
                            disabled={!canAssignAgent()}
                          >
                            <FontAwesomeIcon icon={faUserPlus} className="mr-2 h-4 w-4" />
                            <span>Przypisz do</span>
                          </DropdownMenuSubTrigger>
                          <DropdownMenuSubContent>
                            {Object.entries(groupAgentsByPosition(agents || [])).map(([position, agents]) => (
                              <DropdownMenuGroup key={position}>
                                <DropdownMenuLabel>{position}</DropdownMenuLabel>
                                {agents.map((agent) => (
                                  <DropdownMenuItem
                                    key={agent.id}
                                    onClick={() => handleAssignAgent(agent.id)}
                                  >
                                    <Avatar className="h-6 w-6 mr-2">
                                      <AvatarImage src={agent.avatarUrl} />
                                      <AvatarFallback>{agent.fullName[0]}</AvatarFallback>
                                    </Avatar>
                                    {agent.fullName}
                                  </DropdownMenuItem>
                                ))}
                              </DropdownMenuGroup>
                            ))}
                          </DropdownMenuSubContent>
                        </DropdownMenuSub>
                      ) : (
                        <DropdownMenuItem
                          onClick={() => handleAssignAgent(selectedAgent?.id || '')}
                          disabled={!selectedAgent || !canAssignAgent()}
                        >
                          <FontAwesomeIcon icon={faUserPlus} className="mr-2 h-4 w-4" />
                          <span>Przypisz do mnie</span>
                        </DropdownMenuItem>
                      )}
                    </div>
                  </TooltipTrigger>
                  {!canAssignAgent() && (
                    <TooltipContent>
                      <p>Ticket musi być w statusie "Zakwalifikowany" lub "Zablokowany"</p>
                    </TooltipContent>
                  )}
                </Tooltip>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="relative">
                      <DropdownMenuItem
                        onClick={() => setBlockDialogOpen(true)}
                        className="h-9"
                        disabled={ticket.status !== TicketStatus.Qualified || !ticket.agentId || !canModifyTicket()}
                      >
                        <FontAwesomeIcon icon={faLock} className="mr-2 h-4 w-4" />
                        <span>Zablokuj ticket</span>
                      </DropdownMenuItem>
                    </div>
                  </TooltipTrigger>
                  {(!ticket.agentId && ticket.status !== TicketStatus.BeforeQualification) && (
                    <TooltipContent>
                      <p>Ticket musi mieć przypisanego agenta</p>
                    </TooltipContent>
                  )}
                  {ticket.status !== TicketStatus.Qualified && (
                    <TooltipContent>
                      <p>Ticket musi być w statusie "Zakwalifikowany"</p>
                    </TooltipContent>
                  )}
                  {!canModifyTicket() && (
                    <TooltipContent>
                      <p>Nie masz uprawnień do modyfikacji tego ticketu</p>
                    </TooltipContent>
                  )}
                </Tooltip>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="relative">
                      <DropdownMenuItem
                        onClick={() => setUnblockDialogOpen(true)}
                        className="h-9"
                        disabled={ticket.status !== TicketStatus.Blocked || !ticket.agentId || !canModifyTicket()}
                      >
                        <FontAwesomeIcon icon={faUnlock} className="mr-2 h-4 w-4" />
                        <span>Odblokuj ticket</span>
                      </DropdownMenuItem>
                    </div>
                  </TooltipTrigger>
                  {(!ticket.agentId && ticket.status !== TicketStatus.BeforeQualification) && (
                    <TooltipContent>
                      <p>Ticket musi mieć przypisanego agenta</p>
                    </TooltipContent>
                  )}
                  {ticket.status !== TicketStatus.Blocked && (
                    <TooltipContent>
                      <p>Ticket musi być w statusie "Zablokowany"</p>
                    </TooltipContent>
                  )}
                  {!canModifyTicket() && (
                    <TooltipContent>
                      <p>Nie masz uprawnień do modyfikacji tego ticketu</p>
                    </TooltipContent>
                  )}
                </Tooltip>

                <Tooltip>
                  <TooltipTrigger asChild>
                    <div className="relative">
                      <DropdownMenuItem
                        onClick={() => setResolveDialogOpen(true)}
                        className="h-9"
                        disabled={ticket.status !== TicketStatus.Qualified || !ticket.agentId || !canModifyTicket()}
                      >
                        <FontAwesomeIcon icon={faCheck} className="mr-2 h-4 w-4" />
                        <span>Rozwiąż ticket</span>
                      </DropdownMenuItem>
                    </div>
                  </TooltipTrigger>
                  {(!ticket.agentId && ticket.status !== TicketStatus.BeforeQualification) && (
                    <TooltipContent>
                      <p>Ticket musi mieć przypisanego agenta</p>
                    </TooltipContent>
                  )}
                  {ticket.status !== TicketStatus.Qualified && (
                    <TooltipContent>
                      <p>Ticket musi być w statusie "Zakwalifikowany"</p>
                    </TooltipContent>
                  )}
                  {!canModifyTicket() && (
                    <TooltipContent>
                      <p>Nie masz uprawnień do modyfikacji tego ticketu</p>
                    </TooltipContent>
                  )}
                </Tooltip>
              </TooltipProvider>
            </DropdownMenuContent>
          </DropdownMenu>

          <TicketSettingsDialog 
            ticket={ticket}
            open={settingsOpen}
            onOpenChange={setSettingsOpen}
          />

          <TicketDetails 
            ticket={ticket}
            open={detailsOpen}
            onOpenChange={setDetailsOpen}
          />

          <Dialog open={blockDialogOpen} onOpenChange={setBlockDialogOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Podaj powód zablokowania ticketu</DialogTitle>
              </DialogHeader>
              <Input
                value={blockReason}
                onChange={(e) => setBlockReason(e.target.value)}
                placeholder="Powód zablokowania..."
              />
              <DialogFooter>
                <Button
                  variant="secondary"
                  onClick={() => setBlockDialogOpen(false)}
                >
                  Anuluj
                </Button>
                <Button
                  onClick={() => {
                    blockTicket.mutate({ ticketId: ticket.id, reason: blockReason });
                    setBlockDialogOpen(false);
                    setBlockReason("");
                  }}
                  disabled={!blockReason.trim()}
                >
                  Zablokuj
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>

          <Dialog open={unblockDialogOpen} onOpenChange={setUnblockDialogOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Podaj powód odblokowania ticketu</DialogTitle>
              </DialogHeader>
              <Input
                value={unblockReason}
                onChange={(e) => setUnblockReason(e.target.value)}
                placeholder="Powód odblokowania..."
              />
              <DialogFooter>
                <Button
                  variant="secondary"
                  onClick={() => setUnblockDialogOpen(false)}
                >
                  Anuluj
                </Button>
                <Button
                  onClick={() => {
                    unblockTicket.mutate({ ticketId: ticket.id, reason: unblockReason });
                    setUnblockDialogOpen(false);
                    setUnblockReason("");
                  }}
                  disabled={!unblockReason.trim()}
                >
                  Odblokuj
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>

          <Dialog open={resolveDialogOpen} onOpenChange={setResolveDialogOpen}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Podaj rozwiązanie ticketu</DialogTitle>
              </DialogHeader>
              <Input
                value={resolution}
                onChange={(e) => setResolution(e.target.value)}
                placeholder="Rozwiązanie..."
              />
              <DialogFooter>
                <Button
                  variant="secondary"
                  onClick={() => setResolveDialogOpen(false)}
                >
                  Anuluj
                </Button>
                <Button
                  onClick={() => {
                    resolveTicket.mutate({ ticketId: ticket.id, resolution });
                    setResolveDialogOpen(false);
                    setResolution("");
                  }}
                  disabled={!resolution.trim()}
                >
                  Rozwiąż
                </Button>
              </DialogFooter>
            </DialogContent>
          </Dialog>
        </>
      )
    },
  },
]
</file>

<file path="src_frontend/tickets/app/types/enums.ts">
export enum TicketCategory {
  "General" = "General",
  "Technical" = "Technical",
  "Billing" = "Billing",
  "Other" = "Other",
}

export enum SeverityLevel {
  "Low" = "Low",
  "Medium" = "Medium",
  "High" = "High",
  "Critical" = "Critical",
}

export enum TicketStatus {
  "Unknown" = "Unknown",
  "WaitingForScheduledAction" = "WaitingForScheduledAction",
  "BeforeQualification" = "BeforeQualification",
  "Qualified" = "Qualified",
  "Resolved" = "Resolved",
  "Blocked" = "Blocked"
}

export enum TicketType {
  "Unknown" = "Unknown",
  "Incident" = "Incident",
  "Question" = "Question"
}
</file>

<file path="src_frontend/tickets/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}


@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 20 14.3% 4.1%;
    --card: 0 0% 100%;
    --card-foreground: 20 14.3% 4.1%;
    --popover: 0 0% 100%;
    --popover-foreground: 20 14.3% 4.1%;
    --primary: 24.6 95% 53.1%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 60 4.8% 95.9%;
    --secondary-foreground: 24 9.8% 10%;
    --muted: 60 4.8% 95.9%;
    --muted-foreground: 25 5.3% 44.7%;
    --accent: 60 4.8% 95.9%;
    --accent-foreground: 24 9.8% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 20 5.9% 90%;
    --input: 20 5.9% 90%;
    --ring: 24.6 95% 53.1%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 20 14.3% 4.1%;
    --foreground: 60 9.1% 97.8%;
    --card: 20 14.3% 4.1%;
    --card-foreground: 60 9.1% 97.8%;
    --popover: 20 14.3% 4.1%;
    --popover-foreground: 60 9.1% 97.8%;
    --primary: 20.5 90.2% 48.2%;
    --primary-foreground: 60 9.1% 97.8%;
    --secondary: 12 6.5% 15.1%;
    --secondary-foreground: 60 9.1% 97.8%;
    --muted: 12 6.5% 15.1%;
    --muted-foreground: 24 5.4% 63.9%;
    --accent: 12 6.5% 15.1%;
    --accent-foreground: 60 9.1% 97.8%;
    --destructive: 0 72.2% 50.6%;
    --destructive-foreground: 60 9.1% 97.8%;
    --border: 12 6.5% 15.1%;
    --input: 12 6.5% 15.1%;
    --ring: 20.5 90.2% 48.2%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}


@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@keyframes vibrate {
  0% { transform: translate(0); }
  20% { transform: translate(-2px, 2px); }
  40% { transform: translate(-2px, -2px); }
  60% { transform: translate(2px, 2px); }
  80% { transform: translate(2px, -2px); }
  100% { transform: translate(0); }
}

.vibrate {
  animation: vibrate 0.3s linear infinite;
}
</file>

<file path="src_frontend/tickets/app/layout-content.tsx">
"use client"

import { Providers } from "./providers";
import { CustomNavigationMenu } from '@/components/custom/custom-nav';
import { Footer } from "@/components/custom/footer";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faTicket } from "@fortawesome/free-solid-svg-icons";
import { Toaster } from "sonner"
import { AgentRequired } from "@/components/custom/agent-required"

export function LayoutContent({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <Providers>
      <div className="mx-auto w-full h-full flex flex-col bg-background border-border/40 dark:border-border min-[1800px]:max-w-[1536px] min-[1800px]:border-x">
        <header className="border-b">
          <div className="container flex h-14 items-center px-8 w-full">
            <CustomNavigationMenu />
          </div>
        </header>

        <div className="container flex-1 py-8 px-8 w-full mx-auto">
          <main className="flex flex-col gap-8 items-center sm:items-start w-full h-full mx-auto">
            <Card className="w-full h-full mx-auto border-none">
              <CardHeader>
                <CardTitle>
                  <h3 className="scroll-m-20 pb-2 text-3xl font-semibold tracking-tight first:mt-0">
                    <FontAwesomeIcon className="pr-4" icon={faTicket} /> 
                    Tickety
                  </h3>
                </CardTitle>
                <CardDescription>
                  Tu nadzorcy analizują zgłoszenia a agenci service desk rozwiązują problemy
                </CardDescription>
              </CardHeader>
              <CardContent>
                <AgentRequired>
                  {children}
                </AgentRequired>
              </CardContent>
            </Card>
          </main>
        </div>
        <div className="w-full mx-auto">
          <Footer />
        </div>
      </div>
      <Toaster />
    </Providers>
  )
}
</file>

<file path="src_frontend/tickets/app/layout.tsx">
import type { Metadata } from "next";
import { GeistSans } from 'geist/font/sans';
import "./globals.css";
import { config } from '@fortawesome/fontawesome-svg-core'
import '@fortawesome/fontawesome-svg-core/styles.css'
import { LayoutContent } from "./layout-content";

config.autoAddCss = false

export const metadata: Metadata = {
  title: "TicketFlow - Tickety"
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className="h-full">
      <body className={`${GeistSans.className} h-full dark:bg-background`}>
        <LayoutContent>
          {children}
        </LayoutContent>
      </body>
    </html>
  )
}
</file>

<file path="src_frontend/tickets/app/page.tsx">
'use client'

import { redirect } from 'next/navigation'

export default function Page() {
  redirect('/tickets-list')
}
</file>

<file path="src_frontend/tickets/app/providers.tsx">
"use client"

import { ThemeProvider } from "next-themes"
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'
import { TooltipProvider } from "@/components/ui/tooltip"

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient())

  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
      <ThemeProvider attribute="class" defaultTheme="dark" enableSystem>
        {children}
      </ThemeProvider>
      </TooltipProvider>
    </QueryClientProvider>
  )
}
</file>

<file path="src_frontend/tickets/components/alerts/alert-list.tsx">
import { Badge } from "@/components/ui/badge";
import { LineChart, Clock, UserPlus, Bell, Trash2, Check } from "lucide-react";
import { useAlerts } from "@/hooks/use-alerts";
import { Alert } from "@/types/alert";
import { cn } from "@/lib/utils";
import { useState } from "react";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";

const getAlertBadgeProps = (type: Alert['type']) => {
  switch (type) {
    case 'SLA':
      return { icon: <Clock className="h-3 w-3" />, text: 'SLA niespełnione' };
    case 'Incydent':
      return { icon: <UserPlus className="h-3 w-3" />, text: 'Nowy incydent' };
    default:
      return { icon: <Clock className="h-3 w-3" />, text: 'Alert' };
  }
};


interface AlertItemProps {
  alert: Alert;
  onDelete: (id: string) => void;
}

function AlertItem({ alert, onDelete }: AlertItemProps) {
  return (
    <div className="rounded-lg border p-4 relative">
      {!alert.isRead && (
        <div className="absolute top-2 right-2 p-2">
          <Check 
            className="h-4 w-4 text-muted-foreground hover:text-primary cursor-pointer" 
            onClick={() => onDelete(alert.id)}
          />
        </div>
      )}
      <div className="flex items-center gap-2 mb-1">
        <Badge variant="outline" className="flex items-center gap-1">
          {getAlertBadgeProps(alert.type).icon}
          {getAlertBadgeProps(alert.type).text}
        </Badge>
        {!alert.isRead && (
          <Badge variant="secondary" className="bg-primary text-primary-foreground">
            Nowy
          </Badge>
        )}
      </div>
      <p className="text-sm text-muted-foreground">{alert.message}</p>
    </div>
  );
}

export function AlertIndicator() {
  const { data: alerts } = useAlerts();
  const unreadCount = alerts?.filter(alert => !alert.isRead).length ?? 0;

  return (
    <div className="relative w-[26px] mr-1.5">
      <Bell 
        className={cn(
          "h-6 w-6",
          unreadCount > 0 && "text-red-500 vibrate"
        )} 
      />
      {unreadCount > 0 && (
        <div className="absolute -top-2 -right-2 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center text-xs font-bold">
          {unreadCount > 99 ? '99+' : unreadCount}
        </div>
      )}
    </div>
  );
}

export function AlertList() {
  const [showOnlyUnread, setShowOnlyUnread] = useState(() => 
    localStorage.getItem('alertsOnlyUnread') === 'true'
  );
  const { data: alerts, isLoading, changeIsRead } = useAlerts(showOnlyUnread);

  const handleSwitchChange = (checked: boolean) => {
    setShowOnlyUnread(checked);
    localStorage.setItem('alertsOnlyUnread', checked.toString());
  };

  return (
    <>
      <div className="flex items-center space-x-2 mb-4">
        <Switch
          id="unread-mode"
          checked={showOnlyUnread}
          onCheckedChange={handleSwitchChange}
        />
        <Label htmlFor="unread-mode">Pokaż tylko nieprzeczytane</Label>
      </div>
      <div className="space-y-4">
        {alerts?.map((alert) => (
          <AlertItem 
            key={alert.id} 
            alert={alert} 
            onDelete={() => changeIsRead(alert.id, true)}
          />
        ))}
      </div>
    </>
  );
}
</file>

<file path="src_frontend/tickets/components/custom/agent-required.tsx">
"use client"

import { useAgentStore } from "@/store/use-agent-store"
import { useAgents } from "@/hooks/use-agents"
import { AgentSelect } from "./agent-select"
import { Card } from "@/components/ui/card"

interface AgentRequiredProps {
  children: React.ReactNode
}

export function AgentRequired({ children }: AgentRequiredProps) {
  const { selectedAgent, setSelectedAgent } = useAgentStore()
  const { data: agents, isLoading } = useAgents()

  if (isLoading) {
    return <div>Ładowanie...</div>
  }

  if (!selectedAgent) {
    return (
      <div className="min-h-[calc(100vh-4rem)] flex items-start justify-center pt-8">
        <Card className="p-8 max-w-md w-full space-y-4">
          <h2 className="text-xl font-semibold text-center">Wybierz agenta</h2>
          <p className="text-muted-foreground text-center">
            Aby kontynuować, musisz wybrać agenta, w kontekście którego będziesz pracować.
          </p>
          <div className="flex justify-center">
            <AgentSelect
              agents={agents || []}
              value={selectedAgent?.id}
              onChange={(id) => {
                const agent = agents?.find((a) => a.id === id)
                setSelectedAgent(agent || null)
              }}
              size="large"
            />
          </div>
        </Card>
      </div>
    )
  }

  return <>{children}</>
}
</file>

<file path="src_frontend/tickets/components/custom/agent-select.tsx">
"use client"

import {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import type { Agent } from "@/hooks/use-agents"
import { cn } from "@/lib/utils"

const POSITION_TRANSLATIONS: Record<string, string> = {
  'Agent': 'Agenci',
  'Supervisor': 'Supervisorzy',
}

interface AgentSelectProps {
  agents: Agent[]
  value?: string
  onChange: (value: string) => void
  disabled?: boolean
  size?: "compact" | "large"
  placeholder?: string
}

export function AgentSelect({ 
  agents, 
  value, 
  onChange, 
  disabled,
  size = "compact",
  placeholder = "Wybierz agenta"
}: AgentSelectProps) {
  const selectedAgent = agents.find(e => e.id === value)
  
  const groupedAgents = agents.reduce((acc, agent) => {
    const group = acc.get(agent.position) || []
    group.push(agent)
    acc.set(agent.position, group)
    return acc
  }, new Map<string, Agent[]>())

  const sizeStyles = {
    compact: {
      trigger: "w-[280px]",
      triggerAvatar: "h-6 w-6",
      avatar: "h-6 w-6",
      text: "text-sm",
      position: "text-xs",
      item: "py-2",
      label: "text-xs"
    },
    large: {
      trigger: "w-[320px]",
      triggerAvatar: "h-7 w-7",
      avatar: "h-10 w-10",
      text: "text-base",
      position: "text-sm",
      item: "py-3",
      label: "text-sm"
    }
  }

  const styles = sizeStyles[size]

  return (
    <Select
      value={value}
      onValueChange={onChange}
      disabled={disabled}
    >
      <SelectTrigger className={styles.trigger}>
        <SelectValue placeholder={placeholder}>
          {selectedAgent && (
            <div className="flex items-center justify-center gap-3">
              <Avatar className={cn(styles.triggerAvatar, "flex-shrink-0")}>
                <AvatarImage src={selectedAgent.avatarUrl} alt={selectedAgent.fullName} />
                <AvatarFallback className={styles.text}>
                  {selectedAgent.fullName.split(' ').map(n => n[0]).join('')}
                </AvatarFallback>
              </Avatar>
              <span className={cn(styles.text, "leading-none my-auto")}>
                {selectedAgent.fullName}
              </span>
              <span className={cn(styles.position, "text-muted-foreground ml-auto leading-none my-auto")}>
                {selectedAgent.position}
              </span>
            </div>
          )}
        </SelectValue>
      </SelectTrigger>
      <SelectContent>
        {Array.from(groupedAgents.entries()).map(([position, groupAgents]) => (
          <SelectGroup key={position}>
            <SelectLabel className={cn("px-2 py-1.5 font-semibold text-muted-foreground", styles.label)}>
              {POSITION_TRANSLATIONS[position]}
            </SelectLabel>
            {groupAgents.map((agent) => (
              <SelectItem 
                key={agent.id} 
                value={agent.id}
                className={cn("flex items-center gap-2", styles.item)}
              >
                <div className="flex items-center gap-3 w-full">
                  <Avatar className={styles.avatar}>
                    <AvatarImage src={agent.avatarUrl} alt={agent.fullName} />
                    <AvatarFallback className={styles.text}>
                      {agent.fullName.split(' ').map(n => n[0]).join('')}
                    </AvatarFallback>
                  </Avatar>
                  <span className={styles.text}>{agent.fullName}</span>
                </div>
              </SelectItem>
            ))}
          </SelectGroup>
        ))}
      </SelectContent>
    </Select>
  )
}
</file>

<file path="src_frontend/tickets/components/custom/custom-nav.tsx">
"use client"

import {
    NavigationMenu,
    NavigationMenuItem,
    NavigationMenuLink,
    NavigationMenuList,
    navigationMenuTriggerStyle,
  } from "@/components/ui/navigation-menu";
import Link from "next/link";
import { AgentSelect } from "./agent-select";
import React, { useState, useEffect } from "react";
import { useAgents } from "@/hooks/use-agents";
import { useAgentStore } from '@/store/use-agent-store';
import { AlertCircle, BarChart, Clock, UserPlus, Ticket } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  Sheet,
  SheetContent,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from "@/components/ui/sheet"
import { AlertList } from "@/components/alerts/alert-list";
import { ServiceStatusList } from "@/components/metrics/service-status-list";
import { useServices } from "@/hooks/use-services";
import { faEnvelope } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { MessageList, useUnreadMessages } from "@/components/messages/message-list";
import { useRouter, useSearchParams } from 'next/navigation';
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { AlertIndicator } from "@/components/alerts/alert-list";

export function CustomNavigationMenu() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [showOnlyUnread, setShowOnlyUnread] = useState(() => {
    // Initialize from localStorage if available, otherwise false
    if (typeof window !== 'undefined') {
      return localStorage.getItem('showOnlyUnread') === 'true';
    }
    return false;
  });
  const { selectedAgent, setSelectedAgent } = useAgentStore();
  const { data: agents, isLoading: isLoadingAgents } = useAgents();
  const { services, isConnected } = useServices();
  const { data: unreadCount } = useUnreadMessages();

  useEffect(() => {
    // Update localStorage when preference changes
    localStorage.setItem('showOnlyUnread', showOnlyUnread.toString());
  }, [showOnlyUnread]);

  const handleAgentChange = (agentId: string) => {
    const agent = agents?.find(agn => agn.id === agentId) ?? null;
    setSelectedAgent(agent);
  };

  const menuItemStyle = "group inline-flex h-9 w-max items-center justify-center rounded-md px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50";

  return (
    <div className="flex items-center justify-between w-full gap-4 px-8">
      <div className="flex items-center gap-4">
        <div className="flex items-center pr-4">
            <img 
                src="/img/ticketflow_logo.png" 
                alt="TicketFlow Logo"
                width="124"
                height="auto"
            />
        </div>
        
        <NavigationMenu>
          <NavigationMenuList>
            <NavigationMenuItem className="pr-2">
              <Link href="http://localhost:21000" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle}>
                  Zgłoszenia
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
            <NavigationMenuItem className="pr-2">
              <Link href="/tickets-list" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle} active={true}>
                  Tickety
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
            <NavigationMenuItem className="pr-2">
              <Link href="http://localhost:21002" legacyBehavior passHref>
                <NavigationMenuLink className={menuItemStyle}>
                  Panel admina
                </NavigationMenuLink>
              </Link>
            </NavigationMenuItem>
          </NavigationMenuList>
        </NavigationMenu>
      </div>

      <div className="flex items-center gap-2">
        <AgentSelect
          agents={agents || []}
          value={selectedAgent?.id}
          onChange={handleAgentChange}
          disabled={isLoadingAgents}
          size="large"
          placeholder="Pracuj jako..."
        />
        <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="h-9 w-9">
              <BarChart className="h-5 w-5" />
            </Button>
          </SheetTrigger>
          <SheetContent side="right" className="sm:max-w-[800px] w-[90vw]">
            <SheetHeader>
              <SheetTitle>Status usług</SheetTitle>
            </SheetHeader>
            <div className="mt-4">
              <ServiceStatusList 
                services={services} 
                isConnected={isConnected}
              />
            </div>
          </SheetContent>
        </Sheet>
        <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="h-9 w-9">
              <AlertIndicator />
            </Button>
          </SheetTrigger>
          <SheetContent>
            <SheetHeader>
              <SheetTitle>Alerty</SheetTitle>
            </SheetHeader>
            <div className="mt-4">
              <AlertList />
            </div>
          </SheetContent>
        </Sheet>
        
        <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="h-9 w-9 relative">
              <FontAwesomeIcon icon={faEnvelope} className="h-5 w-5" />
              {unreadCount && unreadCount > 0 && (
                <span className="absolute -top-1 -right-1 bg-primary text-primary-foreground text-xs rounded-full w-5 h-5 flex items-center justify-center">
                  {unreadCount}
                </span>
              )}
            </Button>
          </SheetTrigger>
          <SheetContent className="w-[95vw] sm:w-[600px] overflow-y-auto max-w-[95vw] sm:max-w-[600px]">
            <SheetHeader>
              <SheetTitle>Wiadomości</SheetTitle>
            </SheetHeader>
            <div className="flex items-center space-x-2 mb-4">
              <Switch
                id="unread-mode"
                checked={showOnlyUnread}
                onCheckedChange={setShowOnlyUnread}
              />
              <Label htmlFor="unread-mode">Pokaż tylko nieprzeczytane</Label>
            </div>
            <MessageList showOnlyUnread={showOnlyUnread} />
          </SheetContent>
        </Sheet>
      </div>
    </div>
  );
}
</file>

<file path="src_frontend/tickets/components/custom/data-table.tsx">
"use client"

import {
  ColumnDef,
  flexRender,
  getCoreRowModel,
  getPaginationRowModel,
  useReactTable,
} from "@tanstack/react-table"

import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table"
import { Button } from "../ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"

interface DataTableProps<TData, TValue> {
  columns: ColumnDef<TData, TValue>[]
  data: TData[]
  pagination: {
    page: number
    pageSize: number
    totalPages: number
    onPageChange: (page: number) => void
  }
}

export function DataTable<TData, TValue>({
  columns,
  data,
  pagination,
}: DataTableProps<TData, TValue>) {
  const table = useReactTable({
    data,
    columns,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    manualPagination: true,
    pageCount: pagination.totalPages,
  })

  return (
    <div>
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => {
                  return (
                    <TableHead key={header.id}>
                      {header.isPlaceholder
                        ? null
                        : flexRender(
                            header.column.columnDef.header,
                            header.getContext()
                          )}
                    </TableHead>
                  )
                })}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(cell.column.columnDef.cell, cell.getContext())}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell colSpan={columns.length} className="h-24 text-center">
                  No results.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>
      {pagination.totalPages > 1 && (
        <div className="flex items-center justify-end space-x-2 py-4">
          <Button
            variant="outline"
            size="sm"
            onClick={() => pagination.onPageChange(pagination.page - 1)}
            disabled={pagination.page <= 1}
          >
            Poprzednia
          </Button>
          <div className="flex-1 text-sm text-muted-foreground text-center">
            Strona {pagination.page} z {pagination.totalPages}
          </div>
          <Button
            variant="outline"
            size="sm"
            onClick={() => pagination.onPageChange(pagination.page + 1)}
            disabled={pagination.page >= pagination.totalPages}
          >
            Następna
          </Button>
        </div>
      )}
    </div>
  )
}
</file>

<file path="src_frontend/tickets/components/custom/employee-card.tsx">
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar"
import { Card, CardContent } from "@/components/ui/card"

interface EmployeeCardProps {
  name: string
  surname: string
  position: 'Supervisor' | 'Agent'
  avatarUrl?: string
}

export function EmployeeCard({ name, surname, position, avatarUrl }: EmployeeCardProps) {
  return (
    <Card className="w-[240px]">
      <CardContent className="flex items-center gap-2 p-3">
        <Avatar className="h-8 w-8">
          <AvatarImage src={avatarUrl} alt={`${name} ${surname}`} />
          <AvatarFallback className="text-xs">{`${name[0]}${surname[0]}`}</AvatarFallback>
        </Avatar>
        <div className="min-w-0">
          <p className="text-sm font-medium truncate">{`${name} ${surname}`}</p>
          <p className="text-xs text-muted-foreground">{position}</p>
        </div>
      </CardContent>
    </Card>
  )
}
</file>

<file path="src_frontend/tickets/components/custom/footer.tsx">
import Image from "next/image";
import { FontAwesomeIcon } from '@fortawesome/react-fontawesome';
import { 
  faGithub, 
  faYoutube, 
  faDiscord, 
  faInstagram, 
  faTwitter, 
  faLinkedinIn 
} from '@fortawesome/free-brands-svg-icons';

export function Footer() {
  return (
    <footer className="border-t py-4 bg-black">
      <div className="container flex flex-col items-center gap-3 mx-auto">
        <div className="flex items-center gap-4">
          <a href="https://devmentors.io">
            <Image 
              src="/img/devmentors-logo.png" 
              alt="DevMentors Logo" 
              width={80}
              height={19}
              className="h-auto w-auto"
            />
          </a>
          <a href="https://github.com/devmentors" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faGithub} />
          </a>
          <a href="https://www.youtube.com/@DevMentorsPL" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faYoutube} />
          </a>
          <a href="https://devmentors.io/discordpl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faDiscord} />
          </a>
          <a href="https://www.instagram.com/devmentors_pl/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faInstagram} />
          </a>
          <a href="https://twitter.com/dev_mentors_pl" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faTwitter} />
          </a>
          <a href="https://www.linkedin.com/company/devmentors-io/" className="text-sm text-white hover:opacity-75">
            <FontAwesomeIcon icon={faLinkedinIn} />
          </a>
        </div>
      </div>
    </footer>
  );
}
</file>

<file path="src_frontend/tickets/components/messages/message-item.tsx">
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { useMutation, useQueryClient, useQuery } from "@tanstack/react-query";
import { faEnvelope, faEnvelopeOpen } from "@fortawesome/free-solid-svg-icons";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { toggleMessageReadStatus } from "@/services/messages";
import { useAgent } from "@/hooks/use-agents";
import { Message } from "@/types/message";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useAgentStore } from "@/store/use-agent-store";
import { User } from "lucide-react";

interface MessageItemProps extends Message {
  onReadStatusChange: () => void;
}

export function MessageItem({ onReadStatusChange, ...props }: MessageItemProps) {
  const queryClient = useQueryClient();
  const { selectedAgent } = useAgentStore();
  
  const toggleReadStatus = useMutation({
    mutationFn: () => toggleMessageReadStatus(props.id, !props.isRead),
    onSuccess: () => {
      onReadStatusChange();
      queryClient.invalidateQueries({ 
        queryKey: ['messages', 'unreadCount', selectedAgent?.userId] 
      });
    },
  });

  const formattedDate = new Date(props.timestamp).toLocaleString('pl-PL', {
    day: 'numeric',
    month: 'short',
    hour: '2-digit',
    minute: '2-digit'
  });

  let displayName;
  let agent;

  if (props.senderEmployeeId) {
    const { data: agentData } = useAgent(props.senderEmployeeId!);
    agent = agentData;
    displayName = agent 
      ? `${agent.fullName}`
      : props.senderDisplayName || 'Loading...';
  } else {
    displayName = 'SYSTEM';
  }

  return (
    <div className="relative border rounded-lg p-4 hover:bg-accent transition-colors">
      <div className="flex justify-between items-start mb-1">
        <div className="flex items-center gap-2">
          <h4 className="font-medium truncate max-w-[400px]">{props.title}</h4>
          {!props.isRead && <Badge variant="secondary">Nowa</Badge>}
        </div>
        <time className="text-sm text-muted-foreground">
          {formattedDate}
        </time>
      </div>
      <p className="text-sm text-muted-foreground mb-2">{props.preview}</p>
      <p className="text-sm mb-4">{props.content}</p>
      
      <div className="border-t pt-3 mt-3">
        <div className="flex justify-between items-center">
          <div>
            <div className="text-xs text-muted-foreground mb-1 flex items-center gap-1">
              <User className="h-3 w-3" />
              Nadawca
            </div>
            <div className="flex items-center gap-2">
              {props.senderEmployeeId && agent && (
                <Avatar className="h-8 w-8">
                  <AvatarImage src={agent.avatarUrl} alt={displayName} />
                  <AvatarFallback>{displayName.split(' ').map((n: string) => n[0]).join('')}</AvatarFallback>
                </Avatar>
              )}
              <span className="text-sm font-medium">{displayName}</span>
            </div>
          </div>
          <Button
            variant="ghost"
            size="sm"
            onClick={() => toggleReadStatus.mutate()}
            disabled={toggleReadStatus.isPending}
          >
            <FontAwesomeIcon 
              icon={props.isRead ? faEnvelopeOpen : faEnvelope} 
              className={`h-4 w-4 ${props.isRead ? 'text-muted-foreground' : 'text-primary'}`}
            />
          </Button>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src_frontend/tickets/components/messages/message-list.tsx">
import { useState, useEffect } from "react";
import { useQuery } from "@tanstack/react-query";
import { Message } from "@/types/message";
import { MessageItem } from "./message-item";
import { getMessages } from "@/services/messages";
import { useAgentStore } from "@/store/use-agent-store";

const MESSAGES_PER_PAGE = 5;

interface MessageListProps {
  showOnlyUnread?: boolean;
}

export function MessageList({ showOnlyUnread = false }: MessageListProps) {
  const [page, setPage] = useState(1);
  const { selectedAgent } = useAgentStore();

  const { 
    data, 
    isLoading, 
    error,
    isFetching,
    refetch 
  } = useQuery({
    queryKey: ['messages', page, selectedAgent?.userId, showOnlyUnread],
    queryFn: async () => {
      const response = await getMessages({ 
        page, 
        limit: MESSAGES_PER_PAGE,
        userId: selectedAgent!.userId,
        onlyUnread: showOnlyUnread
      });
      return response;
    },
    enabled: !!selectedAgent?.userId,
  });

  useEffect(() => {
    setPage(1);
    refetch();
  }, [showOnlyUnread, refetch]);

  const messages: Message[] = data?.messages || [];
  const totalMessages = messages.length;
  const totalPages = Math.ceil(totalMessages / MESSAGES_PER_PAGE);
  const unreadCount = messages.filter((msg) => !msg.isRead).length;

  return (
    <div className="mt-4 space-y-4">
      {isLoading ? (
        <p className="text-muted-foreground">Ładowanie wiadomości...</p>
      ) : error ? (
        <p className="text-destructive">Błąd podczas ładowania wiadomości</p>
      ) : messages.length === 0 ? (
        <p className="text-muted-foreground">Brak wiadomości</p>
      ) : (
        <>
          {messages.map((message: Message) => (
            <MessageItem 
              key={message.id}
              {...message}
              onReadStatusChange={() => refetch()}
            />
          ))}
        </>
      )}
    </div>
  );
}

export function useUnreadMessages() {
  const { selectedAgent } = useAgentStore();
  
  return useQuery({
    queryKey: ['messages', 'unreadCount', selectedAgent?.userId],
    queryFn: async () => {
      const response = await getMessages({ 
        page: 1, 
        limit: 100,
        userId: selectedAgent!.userId 
      });
      return response.messages.filter(msg => !msg.isRead).length;
    },
    enabled: !!selectedAgent?.userId,
  });
}
</file>

<file path="src_frontend/tickets/components/metrics/mini-sparkline.tsx">
"use client"

import { Area, AreaChart, ResponsiveContainer, XAxis, YAxis } from 'recharts'

interface HistoryPoint {
  timestamp: string;
  value: number;
}

interface MiniSparklineProps {
  data: HistoryPoint[];
  color: string;
  width: number;
  height: number;
  maxValue?: number;
}

export function MiniSparkline({ data, color, width, height, maxValue }: MiniSparklineProps) {
  const chartData = data
    .slice(-10)
    .map(point => ({
      time: new Date(point.timestamp).getTime(),
      value: maxValue ? (point.value / maxValue) * 100 : point.value
    }))
    .sort((a, b) => a.time - b.time);

  if (!chartData.length) return null;

  return (
    <div style={{ width, height }}>
      <ResponsiveContainer width="100%" height="100%">
        <AreaChart data={chartData} margin={{ top: 2, right: 0, bottom: 2, left: 0 }}>
          <XAxis 
            dataKey="time" 
            hide={true}
          />
          <YAxis 
            domain={[0, 100]} 
            hide={true}
          />
          <Area
            type="monotone"
            dataKey="value"
            stroke={color}
            fill={color}
            fillOpacity={0.1}
            strokeWidth={1.5}
            isAnimationActive={false}
          />
        </AreaChart>
      </ResponsiveContainer>
    </div>
  );
}
</file>

<file path="src_frontend/tickets/components/metrics/service-status-list.tsx">
import { MiniSparkline } from "@/components/metrics/mini-sparkline";
import { ServiceStatus } from "@/types/services";
import { cn } from "@/lib/utils";
import { Wifi } from "lucide-react";

interface ServiceStatusListProps {
  services: ServiceStatus[];
  isConnected: boolean;
}

export function ServiceStatusList({ services, isConnected }: ServiceStatusListProps) {
  const getStatusColor = (status: ServiceStatus['status']) => {
    switch (status) {
      case 'Healthy':
        return 'bg-emerald-500';
      case 'Error':
        return 'bg-red-500';
      case 'Unknown':
      default:
        return 'bg-gray-500';
    }
  };

  const getChartColor = (status: ServiceStatus['status']) => {
    switch (status) {
      case 'Healthy':
        return '#10b981'; // emerald-500
      case 'Error':
        return '#ef4444'; // red-500
      case 'Unknown':
      default:
        return '#6b7280'; // gray-500
    }
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center gap-2 pb-2 text-sm text-muted-foreground">
        <Wifi className={cn(
          "h-4 w-4 transition-colors",
          isConnected ? "text-emerald-500" : "text-gray-500"
        )} />
        {isConnected ? "Połączono" : "Rozłączono"}
      </div>

      {(!services || !Array.isArray(services)) && (
        <div>Metryki nie są dostępne</div>
      )}

      {services.length === 0 && (
        <div>Brak dostępnych metryk</div>
      )}

      {services.map((service) => (
        <div key={service.name} className="flex items-center justify-between p-4 bg-background rounded-lg border">
          <div className="flex items-center gap-3">
            <div className={cn(
              "w-2.5 h-2.5 rounded-full",
              getStatusColor(service.status)
            )} />
            <div>
              <h3 className="font-medium">{service.name}</h3>
              <p className="text-sm text-muted-foreground">
                Ostatni pomiar: {new Date(service.lastChecked).toLocaleString('pl-PL', {
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit',
                  hour12: false
                })}
              </p>
            </div>
          </div>
          {service.metrics && (
            <div className="flex gap-4">
              {service.metrics.cpu && (
                <div className="flex items-center gap-2">
                  <div className="w-24 h-8 border-gray-300">
                    <MiniSparkline 
                      data={service.metrics.cpu.history} 
                      color={getChartColor(service.status)}
                      width={96}
                      height={32}
                      maxValue={100}
                    />
                  </div>
                  <span className="text-sm">
                    {service.metrics.cpu.usage}%
                  </span>
                </div>
              )}
              {service.metrics.memory && (
                <div className="flex items-center gap-2">
                  <div className="w-24 h-8 border-gray-300">
                    <MiniSparkline 
                      data={service.metrics.memory.history}
                      color={getChartColor(service.status)}
                      width={96}
                      height={32}
                      maxValue={service.metrics.memory.total}
                    />
                  </div>
                  <span className="text-sm">
                    {service.metrics.memory.used}Mb
                  </span>
                </div>
              )}
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
</file>

<file path="src_frontend/tickets/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src_frontend/tickets/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src_frontend/tickets/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="src_frontend/tickets/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-xl border bg-card text-card-foreground shadow",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src_frontend/tickets/components/ui/command.tsx">
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"
import { MagnifyingGlassIcon } from "@radix-ui/react-icons"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <MagnifyingGlassIcon className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src_frontend/tickets/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src_frontend/tickets/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import {
  CheckIcon,
  ChevronRightIcon,
  DotFilledIcon,
} from "@radix-ui/react-icons"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-4 w-4 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}
</file>

<file path="src_frontend/tickets/components/ui/form.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-[0.8rem] text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-[0.8rem] font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}
</file>

<file path="src_frontend/tickets/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="src_frontend/tickets/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="src_frontend/tickets/components/ui/navigation-menu.tsx">
import * as React from "react"
import { ChevronDownIcon } from "@radix-ui/react-icons"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-9 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDownIcon
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-300 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}
</file>

<file path="src_frontend/tickets/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src_frontend/tickets/components/ui/select.tsx">
"use client"

import * as React from "react"
import {
  CaretSortIcon,
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons"
import * as SelectPrimitive from "@radix-ui/react-select"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="src_frontend/tickets/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "@/lib/utils"
import { Cross2Icon } from "@radix-ui/react-icons"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src_frontend/tickets/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }
</file>

<file path="src_frontend/tickets/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src_frontend/tickets/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="src_frontend/tickets/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Portal>
    <TooltipPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </TooltipPrimitive.Portal>
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src_frontend/tickets/components/ticket-details.tsx">
"use client"

import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Textarea } from "@/components/ui/textarea"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Ticket } from "@/types/ticket"
import { SeverityLevel, TicketStatus, TicketCategory } from '@/app/types/enums'
import { ticketCategoryTranslations, ticketStatusTranslations, ticketSeverityTranslations } from "@/app/lib/translations"
import { useState } from "react"
import { severityConfig, statusConfig } from "@/lib/ticket-styling"
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome"
import { faCircle, faCircleExclamation, faTriangleExclamation, faFire } from "@fortawesome/free-solid-svg-icons"
import { Badge } from "@/components/ui/badge"
import { Switch } from "@/components/ui/switch"
import { Clock } from "lucide-react"

interface TicketDetailsProps {
  ticket: Ticket
  open: boolean
  onOpenChange: (open: boolean) => void
}

const formatDeadline = (deadline: Date | string | null, createdAt: Date | string) => {
  if (!deadline) return null;
  
  const deadlineDate = new Date(deadline);
  const createdAtDate = new Date(createdAt);
  
  const diff = deadlineDate.getTime() - createdAtDate.getTime();
  const days = Math.floor(diff / (1000 * 60 * 60 * 24));
  const hours = Math.floor((diff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
  const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
  const seconds = Math.floor((diff % (1000 * 60)) / 1000);
  
  return [
    days > 0 ? `${days}d` : null,
    hours > 0 ? `${hours}h` : null,
    minutes > 0 ? `${minutes}m` : null,
    seconds > 0 ? `${seconds}s` : null
  ].filter(Boolean).join(' ');
};

export function TicketDetails({ ticket, open, onOpenChange }: TicketDetailsProps) {
  const [showTranslated, setShowTranslated] = useState(false)

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogTrigger asChild>
        {/* Your existing children */}
      </DialogTrigger>
      <DialogContent className="max-w-2xl p-0">
        <Card className="border-0">
          <CardHeader className="p-6 pb-4 border-b">
            <CardTitle className="text-2xl font-semibold">{ticket.title}</CardTitle>
            <CardDescription className="flex items-center gap-2">
              <strong>ID:</strong> {ticket.id} • 
              <Badge variant="outline" className="flex items-center gap-1">
                <Clock className="h-3 w-3" />
                {ticket.deadline 
                  ? `Deadline: ${formatDeadline(ticket.deadline, ticket.createdAt)}`
                  : 'Deadline nieznany'}
              </Badge>
            </CardDescription>
          </CardHeader>
          <CardContent className="p-6 space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="status">Status</Label>
                <Input 
                  id="status" 
                  value={ticketStatusTranslations[ticket.status as TicketStatus]} 
                  readOnly 
                  disabled
                />
              </div>

              <div className="space-y-2">
                <Label htmlFor="severity">Priorytet</Label>
                <div className="mt-1">
                  {(() => {
                    const config = severityConfig[ticket.severityLevel as SeverityLevel] || severityConfig.Low;
                    return (
                      <Badge className="py-2" variant={config.variant}>
                        <FontAwesomeIcon icon={config.icon} className="mr-2" />
                        {config.label}
                      </Badge>
                    );
                  })()}
                </div>
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="category">Kategoria</Label>
              <Input 
                id="category" 
                value={ticketCategoryTranslations[ticket.category as TicketCategory] || ticket.category} 
                readOnly 
                disabled
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="email">Email zgłaszającego</Label>
              <Input 
                id="email" 
                value={ticket.email} 
                readOnly 
                disabled
              />
            </div>

            {ticket.resolution && (
              <div className="space-y-2">
                <Label htmlFor="resolution">Rozwiązanie</Label>
                <Textarea
                  id="resolution"
                  value={ticket.resolution}
                  readOnly
                  disabled
                  className="min-h-[100px] resize-none"
                />
              </div>
            )}

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label>Opis</Label>
                <div className="flex items-center gap-2 mb-2">
                  <Switch
                    checked={showTranslated}
                    onCheckedChange={setShowTranslated}
                    disabled={!ticket.descriptionTranslated}
                  />
                  <Label className={!ticket.descriptionTranslated ? "text-muted-foreground" : ""}>
                    {ticket.descriptionTranslated ? "Pokaż tłumaczenie" : "Tłumaczenie niedostępne"}
                  </Label>
                </div>
              </div>
              <Textarea
                value={showTranslated ? (ticket.descriptionTranslated ?? ticket.description) : ticket.description}
                readOnly
                className="min-h-[150px] resize-none"
              />
            </div>
          </CardContent>
        </Card>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="src_frontend/tickets/components/ticket-settings-dialog.tsx">
import { Button } from "@/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select"
import { Label } from "@/components/ui/label"
import { SeverityLevel, TicketType } from "@/app/types/enums"
import { ticketSeverityTranslations, ticketTypeTranslations } from "@/app/lib/translations"
import { useState } from "react"
import { Ticket } from "@/types/ticket"
import { useMutation, useQueryClient } from "@tanstack/react-query"
import api from '@/lib/axios'
import { toast } from "sonner"

interface TicketSettingsDialogProps {
  ticket: Ticket
  open: boolean
  onOpenChange: (open: boolean) => void
}

interface QualifyPayload {
  ticketId: string
  ticketType: TicketType
  severityLevel: SeverityLevel
}

export function TicketSettingsDialog({ ticket, open, onOpenChange }: TicketSettingsDialogProps) {
  const queryClient = useQueryClient()
  const [severity, setSeverity] = useState<SeverityLevel>(ticket.severityLevel as SeverityLevel)
  const [type, setType] = useState<TicketType>(ticket.type || TicketType.Question)

  const qualifyMutation = useMutation({
    mutationFn: async (data: QualifyPayload) => {
      const response = await api.post(`/tickets/${data.ticketId}/qualify`, data)
      return response.data
    },
    onSuccess: async (data) => {
      onOpenChange(false);
      await Promise.all([
        queryClient.invalidateQueries({ queryKey: ['tickets'] }),
        queryClient.invalidateQueries({ queryKey: ['ticket', ticket.id] })
      ]);
      toast.success("Zgłoszenie zostało zakwalifikowane")
    },
    onError: (error) => {
      toast.error("Wystąpił błąd podczas kwalifikacji zgłoszenia")
      console.error("Qualification error:", error)
    }
  })

  const handleSave = () => {
    try {
      qualifyMutation.mutate({
        ticketId: ticket.id.toString(),
        ticketType: type,
        severityLevel: severity
      })
    } catch (error) {
      console.error("Handle save error:", error)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogTrigger asChild>
        {/* Your existing children */}
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Kwalifikacja zgłoszenia</DialogTitle>
        </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="space-y-2">
            <Label>Priorytet</Label>
            <Select 
              value={(severity ?? "Nie określono").toString()} 
              onValueChange={(value) => setSeverity(value as unknown as SeverityLevel)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Wybierz priorytet" />
              </SelectTrigger>
              <SelectContent>
                {Object.values(SeverityLevel).map((level) => (
                  <SelectItem key={level} value={level.toString()}>
                    {ticketSeverityTranslations[level as keyof typeof ticketSeverityTranslations]}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
          <div className="space-y-2">
            <Label>Typ zgłoszenia</Label>
            <Select 
              value={(type ?? TicketType.Question).toString()}
              onValueChange={(value) => setType(value as unknown as TicketType)}
            >
              <SelectTrigger>
                <SelectValue placeholder="Wybierz typ" />
              </SelectTrigger>
              <SelectContent>
                {Object.values(TicketType)
                  .filter(ticketType => ticketType !== TicketType.Unknown)
                  .map((ticketType) => (
                    <SelectItem key={ticketType} value={ticketType.toString()}>
                      {ticketTypeTranslations[ticketType as keyof typeof ticketTypeTranslations]}
                    </SelectItem>
                  ))}
              </SelectContent>
            </Select>
          </div>
        </div>
        <div className="flex justify-end gap-2">
          <Button variant="outline" onClick={() => onOpenChange(false)}>
            Anuluj
          </Button>
          <Button 
            onClick={handleSave} 
            disabled={qualifyMutation.isPending}
          >
            {qualifyMutation.isPending ? "Zapisywanie..." : "Zapisz"}
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="src_frontend/tickets/hooks/use-agents.ts">
import { useQuery } from "@tanstack/react-query"

interface Agent {
  id: string
  userId: string
  fullName: string
  position: 'Supervisor' | 'Agent'
  avatarUrl: string
}

async function getAgents(): Promise<Agent[]> {
  const response = await fetch('http://localhost:5112/agents')
  if (!response.ok) {
    throw new Error('Nie udało się pobrać agentów')
  }
  return response.json()
}

export function useAgents() {
  return useQuery({
    queryKey: ['agents'],
    queryFn: getAgents,
  })
}

export function useAgent(id: string) {
  return useQuery({
    queryKey: ['agents', id],
    queryFn: async () => {
      const response = await fetch(`http://localhost:5112/agents/${id}`)
      if (!response.ok) {
        throw new Error('Nie udało się pobrać agenta')
      }
      return response.json()
    },
  })
}

export type { Agent }
</file>

<file path="src_frontend/tickets/hooks/use-alerts.ts">
import { useQuery } from "@tanstack/react-query";
import { Alert } from "@/types/alert";

export function useAlerts(onlyUnread: boolean = false) {
  const { data, isLoading, refetch } = useQuery<Alert[]>({
    queryKey: ["alerts", onlyUnread],
    queryFn: async () => {
      const response = await fetch(`http://localhost:5148/alerts${onlyUnread ? '?onlyUnread=true' : ''}`);
      if (!response.ok) throw new Error("Failed to fetch alerts");
      return response.json();
    },
  });

  const changeIsRead = async (id: string, isRead: boolean) => {
    await fetch(`http://localhost:5148/alerts/${id}?isRead=${isRead}`, {
      method: 'PUT'
    });
    refetch();
  };

  return { data, isLoading, refetch, changeIsRead };
}
</file>

<file path="src_frontend/tickets/hooks/use-services.ts">
import { HubConnection, HubConnectionBuilder } from "@microsoft/signalr";
import { ServiceMetricsResponse, ServiceStatus } from "@/types/services";
import { useEffect, useRef, useState } from "react";

const HISTORY_LENGTH = 20;

export function useServices() {
  const [services, setServices] = useState<ServiceStatus[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  const historyRef = useRef<Record<string, ServiceStatus>>({});
  const connectionRef = useRef<HubConnection>();

  useEffect(() => {
    if (connectionRef.current) {
      return;
    }

    const setupConnection = async () => {
      try {
        const connection = new HubConnectionBuilder()
          .withUrl("http://localhost:5231/live-metrics")
          .withAutomaticReconnect({
            nextRetryDelayInMilliseconds: retryContext => {
              return Math.min(1000 * Math.pow(2, retryContext.previousRetryCount), 30000);
            }
          })
          .build();

        connectionRef.current = connection;

        connection.onclose(() => setIsConnected(false));
        connection.onreconnecting(() => setIsConnected(false));
        connection.onreconnected(() => setIsConnected(true));

        connection.on("MetricTick", (service: ServiceMetricsResponse) => {
          const previousService = historyRef.current[service.name];
          const newService: ServiceStatus = {
            ...service,
            metrics: service.metrics ? {
              cpu: {
                usage: service.metrics.cpu.usage,
                history: [
                  ...(previousService?.metrics?.cpu?.history || []),
                  { timestamp: service.lastChecked, value: service.metrics.cpu.usage }
                ].slice(-HISTORY_LENGTH)
              },
              memory: {
                used: service.metrics.memory.used,
                total: service.metrics.memory.total,
                history: [
                  ...(previousService?.metrics?.memory?.history || []),
                  { timestamp: service.lastChecked, value: service.metrics.memory.used }
                ].slice(-HISTORY_LENGTH)
              }
            } : undefined
          };
          
          historyRef.current[service.name] = newService;
          
          setServices(prevServices => {
            // Create a map of existing services for easier lookup
            const servicesMap = new Map(prevServices.map(s => [s.name, s]));
            // Update or add the new service
            servicesMap.set(service.name, newService);
            // Convert map back to array and sort by name for consistent ordering
            return Array.from(servicesMap.values()).sort((a, b) => 
              a.name.localeCompare(b.name)
            );
          });
        });

        await connection.start();
        setIsConnected(true);
      } catch (err) {
        console.error("Failed to establish connection:", err);
        connectionRef.current = undefined;
      }
    };

    const timer = setTimeout(() => {
      setupConnection();
    }, 100);

    return () => {
      clearTimeout(timer);
      if (connectionRef.current) {
        connectionRef.current.stop();
        connectionRef.current = undefined;
      }
    };
  }, []);

  return {
    services,
    isConnected
  };
}
</file>

<file path="src_frontend/tickets/hooks/use-tickets.ts">
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query"
import type { Ticket } from "@/types/ticket"
import api from "@/lib/axios";
import { useDebounce } from 'use-debounce';

// Fetch tickets
async function getTickets({ page, limit }: UseTicketsParams): Promise<TicketsResponse> {
  await new Promise(resolve => setTimeout(resolve, 200));
  const response = await fetch(`http://localhost:5112/tickets?page=${page}&limit=${limit}`)
  if (!response.ok) throw new Error('Nie udało się pobrać ticketów')
  const data = await response.json();
  return data;
}

interface AssignAgentPayload {
  ticketId: string;
  agentId: string;
}

interface TicketsResponse {
  data: Ticket[];
  totalCount: number;
}

interface UseTicketsParams {
  page: number;
  limit: number;
}

interface BlockTicketPayload {
  ticketId: string;
  reason: string;
}

interface UnblockTicketPayload {
  ticketId: string;
  reason: string;
}

interface ResolveTicketPayload {
  ticketId: string;
  resolution: string;
}

export function useTickets({ page, limit }: UseTicketsParams) {
  console.log('page changed:', page);
  const [debouncedPage] = useDebounce(page, 300);
  
  return useQuery({
    queryKey: ['tickets', debouncedPage],
    queryFn: () => getTickets({ page: debouncedPage, limit }),
    enabled: debouncedPage === page,
    refetchOnWindowFocus: false
  });
}

export function useAssignAgent() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({ ticketId, agentId }: AssignAgentPayload) => {
      const response = await api.post(`/tickets/${ticketId}/assign/${agentId}`);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}

export function useBlockTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ ticketId, reason }: BlockTicketPayload) => {
      const response = await api.post(`/tickets/${ticketId}/block/${reason}`);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}

export function useUnblockTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ ticketId, reason }: UnblockTicketPayload) => {
      const response = await api.post(`/tickets/${ticketId}/unblock/${reason}`);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}

export function useResolveTicket() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ ticketId, resolution }: ResolveTicketPayload) => {
      const response = await api.post(`/tickets/${ticketId}/resolve/${resolution}`);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['tickets'] });
    },
  });
}
</file>

<file path="src_frontend/tickets/lib/axios.ts">
import axios from 'axios';

// Create axios instance with default config
const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5112',
  headers: {
    'Content-Type': 'application/json',
  },
});

export default api;
</file>

<file path="src_frontend/tickets/lib/ticket-styling.tsx">
import { faCircle, faCircleExclamation, faTriangleExclamation, faFire, faCheckCircle, faSpinner, faPlusCircle, faLock, faQuestionCircle } from "@fortawesome/free-solid-svg-icons"
import { SeverityLevel, TicketStatus } from '@/app/types/enums'
import { ticketStatusTranslations, ticketSeverityTranslations } from "@/app/lib/translations"

export const severityConfig = {
  Low: {
    label: ticketSeverityTranslations[SeverityLevel.Low],
    variant: "secondary",
    icon: faCircle
  },
  Medium: {
    label: ticketSeverityTranslations[SeverityLevel.Medium],
    variant: "default",
    icon: faTriangleExclamation
  },
  High: {
    label: ticketSeverityTranslations[SeverityLevel.High],
    variant: "destructive",
    icon: faCircleExclamation
  },
  Critical: {
    label: ticketSeverityTranslations[SeverityLevel.Critical],
    variant: "destructive",
    icon: faFire
  },
  null: {
    label: "Nie określono",
    variant: "secondary",
    icon: faQuestionCircle
  },
  undefined: {
    label: "Nie określono",
    variant: "secondary",
    icon: faQuestionCircle
  }
} as const;

export const statusConfig = {
  [TicketStatus.Unknown]: { 
    label: ticketStatusTranslations[TicketStatus.Unknown], 
    variant: "outline",
    icon: faQuestionCircle
  },
  [TicketStatus.WaitingForScheduledAction]: { 
    label: ticketStatusTranslations[TicketStatus.WaitingForScheduledAction], 
    variant: "outline",
    icon: faSpinner
  },
  [TicketStatus.BeforeQualification]: { 
    label: ticketStatusTranslations[TicketStatus.BeforeQualification], 
    variant: "outline",
    icon: faPlusCircle
  },
  [TicketStatus.Qualified]: { 
    label: ticketStatusTranslations[TicketStatus.Qualified], 
    variant: "outline",
    icon: faCheckCircle
  },
  [TicketStatus.Resolved]: { 
    label: ticketStatusTranslations[TicketStatus.Resolved], 
    variant: "secondary",
    icon: faCheckCircle
  },
  [TicketStatus.Blocked]: { 
    label: ticketStatusTranslations[TicketStatus.Blocked], 
    variant: "destructive",
    icon: faLock
  },
} as const; 

// Helper function to map API status to enum
function mapApiStatusToEnum(status: string): TicketStatus {
  switch (status) {
    case "BeforeQualification":
      return TicketStatus.BeforeQualification;
    case "WaitingForScheduledAction":
      return TicketStatus.WaitingForScheduledAction;
    case "Qualified":
      return TicketStatus.Qualified;
    case "Resolved":
      return TicketStatus.Resolved;
    case "Blocked":
      return TicketStatus.Blocked;
    default:
      return TicketStatus.Unknown;
  }
}

// Update the getStatusConfig function
export function getStatusConfig(status: string) {
  const enumStatus = mapApiStatusToEnum(status);
  return (
    statusConfig[enumStatus] ?? {
      label: ticketStatusTranslations[TicketStatus.Unknown],
      variant: "outline",
      icon: faQuestionCircle,
    }
  );
}
</file>

<file path="src_frontend/tickets/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src_frontend/tickets/services/messages.ts">
import { Message } from "@/types/message";

const API_URL = 'http://localhost:5148';

interface GetMessagesParams {
  page: number;
  limit: number;
  userId: string;
  onlyUnread?: boolean;
}

interface MessagesResponse {
  messages: Message[];
  total: number;
}

export async function getMessages({ page, limit, userId, onlyUnread }: GetMessagesParams): Promise<MessagesResponse> {
  try {
    const response = await fetch(
      `${API_URL}/logged-users/${userId}/messages/?_page=${page}&_limit=${limit}${onlyUnread ? '&onlyUnread=true' : ''}`, 
      { cache: 'no-store' }
    );
    
    if (!response.ok) {
      throw new Error('Failed to fetch messages');
    }
    
    const responseData = await response.json();
    
    return { messages: responseData.data, total: responseData.total };
  } catch (error) {
    console.error('Error fetching messages:', error);
    return { messages: [], total: 0 };
  }
}

export async function toggleMessageReadStatus(id: string, isRead: boolean): Promise<void> {
  console.log(`Calling API: /messages/${id}?isRead=${isRead}`);
  const response = await fetch(
    `${API_URL}/messages/${id}?isRead=${isRead}`,
    {
      method: 'PUT',
      cache: 'no-store'
    }
  );

  if (!response.ok) {
    throw new Error('Failed to update message status');
  }
}
</file>

<file path="src_frontend/tickets/store/use-agent-store.ts">
import { create } from 'zustand'
import { persist, createJSONStorage } from 'zustand/middleware'
import { Agent } from '@/hooks/use-agents'

interface AgentState {
  selectedAgent: Agent | null
  setSelectedAgent: (agent: Agent | null) => void
}

export const useAgentStore = create<AgentState>()(
  persist(
    (set) => ({
      selectedAgent: null,
      setSelectedAgent: (agent) => set({ selectedAgent: agent }),
    }),
    {
      name: 'agent-storage',
      storage: createJSONStorage(() => localStorage),
    }
  )
)
</file>

<file path="src_frontend/tickets/types/alert.ts">
export interface Alert {
  id: string;
  message: string;
  createdAt: string;
  isRead: boolean;
  type: 'SLA' | 'Incydent';
}
</file>

<file path="src_frontend/tickets/types/message.ts">
export interface Message {
    id: string;
    title: string;
    preview: string;
    content: string;
    timestamp: string;
    isRead: boolean;
    senderDisplayName?: string;
    senderEmployeeId?: string;
  }
</file>

<file path="src_frontend/tickets/types/services.ts">
// Server response type
export interface ServiceMetricsResponse {
  name: string;
  status: 'Healthy' | 'Error' | 'Unknown';
  lastChecked: string;
  metrics?: {
    cpu: {
      usage: number;
    };
    memory: {
      used: number;
      total: number;
    };
  };
}

// Client-side type with history
export interface ServiceStatus {
  name: string;
  status: 'Healthy' | 'Error' | 'Unknown';
  lastChecked: string;
  metrics?: {
    cpu: {
      usage: number;
      history: Array<{
        timestamp: string;
        value: number;
      }>;
    };
    memory: {
      used: number;
      total: number;
      history: Array<{
        timestamp: string;
        value: number;
      }>;
    };
  };
}
</file>

<file path="src_frontend/tickets/types/ticket.ts">
import { TicketCategory, SeverityLevel, TicketStatus, TicketType } from '@/app/types/enums'

export interface Ticket {
  id: string;
  title: string;
  email: string;
  status: TicketStatus;
  createdAt: Date;
  deadline: Date | null;
  description: string;
  descriptionTranslated: string | null;
  severityLevel?: SeverityLevel | null;
  category: TicketCategory;
  type: TicketType;
  agentId?: string | null;
  resolution?: string | null;
}
</file>

<file path="src_frontend/tickets/.eslintrc.json">
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}
</file>

<file path="src_frontend/tickets/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="src_frontend/tickets/components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "zinc",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="src_frontend/tickets/next.config.mjs">
/** @type {import('next').NextConfig} */
const nextConfig = {
  basePath: '',
  async redirects() {
    return [
      {
        source: '/',
        destination: '/tickets-list',
        permanent: true,
      },
    ]
  },
}

export default nextConfig
</file>

<file path="src_frontend/tickets/package.json">
{
  "name": "tickets",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev -p 21001",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@fortawesome/fontawesome-svg-core": "^6.6.0",
    "@fortawesome/free-brands-svg-icons": "^6.6.0",
    "@fortawesome/free-solid-svg-icons": "^6.6.0",
    "@fortawesome/react-fontawesome": "^0.2.2",
    "@hookform/resolvers": "^3.9.1",
    "@microsoft/signalr": "^8.0.7",
    "@radix-ui/react-avatar": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-dropdown-menu": "^2.1.2",
    "@radix-ui/react-icons": "^1.3.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-navigation-menu": "^1.2.1",
    "@radix-ui/react-popover": "^1.1.2",
    "@radix-ui/react-select": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-switch": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@shadcn/ui": "^0.0.4",
    "@tanstack/react-query": "^5.59.20",
    "@tanstack/react-table": "^8.20.5",
    "@types/recharts": "^1.8.29",
    "axios": "^1.7.8",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "geist": "^1.3.1",
    "lucide-react": "^0.454.0",
    "next": "14.2.16",
    "next-themes": "^0.3.0",
    "react": "^18",
    "react-dom": "^18",
    "react-hook-form": "^7.53.1",
    "recharts": "^2.13.3",
    "shadcn-ui": "^0.2.3",
    "sonner": "^1.7.0",
    "tailwind-merge": "^2.5.4",
    "tailwindcss-animate": "^1.0.7",
    "use-debounce": "^10.0.4",
    "zod": "^3.23.8",
    "zustand": "^5.0.1"
  },
  "devDependencies": {
    "@types/next": "^9.0.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.16",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}
</file>

<file path="src_frontend/tickets/postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="src_frontend/tickets/tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
};
export default config;
</file>

<file path="src_frontend/tickets/tsconfig.json">
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src_frontend/check_port.js">
const net = require('net');
const port = process.argv[2];

function checkPort() {
    const socket = new net.Socket();
    
    socket.on('connect', () => {
        socket.destroy();
        process.exit(0);
    });
    
    socket.on('error', (err) => {
        socket.destroy();
        setTimeout(checkPort, 1000);
    });

    socket.connect(port, 'localhost');
}

checkPort();
</file>

<file path="src_frontend/kill_port.js">
const { execSync } = require('child_process');
const port = process.argv[2];

try {
    if (process.platform === 'win32') {
        const command = `for /f "tokens=5" %a in ('netstat -aon ^| findstr :${port}') do taskkill /F /PID %a 2>NUL`;
        execSync(command, { shell: 'cmd.exe', stdio: 'ignore' });
    } else {
        execSync(`lsof -i :${port} -t | xargs -r kill -9`, { stdio: 'ignore' });
    }
} catch (error) {
    // Ignore errors if no process is found
}
</file>

<file path="src_frontend/run_all_fe.sh">
#!/bin/bash

# Create a temporary Node.js script for killing processes
cat > kill_port.js << 'EOF'
const { execSync } = require('child_process');
const port = process.argv[2];

try {
    if (process.platform === 'win32') {
        const command = `for /f "tokens=5" %a in ('netstat -aon ^| findstr :${port}') do taskkill /F /PID %a 2>NUL`;
        execSync(command, { shell: 'cmd.exe', stdio: 'ignore' });
    } else {
        execSync(`lsof -i :${port} -t | xargs -r kill -9`, { stdio: 'ignore' });
    }
} catch (error) {
    // Ignore errors if no process is found
}
EOF

# Function to kill process using a specific port
kill_port() {
    local port=$1
    echo "Checking if port $port is in use..."
    node kill_port.js $port
}

# Kill existing processes
echo "Cleaning up existing processes..."
kill_port 21000
kill_port 21001
kill_port 21002

# Install dependencies in parallel
echo "Installing dependencies..."
(cd ./inquiries/ && npm install) &
(cd ./tickets/ && npm install) &
(cd ./technical/ && npm install) &
wait

# Create a temporary Node.js script for port checking
cat > check_port.js << 'EOF'
const net = require('net');
const port = process.argv[2];

function checkPort() {
    const socket = new net.Socket();
    
    socket.on('connect', () => {
        socket.destroy();
        process.exit(0);
    });
    
    socket.on('error', (err) => {
        socket.destroy();
        setTimeout(checkPort, 1000);
    });

    socket.connect(port, 'localhost');
}

checkPort();
EOF

# Function to wait for a port to be available
wait_for_port() {
    local port=$1
    echo "Waiting for port $port..."
    node check_port.js $port
}

# Function to warmup a Next.js application
warmup_app() {
    local port=$1
    echo "Warming up application on port $port..."
    curl -sSL "http://localhost:$port" > /dev/null 2>&1 || wget -q -O /dev/null "http://localhost:$port"
}

# Start dev servers in background
echo "Starting development servers..."
(cd ./inquiries/ && npm run dev) &
(cd ./tickets/ && npm run dev) &
(cd ./technical/ && npm run dev) &

# Wait for ports to be available and warmup each application
echo "Waiting for servers to be ready and warming up..."
wait_for_port 21000 && warmup_app 21000 &
wait_for_port 21001 && warmup_app 21001 &
wait_for_port 21002 && warmup_app 21002 &

# Wait for all warmup processes to complete
wait

# Clean up temporary files
rm check_port.js
rm kill_port.js

echo "All applications are running and warmed up!"
</file>

<file path="tests/Inquiries/TicketFlow.Services.Inquiries.IntegrationTests/Messaging/TranslationsServiceIntegrationTests.cs">
using System.Net.Http.Json;
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.Inquiries.Core.Commands.SubmitInquiry;
using TicketFlow.Services.Inquiries.Core.Data.Repositories;
using TicketFlow.Services.Inquiries.Core.LanguageDetection;
using TicketFlow.Services.Inquiries.Core.Messaging.Publishing;
using TicketFlow.Services.Inquiries.IntegrationTests.Mocks;
using TicketFlow.Shared.Testing;
using Xunit;

namespace TicketFlow.Services.Inquiries.IntegrationTests.Messaging;

public class TranslationsServiceIntegrationTests : IAsyncLifetime
{
    private readonly MessagingIntegrationTestProvider<Program> _messagingTestProvider;
   
    private const string QueueV1 = "request-translation-v1-queue";
    private const string QueueV2 = "request-translation-v2-queue";

    public TranslationsServiceIntegrationTests()
    {
        _messagingTestProvider = new MessagingIntegrationTestProvider<Program>(services =>
        {
            services.AddSingleton<ILanguageDetector, TestLanguageDetector>();
            services.AddSingleton<IInquiriesRepository, InquiriesTestRepository>();
        });
    }
    
   public async Task InitializeAsync()
    {
        await _messagingTestProvider.RabbitMqContainer.StartAsync();

        _messagingTestProvider.Initialize(channel =>
        {
            channel.ExchangeDeclare(exchange: "inquiry-submitted-exchange", type: "direct", durable: false, autoDelete: false, arguments: null);
            channel.QueueDeclare(queue: QueueV1, durable: false, exclusive: false, autoDelete: false, arguments: null);
            channel.QueueDeclare(queue: QueueV2, durable: false, exclusive: false, autoDelete: false, arguments: null);
        });
    }

    public async Task DisposeAsync()
    {
        await _messagingTestProvider.DisposeAsync();
    }

    [Fact]
    public async Task SubmitInquiry_Should_Publish_To_RabbitMq_Queues_When_Language_IsNot_English()
    {
        var client = _messagingTestProvider.Factory.CreateClient();
        var languageDetector = _messagingTestProvider.Factory.Services.GetRequiredService<ILanguageDetector>();
        ((TestLanguageDetector) languageDetector).ReturnedLanguage = "pl";

        var command = new SubmitInquiry(
            Name: "John Doe",
            Email: "john@example.com",
            Title: "Test Title",
            Description: "Test Description",
            Category: "general");

        var response = await client.PostAsJsonAsync("/inquiries/submit", command);
        response.EnsureSuccessStatusCode();

        var receivedMessageV1 = await _messagingTestProvider.ConsumeMessagesAsync<RequestTranslationV1>(QueueV1);
        var receivedMessageV2 = await _messagingTestProvider.ConsumeMessagesAsync<RequestTranslationV2>(QueueV2);

        receivedMessageV1.Should().Match<RequestTranslationV1>(msg => msg.Text == command.Description);
        receivedMessageV2.Should().Match<RequestTranslationV2>(msg =>
            msg.Text == command.Description &&
            msg.LanguageCode == "pl");
    }
    
    [Fact]
    public async Task SubmitInquiry_ShouldNot_Publish_To_RabbitMq_Queues_When_Language_Is_English()
    {
        var client = _messagingTestProvider.Factory.CreateClient();
        var languageDetector = _messagingTestProvider.Factory.Services.GetRequiredService<ILanguageDetector>();
        ((TestLanguageDetector) languageDetector).ReturnedLanguage = "en";

        var inquiry = new SubmitInquiry(
            Name: "John Doe",
            Email: "john@example.com",
            Title: "Test Title",
            Description: "Test Description",
            Category: "general");

        var response = await client.PostAsJsonAsync("/inquiries/submit", inquiry);
        response.EnsureSuccessStatusCode();

        var receivedMessageV1 = await _messagingTestProvider.ConsumeMessagesAsync<RequestTranslationV1>(QueueV1);
        var receivedMessageV2 = await _messagingTestProvider.ConsumeMessagesAsync<RequestTranslationV2>(QueueV2);

        receivedMessageV1.Should().BeNull();
        receivedMessageV2.Should().BeNull();
    }
}
</file>

<file path="tests/Inquiries/TicketFlow.Services.Inquiries.IntegrationTests/Mocks/InquiriesTestRepository.cs">
using TicketFlow.Services.Inquiries.Core.Data.Models;
using TicketFlow.Services.Inquiries.Core.Data.Repositories;

namespace TicketFlow.Services.Inquiries.IntegrationTests.Mocks;

internal sealed class InquiriesTestRepository : IInquiriesRepository
{
    public Task<IEnumerable<Inquiry>> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
        => Task.FromResult(Enumerable.Empty<Inquiry>());

    public Task<Inquiry?> GetAsync(Guid id, CancellationToken cancellationToken = default)
        => Task.FromResult(default(Inquiry));

    public Task AddAsync(Inquiry inquiry, CancellationToken cancellationToken = default)
        => Task.CompletedTask;


    public Task UpdateAsync(Inquiry inquiry, CancellationToken cancellationToken = default)
        => Task.CompletedTask;
}
</file>

<file path="tests/Inquiries/TicketFlow.Services.Inquiries.IntegrationTests/Mocks/TestLanguageDetector.cs">
using TicketFlow.Services.Inquiries.Core.LanguageDetection;

namespace TicketFlow.Services.Inquiries.IntegrationTests.Mocks;

internal sealed class TestLanguageDetector : ILanguageDetector
{
    public string ReturnedLanguage { get; set; }
    
    public Task<string> GetTextLanguageCode(string text, CancellationToken cancellationToken = default)
        => Task.FromResult(ReturnedLanguage ?? "en");
}
</file>

<file path="tests/Inquiries/TicketFlow.Services.Inquiries.IntegrationTests/TicketFlow.Services.Inquiries.IntegrationTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\..\src\Inquiries\TicketFlow.Services.Inquiries.Api\TicketFlow.Services.Inquiries.Api.csproj" />
      <ProjectReference Include="..\..\..\src\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj" />
    </ItemGroup>

    <ItemGroup>
      <PackageReference Include="FluentAssertions" Version="7.0.0" />
      <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
      <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
      <PackageReference Include="xunit" Version="2.9.2" />
    </ItemGroup>

</Project>
</file>

<file path="tests/Translations/TicketFlow.Services.Translations.IntegrationTests/Messaging/InquiriesServiceIntegrationTests.cs">
using FluentAssertions;
using Microsoft.Extensions.DependencyInjection;
using TicketFlow.Services.Translations.Core.Messaging.Consuming.RequestTranslation;
using TicketFlow.Services.Translations.Core.Messaging.Publishing;
using TicketFlow.Services.Translations.Core.Translations;
using TicketFlow.Services.Translations.IntegrationTests.Mocks;
using TicketFlow.Shared.Testing;
using Xunit;

namespace TicketFlow.Services.Translations.IntegrationTests.Messaging;

public class InquiriesServiceIntegrationTests : IAsyncLifetime
{
    private readonly MessagingIntegrationTestProvider<Program> _messagingTestProvider;
       
    private const string IncomingQueue = "request-translation-v2-queue";
    private const string TestQueue = "test-queue";
    private const string Exchange = "translation-completed-exchange";

    public InquiriesServiceIntegrationTests()
    {
        _messagingTestProvider = new MessagingIntegrationTestProvider<Program>(services =>
        {
            services.AddSingleton<ITranslationsService, TestTranslationsService>();
        });
    }
    
   public async Task InitializeAsync()
    {
        await _messagingTestProvider.RabbitMqContainer.StartAsync();

        _messagingTestProvider.Initialize(channel =>
        {
            channel.QueueDeclare(queue: IncomingQueue, durable: false, exclusive: false, autoDelete: false, arguments: null);
            channel.ExchangeDeclare(exchange: Exchange, type: "topic", durable: false, autoDelete: false, arguments: null);
            channel.QueueDeclare(queue: TestQueue, durable: false, exclusive: false, autoDelete: false, arguments: null);
            channel.QueueBind(TestQueue, Exchange, routingKey: "#", arguments: null);
        });
    }

    public async Task DisposeAsync()
    {
        await _messagingTestProvider.DisposeAsync();
    }

    [Fact]
    public async Task RequestTranslation_Should_Publish_To_RabbitMq_TranslationCompleted_When_Translation_Is_Successful()
    {
        var translationsService = _messagingTestProvider.Factory.Services.GetRequiredService<ITranslationsService>();
        var mockedResult = "TEST RESULT";
        ((TestTranslationsService) translationsService).TranslatedText = mockedResult;
        
        var message = new RequestTranslationV2("Test Text", "pl", Guid.NewGuid());
        
        var translationCompletedTask = _messagingTestProvider.ConsumeMessagesAsync<TranslationCompleted>(TestQueue, maxDelay: 10_000);
        _messagingTestProvider.Publish(message, "", routingKey: IncomingQueue);
        
        var translationCompleted = await translationCompletedTask;
        translationCompleted.Should().Match<TranslationCompleted>(msg => 
            msg.TranslatedText == mockedResult && msg.ReferenceId == message.ReferenceId);
    }
    
    [Fact]
    public async Task RequestTranslation_Should_Publish_To_RabbitMq_TranslationSkipped_When_Translation_Is_Missing()
    {
        var translationsService = _messagingTestProvider.Factory.Services.GetRequiredService<ITranslationsService>();
        var mockedResult = "";
        ((TestTranslationsService) translationsService).TranslatedText = mockedResult;
        
        var message = new RequestTranslationV2("Test Text", "pl", Guid.NewGuid());
        
        var translationCompletedTask = _messagingTestProvider.ConsumeMessagesAsync<TranslationSkipped>(TestQueue);
        _messagingTestProvider.Publish(message, "", routingKey: IncomingQueue);
        
        var translationCompleted = await translationCompletedTask;
        translationCompleted.Should().Match<TranslationSkipped>(msg => msg.ReferenceId == message.ReferenceId);
    }
}
</file>

<file path="tests/Translations/TicketFlow.Services.Translations.IntegrationTests/Mocks/TestTranslationsService.cs">
using TicketFlow.Services.Translations.Core.Translations;

namespace TicketFlow.Services.Translations.IntegrationTests.Mocks;

public class TestTranslationsService : ITranslationsService
{
    public string TranslatedText { get; set; }
    
    public Task<string> TranslateAsync(string text, string? translateFrom, string translateTo, CancellationToken cancellationToken = default)
        => Task.FromResult(TranslatedText);
}
</file>

<file path="tests/Translations/TicketFlow.Services.Translations.IntegrationTests/TicketFlow.Services.Translations.IntegrationTests.csproj">
<Project Sdk="Microsoft.NET.Sdk">

    <PropertyGroup>
        <TargetFramework>net9.0</TargetFramework>
        <ImplicitUsings>enable</ImplicitUsings>
        <Nullable>enable</Nullable>
    </PropertyGroup>

    <ItemGroup>
        <PackageReference Include="FluentAssertions" Version="7.0.0" />
        <PackageReference Include="Microsoft.AspNetCore.Mvc.Testing" Version="9.0.0" />
        <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.12.0" />
        <PackageReference Include="xunit" Version="2.9.2" />
    </ItemGroup>

    <ItemGroup>
      <ProjectReference Include="..\..\..\src\Translations\TicketFlow.Services.Translations.Api\TicketFlow.Services.Translations.Api.csproj" />
    </ItemGroup>

</Project>
</file>

<file path=".gitignore">
## Ignore Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*.userosscache
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.lock.json
project.fragment.lock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by Visual Studio
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml

.cursorrules
</file>

<file path="README.md">
[![baner](./docs/images/baner.png)](https://messaging-pragmatycznie.pl/)

 # Czym jest projekt TicketFlow?
 Ticketflow to **rozproszony** **system ticketowy**, w którym w prosty sposób zespół anglojezyczny jest w stanie obsługiwać zgłoszenia klientów z całego świata. Dodatkowo, by utrzymać SLA wynikające z umów podpisanych z klientami, system (poza wspieraniem procesu obsługi ticketow) wspiera agentów service desk w postaci przypomnień, alertowania czy prezentowania metryk na żywo.

 Cały system został w całości oparty o **komunikację asynchroniczną**, a jego omawianie jest przedmiotem kursu [**Messaging:Pragmatycznie**](https://messaging-pragmatycznie.pl/), w którym poruszamy m.in. tematy:

- RabbitMQ i protokołu AMQP
- Producenta/konsumenta wiadomości
- Topologii komunikacji asynchronicznej
- Deduplikacji wiadomości
- Tranzakcyjnego publikowania wiadomości
- Kolejności przetwarzania wiadomości
- Obsługi błędów
- Azure Service Bus
- Message Streaming (Kafka)
- Testowania integracyjnego

# Topologia systemu TicketFlow
W systemie masz moliwość uruchomienia następujących przypadków użycia:

- dodanie zgłoszenia
- tłumaczenie zgłoszenia
- tworzenie ticketu
- kwalifikacja ticketu
- przypisanie agenta do ticketu
- osbługa przypomnień
- blokowanie/odblokowywanie ticketu
- obliczanie deadline-ów obsługi zgłoszeń
- rozwiązywanie ticketów i komunikacja z klientem

 Na pierwszy rzut oka możesz pomyśleć, że tak mały scope w systemach rozproszonych nie ma sensu. Po co komplikować życie, zamiast umieścić wszystko w monolicie? Powód jest prosty – **rzeczywistość wygląda inaczej**. Większość rozwiązań messagingowych działa właśnie w środowiskach rozproszonych, gdzie niedostępność usług, partycjonowanie sieci czy replikacja dramatycznie wpływają na komunikację asynchroniczną i ujawniają słabości systemu. Dlatego zaprojektowaliśmy ten kurs tak, aby jak najbardziej oddawał realia produkcyjne. Zresztą... patrząc na samą topologię zauważysz, że to zdecydowanie nie będzie prosty system à la "Hello World!" ;)

![topologia](./docs/images/topologia.png)


# Jak uruchomić projekt?

Do uruchomienia wymagany jest **Docker Desktop** lub **Rancher Dektop**!


### Infrastruktura

```bash
sh ./run_infra.sh
```

### Wyczysczenie wszystkich baz danych i topologii RabbitMQ

```bash
 cd ./wipe_and_rebuild_infra.sh
```

### Zbudowanie i wykonanie migracji bazodanowych

```bash
 cd ./src && sh ./run_all_migrations.sh
```

### Uruchomienie wszystkich usług

```bash
 sh ./run_ticketflow.sh
```

### Uruchomienie interfejsu uutkownika

```bash
 cd ./src_frontend && sh ./run_all_fe.sh
```

UI dostępny jest pod adresem `localhost:21000`

![UI](./docs/images/UI.png)


# System anomalii
Gdy po raz pierwszy siadaliśmy do budowania listy modułów i rozpisywania lekcji, jedną z głównych rzeczy która wydawała się nam upierdliwa w wykonaniu było płynne i w miarę bezobsługowe pokazanie osobie przechodzącej przez kurs jak na różne problemy w systemie rozproszonym reaguje nasza modelowa aplikacja.

Doszliśmy do wniosku, że skoro budujemy UI do TicketFlow, to powinniśmy także umożliwić Ci odkrywanie, jak system się zachowa, gdy w wybrane miejsce wkradnie się problem.

🧪 Tak też powstał system generowanie anomalii w TicketFlow, o którym [**przeczytasz** **tutaj**](./docs/ANOMALIE.md)!

![anomalie](./docs/images/anomalie.png)
</file>

<file path="run_infra.sh">
cd ./compose
docker build -t rabbitmq-che .
docker compose up -d
</file>

<file path="run_ticketflow.sh">
#!/bin/bash

# Infra
echo "Starting infra..."
sh ./run_infra.sh
echo "Waiting for infra background processes for 10s..."
sleep 10

# Build backend first
(cd src && ./run_all_migrations.sh) || { echo "Backend build failed"; exit 1; }

# Start all services in parallel
echo "Starting all services..."

# Start frontend applications
(cd src_frontend && ./run_all_fe.sh) &

# Start mock API
(cd src_frontend && ./run_mock_api.sh) &

# Start backend services
(cd src && ./run_all_be.sh) &

# Clear the terminal after a brief pause to let services start
sleep 2
clear

echo "All services are running..."
echo "Press Ctrl+C to stop all services"
</file>

<file path="TicketFlow.sln">
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31903.59
MinimumVisualStudioVersion = 10.0.40219.1
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Inquiries", "Inquiries", "{18C31847-2E70-451C-B608-22E64CCDC1A8}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Inquiries.Api", "src\Inquiries\TicketFlow.Services.Inquiries.Api\TicketFlow.Services.Inquiries.Api.csproj", "{425D58FD-4433-4607-91F1-2FD1955A025E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Inquiries.Core", "src\Inquiries\TicketFlow.Services.Inquiries.Core\TicketFlow.Services.Inquiries.Core.csproj", "{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Tickets", "Tickets", "{07DCBB3E-83FB-4E64-B0B0-FA380966A16A}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Tickets.Core", "src\Tickets\TicketFlow.Services.Tickets.Core\TicketFlow.Services.Tickets.Core.csproj", "{285DF664-485F-4447-BF64-F3DF02610A4D}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Tickets.Api", "src\Tickets\TicketFlow.Services.Tickets.Api\TicketFlow.Services.Tickets.Api.csproj", "{9CDAFE0B-3277-4BA4-873C-083093BDAA24}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Translations", "Translations", "{22569C41-4C87-4AB6-8F1A-DF86F51A3E58}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Translations.Api", "src\Translations\TicketFlow.Services.Translations.Api\TicketFlow.Services.Translations.Api.csproj", "{5CCED511-747C-4F72-98D6-A4C0ADB9F949}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Translations.Core", "src\Translations\TicketFlow.Services.Translations.Core\TicketFlow.Services.Translations.Core.csproj", "{33BE366B-3422-4F73-BC65-1F73D805C1AD}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "SLA", "SLA", "{4FAD02DF-37B5-4946-ABD8-922DC9C19893}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.SLA.Core", "src\SLA\TicketFlow.Services.SLA.Core\TicketFlow.Services.SLA.Core.csproj", "{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.SLA.Api", "src\SLA\TicketFlow.Services.SLA.Api\TicketFlow.Services.SLA.Api.csproj", "{5069C338-D69A-4694-994F-1CA851355F57}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Communication", "Communication", "{9FEC8D86-638C-42D7-AC4F-DD3E0F2DA95E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Communication.Api", "src\Communication\TicketFlow.Services.Communication.Api\TicketFlow.Services.Communication.Api.csproj", "{48D19E98-B3CF-4325-A3D1-2F07CB1FD488}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Communication.Core", "src\Communication\TicketFlow.Services.Communication.Core\TicketFlow.Services.Communication.Core.csproj", "{3F5D015B-308B-470D-9F00-EECACAE0A0AA}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Shared", "Shared", "{B106A5A0-3379-4C18-9A42-58B6A64EE99B}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Shared", "src\Shared\TicketFlow.Shared\TicketFlow.Shared.csproj", "{91277A53-FE99-4F39-9C30-60866780029E}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "SystemMetrics", "SystemMetrics", "{2C0A89DC-360C-44E0-A12D-C3051EECA590}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.SystemMetrics.Core", "src\SystemMetrics\TicketFlow.Services.SystemMetrics.Core\TicketFlow.Services.SystemMetrics.Core.csproj", "{66DF4D54-C851-418C-846C-A548E1726C4E}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.SystemMetrics.Api", "src\SystemMetrics\TicketFlow.Services.SystemMetrics.Api\TicketFlow.Services.SystemMetrics.Api.csproj", "{55D72A45-C58B-46FE-BA1F-64816FA41928}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Communication.Alerting", "src\Communication\TicketFlow.Services.Communication.Alerting\TicketFlow.Services.Communication.Alerting.csproj", "{53F728C9-4BA9-4E8B-B6BF-0B170B637E01}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.SystemMetrics.Generator", "src\SystemMetrics\TicketFlow.Services.SystemMetrics.Generator\TicketFlow.Services.SystemMetrics.Generator.csproj", "{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.CourseUtils", "src\Shared\TicketFlow.CourseUtils\TicketFlow.CourseUtils.csproj", "{B569981C-50EB-49D7-A445-FDF1F62D7DD3}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Inquiries.IntegrationTests", "tests\Inquiries\TicketFlow.Services.Inquiries.IntegrationTests\TicketFlow.Services.Inquiries.IntegrationTests.csproj", "{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TicketFlow.Services.Translations.IntegrationTests", "tests\Translations\TicketFlow.Services.Translations.IntegrationTests\TicketFlow.Services.Translations.IntegrationTests.csproj", "{0153A7C4-04A0-47D6-963E-95558FFE0B91}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{425D58FD-4433-4607-91F1-2FD1955A025E} = {18C31847-2E70-451C-B608-22E64CCDC1A8}
		{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED} = {18C31847-2E70-451C-B608-22E64CCDC1A8}
		{285DF664-485F-4447-BF64-F3DF02610A4D} = {07DCBB3E-83FB-4E64-B0B0-FA380966A16A}
		{9CDAFE0B-3277-4BA4-873C-083093BDAA24} = {07DCBB3E-83FB-4E64-B0B0-FA380966A16A}
		{5CCED511-747C-4F72-98D6-A4C0ADB9F949} = {22569C41-4C87-4AB6-8F1A-DF86F51A3E58}
		{33BE366B-3422-4F73-BC65-1F73D805C1AD} = {22569C41-4C87-4AB6-8F1A-DF86F51A3E58}
		{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5} = {4FAD02DF-37B5-4946-ABD8-922DC9C19893}
		{5069C338-D69A-4694-994F-1CA851355F57} = {4FAD02DF-37B5-4946-ABD8-922DC9C19893}
		{48D19E98-B3CF-4325-A3D1-2F07CB1FD488} = {9FEC8D86-638C-42D7-AC4F-DD3E0F2DA95E}
		{3F5D015B-308B-470D-9F00-EECACAE0A0AA} = {9FEC8D86-638C-42D7-AC4F-DD3E0F2DA95E}
		{91277A53-FE99-4F39-9C30-60866780029E} = {B106A5A0-3379-4C18-9A42-58B6A64EE99B}
		{66DF4D54-C851-418C-846C-A548E1726C4E} = {2C0A89DC-360C-44E0-A12D-C3051EECA590}
		{55D72A45-C58B-46FE-BA1F-64816FA41928} = {2C0A89DC-360C-44E0-A12D-C3051EECA590}
		{53F728C9-4BA9-4E8B-B6BF-0B170B637E01} = {9FEC8D86-638C-42D7-AC4F-DD3E0F2DA95E}
		{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE} = {2C0A89DC-360C-44E0-A12D-C3051EECA590}
		{B569981C-50EB-49D7-A445-FDF1F62D7DD3} = {B106A5A0-3379-4C18-9A42-58B6A64EE99B}
		{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752} = {18C31847-2E70-451C-B608-22E64CCDC1A8}
		{0153A7C4-04A0-47D6-963E-95558FFE0B91} = {22569C41-4C87-4AB6-8F1A-DF86F51A3E58}
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{425D58FD-4433-4607-91F1-2FD1955A025E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{425D58FD-4433-4607-91F1-2FD1955A025E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{425D58FD-4433-4607-91F1-2FD1955A025E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{425D58FD-4433-4607-91F1-2FD1955A025E}.Release|Any CPU.Build.0 = Release|Any CPU
		{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{27367E15-D4E4-4282-8FA6-8FBD9DB0BAED}.Release|Any CPU.Build.0 = Release|Any CPU
		{285DF664-485F-4447-BF64-F3DF02610A4D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{285DF664-485F-4447-BF64-F3DF02610A4D}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{285DF664-485F-4447-BF64-F3DF02610A4D}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{285DF664-485F-4447-BF64-F3DF02610A4D}.Release|Any CPU.Build.0 = Release|Any CPU
		{9CDAFE0B-3277-4BA4-873C-083093BDAA24}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{9CDAFE0B-3277-4BA4-873C-083093BDAA24}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{9CDAFE0B-3277-4BA4-873C-083093BDAA24}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{9CDAFE0B-3277-4BA4-873C-083093BDAA24}.Release|Any CPU.Build.0 = Release|Any CPU
		{5CCED511-747C-4F72-98D6-A4C0ADB9F949}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5CCED511-747C-4F72-98D6-A4C0ADB9F949}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5CCED511-747C-4F72-98D6-A4C0ADB9F949}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5CCED511-747C-4F72-98D6-A4C0ADB9F949}.Release|Any CPU.Build.0 = Release|Any CPU
		{33BE366B-3422-4F73-BC65-1F73D805C1AD}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{33BE366B-3422-4F73-BC65-1F73D805C1AD}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{33BE366B-3422-4F73-BC65-1F73D805C1AD}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{33BE366B-3422-4F73-BC65-1F73D805C1AD}.Release|Any CPU.Build.0 = Release|Any CPU
		{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0E11CE9E-8FC7-4780-84F0-9E6FF7D25CE5}.Release|Any CPU.Build.0 = Release|Any CPU
		{5069C338-D69A-4694-994F-1CA851355F57}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{5069C338-D69A-4694-994F-1CA851355F57}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{5069C338-D69A-4694-994F-1CA851355F57}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{5069C338-D69A-4694-994F-1CA851355F57}.Release|Any CPU.Build.0 = Release|Any CPU
		{48D19E98-B3CF-4325-A3D1-2F07CB1FD488}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{48D19E98-B3CF-4325-A3D1-2F07CB1FD488}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{48D19E98-B3CF-4325-A3D1-2F07CB1FD488}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{48D19E98-B3CF-4325-A3D1-2F07CB1FD488}.Release|Any CPU.Build.0 = Release|Any CPU
		{3F5D015B-308B-470D-9F00-EECACAE0A0AA}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{3F5D015B-308B-470D-9F00-EECACAE0A0AA}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{3F5D015B-308B-470D-9F00-EECACAE0A0AA}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{3F5D015B-308B-470D-9F00-EECACAE0A0AA}.Release|Any CPU.Build.0 = Release|Any CPU
		{91277A53-FE99-4F39-9C30-60866780029E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{91277A53-FE99-4F39-9C30-60866780029E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{91277A53-FE99-4F39-9C30-60866780029E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{91277A53-FE99-4F39-9C30-60866780029E}.Release|Any CPU.Build.0 = Release|Any CPU
		{66DF4D54-C851-418C-846C-A548E1726C4E}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{66DF4D54-C851-418C-846C-A548E1726C4E}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{66DF4D54-C851-418C-846C-A548E1726C4E}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{66DF4D54-C851-418C-846C-A548E1726C4E}.Release|Any CPU.Build.0 = Release|Any CPU
		{55D72A45-C58B-46FE-BA1F-64816FA41928}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{55D72A45-C58B-46FE-BA1F-64816FA41928}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{55D72A45-C58B-46FE-BA1F-64816FA41928}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{55D72A45-C58B-46FE-BA1F-64816FA41928}.Release|Any CPU.Build.0 = Release|Any CPU
		{53F728C9-4BA9-4E8B-B6BF-0B170B637E01}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{53F728C9-4BA9-4E8B-B6BF-0B170B637E01}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{53F728C9-4BA9-4E8B-B6BF-0B170B637E01}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{53F728C9-4BA9-4E8B-B6BF-0B170B637E01}.Release|Any CPU.Build.0 = Release|Any CPU
		{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B9D65BC3-86A7-4777-B93F-E861DEBDA3DE}.Release|Any CPU.Build.0 = Release|Any CPU
		{B569981C-50EB-49D7-A445-FDF1F62D7DD3}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{B569981C-50EB-49D7-A445-FDF1F62D7DD3}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{B569981C-50EB-49D7-A445-FDF1F62D7DD3}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{B569981C-50EB-49D7-A445-FDF1F62D7DD3}.Release|Any CPU.Build.0 = Release|Any CPU
		{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7BB0714A-0C7B-4190-BD0E-7B5BCE90D752}.Release|Any CPU.Build.0 = Release|Any CPU
		{0153A7C4-04A0-47D6-963E-95558FFE0B91}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{0153A7C4-04A0-47D6-963E-95558FFE0B91}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{0153A7C4-04A0-47D6-963E-95558FFE0B91}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{0153A7C4-04A0-47D6-963E-95558FFE0B91}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
EndGlobal
</file>

<file path="wipe_and_rebuild_infra.sh">
cd ./compose
docker compose down -v
docker compose stop && docker compose rm -f -v
cd .. && sh ./run_infra.sh
cd ./src && sh ./run_all_migrations.sh
</file>

</files>
